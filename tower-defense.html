<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: #0a0a12;
      overflow: hidden;
      height: 100%;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    #root { height: 100%; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
const TowerDefenseGame = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  // Responsive scaling
  const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight });

  useEffect(() => {
    const handleResize = () => setWindowSize({ width: window.innerWidth, height: window.innerHeight });
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Calculate responsive cell size
  const GRID_SIZE = 15;
  const maxGridHeight = windowSize.height - 180;
  const maxGridWidth = windowSize.width - 450;
  const CELL_SIZE = Math.max(24, Math.min(42, Math.floor(Math.min(maxGridHeight, maxGridWidth) / GRID_SIZE) - 2));
  const GRID_OFFSET = 8;

  // Game state
  const [gameState, setGameState] = useState('menu');
  const [grid, setGrid] = useState(() => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)));
  const [towers, setTowers] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [projectiles, setProjectiles] = useState([]);
  const [particles, setParticles] = useState([]);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const [announcements, setAnnouncements] = useState([]);
  const [wave, setWave] = useState(1);
  const [lives, setLives] = useState(20);
  const [gold, setGold] = useState(150);
  const [selectedTower, setSelectedTower] = useState(null);
  const [hoveredCell, setHoveredCell] = useState(null);
  const [path, setPath] = useState([]);
  const [waveInProgress, setWaveInProgress] = useState(false);
  const [enemiesSpawned, setEnemiesSpawned] = useState(0);
  const [totalEnemiesInWave, setTotalEnemiesInWave] = useState(0);
  const [totalScore, setTotalScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [maxCombo, setMaxCombo] = useState(0);
  const [comboTimer, setComboTimer] = useState(0);
  const [screenShake, setScreenShake] = useState({ x: 0, y: 0 });
  const [selectedTowerForUpgrade, setSelectedTowerForUpgrade] = useState(null);
  const [killCount, setKillCount] = useState(0);
  const [waveEnemyList, setWaveEnemyList] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(1);
  const [showHotkeys, setShowHotkeys] = useState(true);
  const [lastDamageTime, setLastDamageTime] = useState(0);
  const [totalDamageDealt, setTotalDamageDealt] = useState(0);

  // Refs
  const spawnTimerRef = useRef(null);
  const enemiesRef = useRef(enemies);
  const towersRef = useRef(towers);
  const pathRef = useRef(path);
  const goldRef = useRef(gold);

  useEffect(() => { enemiesRef.current = enemies; }, [enemies]);
  useEffect(() => { towersRef.current = towers; }, [towers]);
  useEffect(() => { pathRef.current = path; }, [path]);
  useEffect(() => { goldRef.current = gold; }, [gold]);

  const theme = {
    bg: '#0a0a12',
    bgPanel: '#14141f',
    bgDark: '#0a0a10',
    bgCell: '#0e0e16',
    accent: '#7c6aed',
    accentBright: '#9d8cff',
    accentGlow: 'rgba(124, 106, 237, 0.6)',
    gold: '#ffd700',
    goldGlow: 'rgba(255, 215, 0, 0.5)',
    error: '#ff4757',
    errorGlow: 'rgba(255, 71, 87, 0.5)',
    success: '#2ed573',
    successGlow: 'rgba(46, 213, 115, 0.5)',
    frost: '#70c9ff',
    fire: '#ff6b35',
    lightning: '#fff200',
    poison: '#a55eea',
    text: '#f0f0ff',
    textSecondary: '#9090b0',
    textMuted: '#505068',
    border: '#252540',
    pathColor: 'rgba(124, 106, 237, 0.25)',
    pathGlow: 'rgba(124, 106, 237, 0.4)',
  };

  const towerTypes = {
    arrow: {
      id: 'arrow', name: 'Arrow', emoji: 'üèπ', cost: 30, hotkey: '1',
      damage: 12, range: 3.5, fireRate: 700, color: '#2ed573',
      projectileSpeed: 18, projectileSize: 4, critChance: 0.15,
      desc: 'Fast ‚Ä¢ 15% crit',
      upgrades: [
        { cost: 40, damage: 18, fireRate: 600, name: 'Sharp' },
        { cost: 80, damage: 28, fireRate: 500, critChance: 0.25, name: 'Precise' },
        { cost: 150, damage: 40, fireRate: 400, critChance: 0.35, range: 4, name: 'Master' },
      ]
    },
    cannon: {
      id: 'cannon', name: 'Cannon', emoji: 'üí£', cost: 60, hotkey: '2',
      damage: 45, range: 2.8, fireRate: 1800, color: '#ff6b35',
      splash: 1.2, projectileSpeed: 10, projectileSize: 8,
      desc: 'Splash damage',
      upgrades: [
        { cost: 50, damage: 65, splash: 1.4, name: 'Big' },
        { cost: 100, damage: 90, splash: 1.6, fireRate: 1600, name: 'Heavy' },
        { cost: 180, damage: 130, splash: 2, fireRate: 1400, name: 'Mega' },
      ]
    },
    sniper: {
      id: 'sniper', name: 'Sniper', emoji: 'üéØ', cost: 80, hotkey: '3',
      damage: 75, range: 6, fireRate: 2200, color: '#5352ed',
      projectileSpeed: 30, projectileSize: 3,
      desc: 'Long range',
      upgrades: [
        { cost: 60, damage: 110, range: 7, name: 'Scope' },
        { cost: 120, damage: 160, name: 'Pierce' },
        { cost: 200, damage: 250, range: 8, fireRate: 1800, name: 'Rail' },
      ]
    },
    frost: {
      id: 'frost', name: 'Frost', emoji: '‚ùÑÔ∏è', cost: 50, hotkey: '4',
      damage: 8, range: 3, fireRate: 500, color: '#70c9ff',
      slow: 0.4, slowDuration: 2500, projectileSpeed: 14, projectileSize: 6,
      desc: 'Slows 40%',
      upgrades: [
        { cost: 45, slow: 0.5, slowDuration: 3000, name: 'Deep' },
        { cost: 90, slow: 0.6, slowDuration: 3500, damage: 15, name: 'Perma' },
        { cost: 160, slow: 0.7, slowDuration: 4000, damage: 25, range: 3.5, name: 'Zero' },
      ]
    },
    lightning: {
      id: 'lightning', name: 'Tesla', emoji: '‚ö°', cost: 100, hotkey: '5',
      damage: 20, range: 3.2, fireRate: 350, color: '#fff200',
      chain: 4, chainDamageDecay: 0.7, projectileSpeed: 50, projectileSize: 2,
      desc: 'Chain √ó4',
      upgrades: [
        { cost: 70, damage: 30, chain: 5, name: 'Arc' },
        { cost: 140, damage: 45, chain: 6, chainDamageDecay: 0.8, name: 'Over' },
        { cost: 220, damage: 65, chain: 8, fireRate: 280, name: 'Storm' },
      ]
    },
    poison: {
      id: 'poison', name: 'Plague', emoji: '‚ò†Ô∏è', cost: 70, hotkey: '6',
      damage: 5, range: 2.5, fireRate: 1200, color: '#a55eea',
      poisonDamage: 8, poisonDuration: 4000, splashPoison: 0.8,
      projectileSpeed: 12, projectileSize: 7,
      desc: 'DoT + AoE',
      upgrades: [
        { cost: 55, poisonDamage: 14, poisonDuration: 5000, name: 'Viral' },
        { cost: 110, poisonDamage: 22, splashPoison: 1.2, name: 'Plague' },
        { cost: 190, poisonDamage: 35, poisonDuration: 6000, damage: 15, name: 'Blight' },
      ]
    },
    laser: {
      id: 'laser', name: 'Laser', emoji: 'üî¥', cost: 120, hotkey: '7',
      damage: 3, range: 4, fireRate: 50, color: '#ff4757',
      beam: true, projectileSpeed: 999, projectileSize: 3,
      desc: 'Continuous',
      upgrades: [
        { cost: 80, damage: 5, range: 4.5, name: 'Focus' },
        { cost: 150, damage: 8, range: 5, name: 'High' },
        { cost: 250, damage: 12, range: 5.5, name: 'Death' },
      ]
    },
  };

  const enemyTypes = {
    slime: { id: 'slime', name: 'Slime', emoji: 'üü¢', health: 40, speed: 0.9, reward: 8, color: '#2ed573', size: 1 },
    scout: { id: 'scout', name: 'Scout', emoji: 'üîµ', health: 25, speed: 1.8, reward: 12, color: '#5352ed', size: 0.9 },
    tank: { id: 'tank', name: 'Golem', emoji: 'üü§', health: 180, speed: 0.45, reward: 25, color: '#cd6133', size: 1.3 },
    swarm: { id: 'swarm', name: 'Bug', emoji: 'üêõ', health: 15, speed: 1.4, reward: 5, color: '#7bed9f', size: 0.7 },
    healer: { id: 'healer', name: 'Medic', emoji: 'üíö', health: 60, speed: 0.7, reward: 20, color: '#26de81', size: 1, heals: true },
    shielded: { id: 'shielded', name: 'Knight', emoji: 'üõ°Ô∏è', health: 100, speed: 0.6, reward: 30, color: '#778ca3', size: 1.1, shield: 50 },
    splitter: { id: 'splitter', name: 'Amoeba', emoji: 'ü´ß', health: 80, speed: 0.8, reward: 15, color: '#a55eea', size: 1.1, splits: 2 },
    boss: { id: 'boss', name: 'Dragon', emoji: 'üêâ', health: 800, speed: 0.35, reward: 150, color: '#ff4757', size: 1.8, isBoss: true },
    megaBoss: { id: 'megaBoss', name: 'Titan', emoji: 'üëπ', health: 2000, speed: 0.25, reward: 300, color: '#ff0000', size: 2.2, isBoss: true },
  };

  const START = { row: 0, col: Math.floor(GRID_SIZE / 2) };
  const END = { row: GRID_SIZE - 1, col: Math.floor(GRID_SIZE / 2) };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (gameState !== 'playing') return;

      const key = e.key;
      const towerKeys = { '1': 'arrow', '2': 'cannon', '3': 'sniper', '4': 'frost', '5': 'lightning', '6': 'poison', '7': 'laser' };

      if (towerKeys[key] && goldRef.current >= towerTypes[towerKeys[key]].cost) {
        setSelectedTower(towerKeys[key]);
        setSelectedTowerForUpgrade(null);
      }
      if (key === 'Escape') {
        setSelectedTower(null);
        setSelectedTowerForUpgrade(null);
      }
      if (key === ' ' && !waveInProgress) {
        e.preventDefault();
        startWave();
      }
      if (key === 'u' && selectedTowerForUpgrade) {
        upgradeTower(selectedTowerForUpgrade.id);
      }
      if (key === 's' && selectedTowerForUpgrade) {
        sellTower(selectedTowerForUpgrade.id);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState, waveInProgress, selectedTowerForUpgrade]);

  // Pathfinding
  const findPath = useCallback((gridState) => {
    const queue = [[START.row, START.col]];
    const visited = new Set();
    const parent = new Map();
    visited.add(`${START.row},${START.col}`);
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    while (queue.length > 0) {
      const [row, col] = queue.shift();
      if (row === END.row && col === END.col) {
        const pathResult = [];
        let current = `${END.row},${END.col}`;
        while (current) {
          const [r, c] = current.split(',').map(Number);
          pathResult.unshift({ row: r, col: c });
          current = parent.get(current);
        }
        return pathResult;
      }
      for (const [dr, dc] of directions) {
        const newRow = row + dr;
        const newCol = col + dc;
        const key = `${newRow},${newCol}`;
        if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE &&
            !visited.has(key) && gridState[newRow][newCol] === null) {
          visited.add(key);
          parent.set(key, `${row},${col}`);
          queue.push([newRow, newCol]);
        }
      }
    }
    return null;
  }, []);

  // Spawn particles
  const spawnParticles = useCallback((x, y, color, count = 8, config = {}) => {
    const { speed = 3, size = 4, life = 500, spread = Math.PI * 2, direction = 0, gravity = 0 } = config;
    const newParticles = Array(count).fill(null).map(() => {
      const angle = direction + (Math.random() - 0.5) * spread;
      const vel = (0.5 + Math.random() * 0.5) * speed;
      return {
        id: Math.random(),
        x, y,
        vx: Math.cos(angle) * vel,
        vy: Math.sin(angle) * vel,
        size: size * (0.5 + Math.random() * 0.5),
        color,
        life,
        maxLife: life,
        gravity,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
      };
    });
    setParticles(prev => [...prev, ...newParticles]);
  }, []);

  // Spawn floating text
  const spawnFloatingText = useCallback((x, y, text, color, size = 14, isCrit = false) => {
    setFloatingTexts(prev => [...prev, {
      id: Math.random(),
      x, y,
      text,
      color,
      size,
      life: 800,
      maxLife: 800,
      isCrit,
      vx: (Math.random() - 0.5) * 1.5,
      vy: -2.5,
    }]);
  }, []);

  // Spawn announcement
  const announce = useCallback((text, color = theme.gold, duration = 2000) => {
    const id = Math.random();
    setAnnouncements(prev => [...prev, { id, text, color, life: duration, maxLife: duration }]);
  }, []);

  // Screen shake
  const triggerShake = useCallback((intensity = 5) => {
    let count = 0;
    const shake = () => {
      if (count++ < 4) {
        setScreenShake({
          x: (Math.random() - 0.5) * intensity * (1 - count * 0.2),
          y: (Math.random() - 0.5) * intensity * (1 - count * 0.2),
        });
        setTimeout(shake, 40);
      } else {
        setScreenShake({ x: 0, y: 0 });
      }
    };
    shake();
  }, []);

  // Tower placement
  const canPlaceTower = useCallback((row, col) => {
    if (grid[row][col] !== null) return false;
    if (row === START.row && col === START.col) return false;
    if (row === END.row && col === END.col) return false;
    const testGrid = grid.map(r => [...r]);
    testGrid[row][col] = 'tower';
    return findPath(testGrid) !== null;
  }, [grid, findPath]);

  const placeTower = useCallback((row, col, towerType) => {
    if (!canPlaceTower(row, col)) return false;
    const towerDef = towerTypes[towerType];
    if (gold < towerDef.cost) return false;

    const newTower = {
      id: Date.now(),
      row, col,
      type: towerType,
      ...towerDef,
      lastFired: 0,
      level: 0,
      totalDamage: 0,
      kills: 0,
      beamTarget: null,
      beamDamageAccum: 0,
      pulsePhase: 0,
    };

    setTowers(prev => [...prev, newTower]);
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[row][col] = 'tower';
      return newGrid;
    });
    setGold(prev => prev - towerDef.cost);
    setSelectedTower(null);

    const cx = col * CELL_SIZE + CELL_SIZE / 2;
    const cy = row * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(cx, cy, towerDef.color, 12, { speed: 4, size: 5, life: 400 });

    const newGrid = grid.map(r => [...r]);
    newGrid[row][col] = 'tower';
    setPath(findPath(newGrid) || []);
    return true;
  }, [canPlaceTower, gold, grid, findPath, spawnParticles, CELL_SIZE]);

  const sellTower = useCallback((towerId) => {
    const tower = towers.find(t => t.id === towerId);
    if (!tower) return;

    const baseCost = towerTypes[tower.type].cost;
    const upgradeCost = towerTypes[tower.type].upgrades.slice(0, tower.level).reduce((sum, u) => sum + u.cost, 0);
    const sellValue = Math.floor((baseCost + upgradeCost) * 0.6);

    setTowers(prev => prev.filter(t => t.id !== towerId));
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[tower.row][tower.col] = null;
      return newGrid;
    });
    setGold(prev => prev + sellValue);
    setSelectedTowerForUpgrade(null);

    const cx = tower.col * CELL_SIZE + CELL_SIZE / 2;
    const cy = tower.row * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(cx, cy, theme.gold, 10, { speed: 3, life: 600 });
    spawnFloatingText(cx, cy, `+${sellValue}`, theme.gold, 16);

    const newGrid = grid.map(r => [...r]);
    newGrid[tower.row][tower.col] = null;
    setPath(findPath(newGrid) || []);
  }, [towers, grid, findPath, spawnParticles, spawnFloatingText, CELL_SIZE]);

  const upgradeTower = useCallback((towerId) => {
    setTowers(prev => prev.map(tower => {
      if (tower.id !== towerId) return tower;
      const upgrades = towerTypes[tower.type].upgrades;
      if (tower.level >= upgrades.length) return tower;

      const upgrade = upgrades[tower.level];
      if (gold < upgrade.cost) return tower;

      setGold(g => g - upgrade.cost);

      const cx = tower.col * CELL_SIZE + CELL_SIZE / 2;
      const cy = tower.row * CELL_SIZE + CELL_SIZE / 2;
      spawnParticles(cx, cy, theme.gold, 15, { speed: 5, size: 6, life: 500 });
      announce(`${tower.name} ‚Üí ${upgrade.name}!`, tower.color, 1500);

      return { ...tower, ...upgrade, level: tower.level + 1 };
    }));
  }, [gold, spawnParticles, announce, CELL_SIZE]);

  // Enemy spawning
  const spawnEnemy = useCallback((type, pathOffset = 0) => {
    const enemyDef = enemyTypes[type];
    const waveMultiplier = 1 + (wave - 1) * 0.15;
    // Small random offset to prevent stacking, but keep enemies centered on path
    const offsetX = (Math.random() - 0.5) * CELL_SIZE * 0.2;
    const offsetY = -pathOffset * CELL_SIZE * 0.3; // Stagger spawns slightly above the start
    const newEnemy = {
      id: Date.now() + Math.random(),
      type,
      ...enemyDef,
      health: Math.floor(enemyDef.health * waveMultiplier),
      maxHealth: Math.floor(enemyDef.health * waveMultiplier),
      currentHealth: Math.floor(enemyDef.health * waveMultiplier),
      currentShield: enemyDef.shield ? Math.floor(enemyDef.shield * waveMultiplier) : 0,
      maxShield: enemyDef.shield ? Math.floor(enemyDef.shield * waveMultiplier) : 0,
      pathIndex: 0,
      x: START.col * CELL_SIZE + CELL_SIZE / 2 + offsetX,
      y: START.row * CELL_SIZE + CELL_SIZE / 2 + offsetY,
      slowedUntil: 0,
      slowAmount: 1,
      poisonedUntil: 0,
      poisonDamage: 0,
      animPhase: Math.random() * Math.PI * 2,
      hitFlash: 0,
      rotation: 0,
      lastHealTime: 0,
    };
    setEnemies(prev => [...prev, newEnemy]);
  }, [wave, CELL_SIZE]);

  // Generate wave
  const generateWaveEnemies = useCallback((waveNum) => {
    const enemies = [];
    const baseCount = 8 + waveNum * 2;

    for (let i = 0; i < baseCount; i++) enemies.push('slime');
    if (waveNum >= 2) for (let i = 0; i < Math.floor(waveNum * 0.8); i++) enemies.push('scout');
    if (waveNum >= 3) for (let i = 0; i < Math.floor(waveNum / 2); i++) enemies.push('tank');
    if (waveNum >= 4) for (let i = 0; i < waveNum; i++) enemies.push('swarm');
    if (waveNum >= 5) for (let i = 0; i < Math.floor(waveNum / 4); i++) enemies.push('healer');
    if (waveNum >= 6) for (let i = 0; i < Math.floor(waveNum / 3); i++) enemies.push('shielded');
    if (waveNum >= 7) for (let i = 0; i < Math.floor(waveNum / 4); i++) enemies.push('splitter');
    if (waveNum % 5 === 0) enemies.push('boss');
    if (waveNum % 10 === 0) enemies.push('megaBoss');

    for (let i = enemies.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [enemies[i], enemies[j]] = [enemies[j], enemies[i]];
    }
    return enemies;
  }, []);

  const startWave = useCallback(() => {
    if (waveInProgress) return;
    setWaveInProgress(true);
    setEnemiesSpawned(0);

    const waveEnemies = generateWaveEnemies(wave);
    setWaveEnemyList(waveEnemies);
    setTotalEnemiesInWave(waveEnemies.length);

    // Boss warning
    if (wave % 5 === 0) {
      announce(wave % 10 === 0 ? '‚ö†Ô∏è TITAN INCOMING!' : '‚ö†Ô∏è BOSS WAVE!', theme.error, 2500);
      triggerShake(8);
    }

    let spawnIndex = 0;
    const spawnDelay = Math.max(250, 600 - wave * 15);

    spawnTimerRef.current = setInterval(() => {
      if (spawnIndex < waveEnemies.length) {
        spawnEnemy(waveEnemies[spawnIndex], spawnIndex % 3);
        spawnIndex++;
        setEnemiesSpawned(spawnIndex);
      } else {
        clearInterval(spawnTimerRef.current);
      }
    }, spawnDelay);
  }, [wave, waveInProgress, spawnEnemy, generateWaveEnemies, announce, triggerShake]);

  // Main game loop
  useEffect(() => {
    if (gameState !== 'playing') return;

    let animationId;
    let lastTime = performance.now();

    const tick = (currentTime) => {
      const deltaTime = Math.min(currentTime - lastTime, 50) * gameSpeed;
      lastTime = currentTime;
      const now = Date.now();

      // Update enemies
      setEnemies(prevEnemies => {
        const newEnemies = [];
        const enemiesToSpawn = [];

        for (const enemy of prevEnemies) {
          // Check if enemy has completed the path
          const pathLength = pathRef.current.length;
          const endX = END.col * CELL_SIZE + CELL_SIZE / 2;
          const endY = END.row * CELL_SIZE + CELL_SIZE / 2;
          const distToEnd = Math.sqrt((enemy.x - endX) ** 2 + (enemy.y - endY) ** 2);

          // Remove enemy if they reached the end (either by pathIndex or by position)
          if (enemy.pathIndex >= pathLength || (pathLength > 0 && enemy.pathIndex >= pathLength - 1 && distToEnd < CELL_SIZE * 0.5)) {
            setLives(l => {
              const damage = enemy.isBoss ? 5 : 1;
              const newLives = l - damage;
              if (newLives <= 0) setGameState('lost');
              return Math.max(0, newLives);
            });
            setLastDamageTime(now);
            triggerShake(12);
            announce(`-${enemy.isBoss ? 5 : 1} ‚ù§Ô∏è`, theme.error, 1000);
            continue;
          }

          // Poison tick
          if (enemy.poisonedUntil > now && enemy.poisonDamage > 0) {
            const poisonTick = enemy.poisonDamage * deltaTime / 1000;
            enemy.currentHealth -= poisonTick;
            if (Math.random() < 0.08) {
              spawnParticles(enemy.x, enemy.y, theme.poison, 2, { speed: 1, size: 3, life: 300 });
            }
          }

          // Healer
          if (enemy.heals && now - enemy.lastHealTime > 2000) {
            for (const other of prevEnemies) {
              if (other.id !== enemy.id) {
                const dx = other.x - enemy.x;
                const dy = other.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < CELL_SIZE * 2) {
                  other.currentHealth = Math.min(other.maxHealth, other.currentHealth + 10);
                  spawnParticles(other.x, other.y, theme.success, 3, { speed: 2, size: 3, life: 400 });
                }
              }
            }
            enemy.lastHealTime = now;
          }

          // Hit flash decay
          if (enemy.hitFlash > 0) enemy.hitFlash -= deltaTime * 0.01;

          // Death
          if (enemy.currentHealth <= 0) {
            const comboBonus = Math.floor(enemy.reward * combo * 0.1);
            const totalReward = enemy.reward + comboBonus;
            setGold(g => g + totalReward);
            setTotalScore(s => s + totalReward * 10);
            setKillCount(k => k + 1);
            setTotalDamageDealt(d => d + enemy.maxHealth);

            const newCombo = Math.min(combo + 1, 50);
            setCombo(newCombo);
            setMaxCombo(m => Math.max(m, newCombo));
            setComboTimer(3000);

            // Kill streak announcements
            if (newCombo === 5) announce('üî• KILLING SPREE!', '#ff9500', 1500);
            else if (newCombo === 10) announce('‚ö° RAMPAGE!', '#ff6b00', 1500);
            else if (newCombo === 20) announce('üíÄ UNSTOPPABLE!', '#ff0000', 2000);
            else if (newCombo === 50) announce('üëë GODLIKE!', theme.gold, 3000);

            spawnParticles(enemy.x, enemy.y, enemy.color, 15, { speed: 4, size: 6, life: 600 });
            if (enemy.isBoss) {
              spawnParticles(enemy.x, enemy.y, theme.gold, 25, { speed: 6, size: 8, life: 800 });
              triggerShake(15);
              announce(enemy.type === 'megaBoss' ? 'üëπ TITAN SLAIN!' : 'üêâ BOSS DEFEATED!', theme.gold, 2500);
            }

            const textColor = comboBonus > 0 ? theme.gold : theme.success;
            spawnFloatingText(enemy.x, enemy.y - 10, `+${totalReward}`, textColor, comboBonus > 0 ? 18 : 14);

            if (enemy.splits) {
              for (let i = 0; i < enemy.splits; i++) {
                enemiesToSpawn.push({
                  type: 'swarm',
                  x: enemy.x + (Math.random() - 0.5) * 20,
                  y: enemy.y + (Math.random() - 0.5) * 20,
                  pathIndex: enemy.pathIndex,
                });
              }
            }
            continue;
          }

          // Movement
          const target = pathRef.current[enemy.pathIndex];
          if (target) {
            const targetX = target.col * CELL_SIZE + CELL_SIZE / 2;
            const targetY = target.row * CELL_SIZE + CELL_SIZE / 2;
            const dx = targetX - enemy.x;
            const dy = targetY - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            let speed = enemy.speed * (deltaTime / 16);
            if (enemy.slowedUntil > now) speed *= enemy.slowAmount;

            enemy.rotation = Math.atan2(dy, dx);

            // Use a reasonable threshold based on cell size for path advancement
            const advanceThreshold = Math.max(speed * 2, CELL_SIZE * 0.15);
            if (dist < advanceThreshold) {
              enemy.pathIndex++;
              // Snap to center when advancing to prevent drift
              enemy.x = targetX;
              enemy.y = targetY;
            } else {
              enemy.x += (dx / dist) * speed * 2;
              enemy.y += (dy / dist) * speed * 2;
            }
          }

          enemy.animPhase += deltaTime * 0.008;
          newEnemies.push(enemy);
        }

        // Spawn split enemies
        for (const spawn of enemiesToSpawn) {
          const enemyDef = enemyTypes[spawn.type];
          newEnemies.push({
            id: Date.now() + Math.random(),
            type: spawn.type,
            ...enemyDef,
            health: enemyDef.health,
            maxHealth: enemyDef.health,
            currentHealth: enemyDef.health,
            currentShield: 0,
            maxShield: 0,
            pathIndex: spawn.pathIndex,
            x: spawn.x,
            y: spawn.y,
            slowedUntil: 0,
            slowAmount: 1,
            poisonedUntil: 0,
            poisonDamage: 0,
            animPhase: Math.random() * Math.PI * 2,
            hitFlash: 0,
            rotation: 0,
            lastHealTime: 0,
          });
        }

        return newEnemies;
      });

      // Update towers
      setTowers(prevTowers => {
        return prevTowers.map(tower => {
          const towerX = tower.col * CELL_SIZE + CELL_SIZE / 2;
          const towerY = tower.row * CELL_SIZE + CELL_SIZE / 2;
          tower.pulsePhase = (tower.pulsePhase || 0) + deltaTime * 0.005;

          // Beam tower
          if (tower.beam) {
            let target = null;
            let minDist = Infinity;

            for (const enemy of enemiesRef.current) {
              const dx = enemy.x - towerX;
              const dy = enemy.y - towerY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= tower.range * CELL_SIZE && dist < minDist) {
                target = enemy;
                minDist = dist;
              }
            }

            if (target) {
              tower.beamTarget = { x: target.x, y: target.y, id: target.id };
              tower.beamDamageAccum += tower.damage * deltaTime / 16;

              if (tower.beamDamageAccum >= 1) {
                const damage = Math.floor(tower.beamDamageAccum);
                tower.beamDamageAccum -= damage;

                setEnemies(enemies => enemies.map(e => {
                  if (e.id === target.id) {
                    e.hitFlash = 1;
                    const newHealth = e.currentHealth - damage;
                    if (newHealth <= 0) {
                      tower.kills++;
                      tower.totalDamage += damage;
                    }
                    return { ...e, currentHealth: newHealth };
                  }
                  return e;
                }));
              }

              if (Math.random() < 0.2) {
                spawnParticles(target.x, target.y, tower.color, 1, { speed: 1, size: 3, life: 200 });
              }
            } else {
              tower.beamTarget = null;
            }
            return tower;
          }

          // Regular tower
          if (now - tower.lastFired < tower.fireRate) return tower;

          let target = null;
          let maxProgress = -1;

          for (const enemy of enemiesRef.current) {
            const dx = enemy.x - towerX;
            const dy = enemy.y - towerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= tower.range * CELL_SIZE && enemy.pathIndex > maxProgress) {
              target = enemy;
              maxProgress = enemy.pathIndex;
            }
          }

          if (target) {
            const isCrit = tower.critChance && Math.random() < tower.critChance;
            const damage = isCrit ? tower.damage * 2 : tower.damage;

            setProjectiles(p => [...p, {
              id: Date.now() + Math.random(),
              fromX: towerX,
              fromY: towerY,
              toX: target.x,
              toY: target.y,
              targetId: target.id,
              damage,
              color: tower.color,
              splash: tower.splash,
              slow: tower.slow,
              slowDuration: tower.slowDuration,
              chain: tower.chain,
              chainDamageDecay: tower.chainDamageDecay || 0.7,
              chainedEnemies: [],
              poisonDamage: tower.poisonDamage,
              poisonDuration: tower.poisonDuration,
              splashPoison: tower.splashPoison,
              progress: 0,
              speed: tower.projectileSpeed || 15,
              size: tower.projectileSize || 5,
              isCrit,
              trail: [],
              towerId: tower.id,
            }]);

            const angle = Math.atan2(target.y - towerY, target.x - towerX);
            spawnParticles(towerX, towerY, tower.color, 3, { speed: 3, size: 3, life: 120, spread: 0.5, direction: angle });

            return { ...tower, lastFired: now };
          }

          return tower;
        });
      });

      // Update projectiles
      setProjectiles(prevProjectiles => {
        const newProjectiles = [];

        for (const proj of prevProjectiles) {
          proj.trail.push({ x: proj.fromX + (proj.toX - proj.fromX) * proj.progress, y: proj.fromY + (proj.toY - proj.fromY) * proj.progress });
          if (proj.trail.length > 6) proj.trail.shift();

          proj.progress += (proj.speed / 100) * (deltaTime / 16);

          if (proj.progress >= 1) {
            setEnemies(enemies => {
              return enemies.map(enemy => {
                if (proj.chainedEnemies.includes(enemy.id)) return enemy;

                if (enemy.id === proj.targetId) {
                  let remainingDamage = proj.damage;
                  if (enemy.currentShield > 0) {
                    const shieldDamage = Math.min(enemy.currentShield, remainingDamage);
                    enemy.currentShield -= shieldDamage;
                    remainingDamage -= shieldDamage;
                    spawnParticles(enemy.x, enemy.y, '#778ca3', 5, { speed: 3, size: 4, life: 300 });
                  }

                  const newHealth = enemy.currentHealth - remainingDamage;
                  enemy.hitFlash = 1;

                  if (proj.slow) {
                    enemy.slowedUntil = now + proj.slowDuration;
                    enemy.slowAmount = proj.slow;
                  }
                  if (proj.poisonDamage) {
                    enemy.poisonedUntil = now + proj.poisonDuration;
                    enemy.poisonDamage = proj.poisonDamage;
                  }

                  spawnParticles(enemy.x, enemy.y, proj.color, 5, { speed: 3, size: 4, life: 300 });

                  if (proj.isCrit) {
                    spawnFloatingText(enemy.x, enemy.y - 15, 'CRIT!', '#ff0', 16, true);
                  }

                  setTowers(towers => towers.map(t => {
                    if (t.id === proj.towerId) {
                      return { ...t, totalDamage: t.totalDamage + proj.damage, kills: newHealth <= 0 ? t.kills + 1 : t.kills };
                    }
                    return t;
                  }));

                  return { ...enemy, currentHealth: newHealth };
                }

                if (proj.splash) {
                  const dx = enemy.x - proj.toX;
                  const dy = enemy.y - proj.toY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist <= proj.splash * CELL_SIZE) {
                    const splashDamage = proj.damage * 0.5;
                    const newHealth = enemy.currentHealth - splashDamage;
                    enemy.hitFlash = 0.5;

                    if (proj.splashPoison) {
                      enemy.poisonedUntil = now + (proj.poisonDuration || 3000);
                      enemy.poisonDamage = proj.poisonDamage * 0.5;
                    }

                    spawnParticles(enemy.x, enemy.y, proj.color, 2, { speed: 2, size: 3, life: 200 });
                    return { ...enemy, currentHealth: newHealth };
                  }
                }

                return enemy;
              }).filter(Boolean);
            });

            if (proj.splash) {
              spawnParticles(proj.toX, proj.toY, proj.color, 12, { speed: 5, size: 6, life: 400 });
              spawnParticles(proj.toX, proj.toY, '#fff', 6, { speed: 3, size: 3, life: 300 });
              triggerShake(3);
            }

            // Chain lightning
            if (proj.chain && proj.chain > 0) {
              let lastX = proj.toX;
              let lastY = proj.toY;
              const chainedIds = [proj.targetId];

              for (let i = 0; i < proj.chain; i++) {
                let nearestEnemy = null;
                let nearestDist = CELL_SIZE * 3;

                for (const enemy of enemiesRef.current) {
                  if (chainedIds.includes(enemy.id)) continue;
                  const dx = enemy.x - lastX;
                  const dy = enemy.y - lastY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                  }
                }

                if (nearestEnemy) {
                  chainedIds.push(nearestEnemy.id);
                  const chainDamage = proj.damage * Math.pow(proj.chainDamageDecay, i + 1);

                  setProjectiles(p => [...p, {
                    id: Date.now() + Math.random(),
                    fromX: lastX,
                    fromY: lastY,
                    toX: nearestEnemy.x,
                    toY: nearestEnemy.y,
                    targetId: nearestEnemy.id,
                    damage: chainDamage,
                    color: proj.color,
                    progress: 0,
                    speed: 50,
                    size: 3,
                    chain: 0,
                    chainedEnemies: chainedIds,
                    trail: [],
                    isChain: true,
                    towerId: proj.towerId,
                  }]);

                  lastX = nearestEnemy.x;
                  lastY = nearestEnemy.y;
                }
              }
            }
            continue;
          }
          newProjectiles.push(proj);
        }
        return newProjectiles;
      });

      // Update particles
      setParticles(prev => prev.map(p => ({
        ...p,
        x: p.x + p.vx * (deltaTime / 16),
        y: p.y + p.vy * (deltaTime / 16) + p.gravity * (deltaTime / 16),
        vy: p.vy + p.gravity * 0.1,
        life: p.life - deltaTime,
        rotation: p.rotation + p.rotationSpeed,
      })).filter(p => p.life > 0));

      // Update floating texts
      setFloatingTexts(prev => prev.map(t => ({
        ...t,
        x: t.x + t.vx * (deltaTime / 16),
        y: t.y + t.vy * (deltaTime / 16),
        vy: t.vy - 0.03,
        life: t.life - deltaTime,
      })).filter(t => t.life > 0));

      // Update announcements
      setAnnouncements(prev => prev.map(a => ({ ...a, life: a.life - deltaTime })).filter(a => a.life > 0));

      // Combo decay
      setComboTimer(prev => {
        const newTimer = prev - deltaTime;
        if (newTimer <= 0) {
          setCombo(0);
          return 0;
        }
        return newTimer;
      });

      // Wave complete
      if (waveInProgress && enemiesRef.current.length === 0 && enemiesSpawned >= totalEnemiesInWave && totalEnemiesInWave > 0) {
        setWaveInProgress(false);
        const waveBonus = 30 + wave * 10;
        setGold(g => g + waveBonus);
        announce(`Wave ${wave} Complete! +${waveBonus}üí∞`, theme.success, 2000);
        setWave(w => w + 1);
      }

      animationId = requestAnimationFrame(tick);
    };

    animationId = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(animationId);
  }, [gameState, gameSpeed, waveInProgress, enemiesSpawned, totalEnemiesInWave, wave, triggerShake, spawnParticles, spawnFloatingText, announce, CELL_SIZE]);

  useEffect(() => {
    setPath(findPath(grid) || []);
  }, []);

  const startGame = () => {
    const emptyGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    setGrid(emptyGrid);
    setTowers([]);
    setEnemies([]);
    setProjectiles([]);
    setParticles([]);
    setFloatingTexts([]);
    setAnnouncements([]);
    setWave(1);
    setLives(20);
    setGold(150);
    setWaveInProgress(false);
    setEnemiesSpawned(0);
    setTotalEnemiesInWave(0);
    setTotalScore(0);
    setCombo(0);
    setMaxCombo(0);
    setComboTimer(0);
    setKillCount(0);
    setTotalDamageDealt(0);
    setSelectedTowerForUpgrade(null);
    setPath(findPath(emptyGrid) || []);
    setGameState('playing');
  };

  const gridWidth = GRID_SIZE * CELL_SIZE + GRID_OFFSET * 2 + 4;
  const gridHeight = GRID_SIZE * CELL_SIZE + GRID_OFFSET * 2 + 4;

  // Wave preview
  const wavePreview = useMemo(() => {
    if (waveInProgress) return null;
    const enemies = generateWaveEnemies(wave);
    const counts = {};
    enemies.forEach(e => { counts[e] = (counts[e] || 0) + 1; });
    return counts;
  }, [wave, waveInProgress, generateWaveEnemies]);

  const styles = `
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');

    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.03); } }
    @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.4); } }
    @keyframes slideIn { 0% { transform: translateY(20px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes slideDown { 0% { transform: translateY(-30px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
    @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    @keyframes rainbow { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }
    @keyframes shimmer { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
    @keyframes towerPulse { 0%, 100% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.05); filter: brightness(1.1); } }

    * { box-sizing: border-box; font-family: 'Inter', -apple-system, sans-serif; }

    .btn {
      cursor: pointer;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-user-select: none;
    }
    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(0) scale(0.98); }

    .tower-card {
      transition: all 0.15s ease;
      cursor: pointer;
    }
    .tower-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .tower-card:active { transform: translateY(0) scale(0.98); }

    .cell { transition: all 0.1s ease; }
    .cell:hover { filter: brightness(1.2); }
  `;

  return (
    <div style={{
      width: '100%',
      height: '100%',
      minHeight: '100vh',
      background: `radial-gradient(ellipse at 50% 30%, #181828 0%, #0a0a12 70%)`,
      color: theme.text,
      position: 'relative',
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
    }}>
      <style>{styles}</style>

      {/* Background pattern */}
      <div style={{
        position: 'fixed',
        inset: 0,
        backgroundImage: `linear-gradient(rgba(124,106,237,0.02) 1px, transparent 1px),
                          linear-gradient(90deg, rgba(124,106,237,0.02) 1px, transparent 1px)`,
        backgroundSize: '40px 40px',
        pointerEvents: 'none',
      }} />

      <div style={{
        position: 'relative',
        zIndex: 5,
        flex: 1,
        display: 'flex',
        flexDirection: 'column',
        padding: '12px',
        transform: `translate(${screenShake.x}px, ${screenShake.y}px)`,
      }}>

        {/* MENU */}
        {gameState === 'menu' && (
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', flex: 1 }}>
            <div style={{ textAlign: 'center', animation: 'slideIn 0.5s ease-out' }}>
              <div style={{ marginBottom: '24px', animation: 'float 3s ease-in-out infinite' }}>
                <div style={{
                  width: 100, height: 100,
                  background: `linear-gradient(135deg, ${theme.accent}30 0%, ${theme.accent}10 100%)`,
                  borderRadius: '24px',
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  fontSize: 50,
                  boxShadow: `0 0 40px ${theme.accentGlow}`,
                  border: `2px solid ${theme.accent}`,
                  margin: '0 auto',
                }}>üè∞</div>
              </div>
              <h1 style={{
                fontSize: 'clamp(28px, 5vw, 42px)',
                fontWeight: 900,
                marginBottom: '8px',
                background: `linear-gradient(135deg, ${theme.gold} 0%, ${theme.accentBright} 100%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
              }}>TOWER DEFENSE</h1>
              <p style={{ fontSize: '14px', color: theme.textSecondary, marginBottom: '32px' }}>
                Build towers ‚Ä¢ Create mazes ‚Ä¢ Survive
              </p>
              <button
                onClick={startGame}
                className="btn"
                style={{
                  padding: '14px 48px',
                  fontSize: '16px',
                  fontWeight: 700,
                  background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                  border: 'none',
                  borderRadius: '12px',
                  color: '#fff',
                  boxShadow: `0 4px 20px ${theme.accentGlow}`,
                }}
              >
                START GAME
              </button>
              <div style={{ marginTop: '24px', fontSize: '12px', color: theme.textMuted }}>
                Press 1-7 to select towers ‚Ä¢ Space to start wave
              </div>
            </div>
          </div>
        )}

        {/* PLAYING */}
        {(gameState === 'playing' || gameState === 'lost') && (
          <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', alignItems: 'flex-start', flex: 1 }}>

            {/* Left Panel */}
            <div style={{
              background: theme.bgPanel,
              borderRadius: '12px',
              padding: '12px',
              border: `1px solid ${theme.border}`,
              width: '170px',
              flexShrink: 0,
            }}>
              <div style={{ fontSize: '10px', fontWeight: 700, color: theme.gold, letterSpacing: '1px', marginBottom: '10px' }}>
                TOWERS
              </div>

              {Object.values(towerTypes).map((tower, idx) => {
                const canAfford = gold >= tower.cost;
                const isSelected = selectedTower === tower.id;

                return (
                  <div
                    key={tower.id}
                    onClick={() => canAfford && (setSelectedTower(tower.id), setSelectedTowerForUpgrade(null))}
                    className="tower-card"
                    style={{
                      background: isSelected ? `${tower.color}20` : theme.bgDark,
                      borderRadius: '8px',
                      padding: '8px 10px',
                      marginBottom: '6px',
                      opacity: canAfford ? 1 : 0.4,
                      border: isSelected ? `2px solid ${tower.color}` : `1px solid ${theme.border}`,
                      cursor: canAfford ? 'pointer' : 'not-allowed',
                    }}
                  >
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <span style={{ fontSize: '18px' }}>{tower.emoji}</span>
                      <div style={{ flex: 1, minWidth: 0 }}>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <span style={{ fontSize: '11px', fontWeight: 700, color: tower.color }}>{tower.name}</span>
                          {showHotkeys && <span style={{ fontSize: '9px', color: theme.textMuted, background: theme.bgDark, padding: '1px 4px', borderRadius: '3px' }}>{tower.hotkey}</span>}
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: '2px' }}>
                          <span style={{ fontSize: '9px', color: theme.textMuted }}>{tower.desc}</span>
                          <span style={{ fontSize: '10px', color: theme.gold, fontWeight: 600 }}>{tower.cost}üí∞</span>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}

              <div style={{ marginTop: '10px', padding: '8px', background: theme.bgDark, borderRadius: '8px', fontSize: '9px', color: theme.textMuted }}>
                <div style={{ fontWeight: 600, color: theme.textSecondary, marginBottom: '4px' }}>Controls</div>
                <div>1-7: Select tower</div>
                <div>U: Upgrade ‚Ä¢ S: Sell</div>
                <div>Space: Start wave</div>
                <div>Esc: Deselect</div>
              </div>
            </div>

            {/* Center - Game */}
            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              {/* Top bar */}
              <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '8px',
                padding: '8px 12px',
                background: theme.bgPanel,
                borderRadius: '10px',
                border: `1px solid ${theme.border}`,
                width: gridWidth,
              }}>
                <div style={{ display: 'flex', gap: '16px' }}>
                  {[
                    { label: 'WAVE', value: wave, color: theme.accent },
                    { label: 'LIVES', value: `‚ù§Ô∏è${lives}`, color: lives <= 5 ? theme.error : theme.success, blink: lives <= 5 },
                    { label: 'GOLD', value: `üí∞${gold}`, color: theme.gold },
                  ].map((stat, i) => (
                    <div key={i} style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted, letterSpacing: '0.5px' }}>{stat.label}</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: stat.color,
                        animation: stat.blink ? 'pulse 0.5s ease-in-out infinite' : 'none',
                      }}>{stat.value}</div>
                    </div>
                  ))}
                  {combo > 0 && (
                    <div style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted }}>COMBO</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: combo >= 20 ? theme.gold : combo >= 10 ? '#ff6b00' : theme.accent,
                        animation: combo >= 20 ? 'rainbow 2s linear infinite' : 'none',
                      }}>üî•{combo}</div>
                    </div>
                  )}
                </div>

                <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
                  <button
                    onClick={() => setGameSpeed(s => s === 1 ? 2 : s === 2 ? 3 : 1)}
                    className="btn"
                    style={{
                      padding: '6px 12px',
                      fontSize: '11px',
                      fontWeight: 700,
                      background: theme.bgDark,
                      border: `1px solid ${theme.border}`,
                      borderRadius: '6px',
                      color: theme.textSecondary,
                    }}
                  >{gameSpeed}√ó</button>
                  <button
                    onClick={startWave}
                    disabled={waveInProgress}
                    className="btn"
                    style={{
                      padding: '8px 16px',
                      fontSize: '12px',
                      fontWeight: 700,
                      background: waveInProgress ? theme.bgDark : `linear-gradient(135deg, ${theme.success} 0%, #1fab54 100%)`,
                      border: 'none',
                      borderRadius: '8px',
                      color: waveInProgress ? theme.textMuted : '#fff',
                      cursor: waveInProgress ? 'not-allowed' : 'pointer',
                      boxShadow: waveInProgress ? 'none' : `0 4px 12px ${theme.successGlow}`,
                    }}
                  >
                    {waveInProgress ? `${enemiesSpawned}/${totalEnemiesInWave}` : `‚ñ∂ WAVE ${wave}`}
                  </button>
                </div>
              </div>

              {/* Wave progress */}
              {waveInProgress && (
                <div style={{
                  width: gridWidth,
                  height: '3px',
                  background: theme.bgDark,
                  borderRadius: '2px',
                  marginBottom: '8px',
                  overflow: 'hidden',
                }}>
                  <div style={{
                    width: `${(enemiesSpawned / totalEnemiesInWave) * 100}%`,
                    height: '100%',
                    background: `linear-gradient(90deg, ${theme.accent} 0%, ${theme.success} 100%)`,
                    transition: 'width 0.2s ease',
                  }} />
                </div>
              )}

              {/* Grid */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`,
                gap: '2px',
                background: `linear-gradient(145deg, ${theme.bgDark} 0%, #080810 100%)`,
                padding: `${GRID_OFFSET}px`,
                borderRadius: '16px',
                border: `2px solid ${theme.border}`,
                position: 'relative',
                boxShadow: `0 8px 32px rgba(0,0,0,0.5), 0 0 60px ${theme.accent}08, inset 0 0 60px rgba(0,0,0,0.3)`,
              }}>
                {grid.map((row, rowIdx) => row.map((cell, colIdx) => {
                  const isStart = rowIdx === START.row && colIdx === START.col;
                  const isEnd = rowIdx === END.row && colIdx === END.col;
                  const isPath = path.some(p => p.row === rowIdx && p.col === colIdx);
                  const isHovered = hoveredCell?.row === rowIdx && hoveredCell?.col === colIdx;
                  const tower = towers.find(t => t.row === rowIdx && t.col === colIdx);
                  const canPlace = selectedTower && canPlaceTower(rowIdx, colIdx) && gold >= towerTypes[selectedTower].cost;
                  const isSelected = tower && selectedTowerForUpgrade?.id === tower.id;

                  return (
                    <div
                      key={`${rowIdx}-${colIdx}`}
                      className="cell"
                      onClick={() => {
                        if (selectedTower && canPlace) placeTower(rowIdx, colIdx, selectedTower);
                        else if (tower && !selectedTower) setSelectedTowerForUpgrade(isSelected ? null : tower);
                      }}
                      onContextMenu={(e) => { e.preventDefault(); if (tower) sellTower(tower.id); }}
                      onMouseEnter={() => setHoveredCell({ row: rowIdx, col: colIdx })}
                      onMouseLeave={() => setHoveredCell(null)}
                      onTouchStart={() => setHoveredCell({ row: rowIdx, col: colIdx })}
                      style={{
                        width: CELL_SIZE,
                        height: CELL_SIZE,
                        background: isStart ? `radial-gradient(circle, ${theme.success}50 0%, ${theme.success}20 70%)`
                          : isEnd ? `radial-gradient(circle, ${theme.error}50 0%, ${theme.error}20 70%)`
                          : tower ? `radial-gradient(circle, ${tower.color}35 0%, ${tower.color}15 70%)`
                          : isHovered && canPlace ? `${towerTypes[selectedTower].color}30`
                          : isHovered && selectedTower && !canPlace ? `${theme.error}30`
                          : isPath ? `linear-gradient(135deg, ${theme.pathColor} 0%, ${theme.pathGlow} 100%)`
                          : theme.bgCell,
                        borderRadius: '6px',
                        boxShadow: isPath ? `inset 0 0 ${CELL_SIZE * 0.4}px ${theme.accent}15` : 'none',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        cursor: canPlace || tower ? 'pointer' : 'default',
                        position: 'relative',
                        border: isSelected ? `2px solid ${tower.color}` : isPath ? `1px solid ${theme.accent}20` : 'none',
                        boxShadow: tower ? `inset 0 0 ${CELL_SIZE/3}px ${tower.color}30, 0 0 8px ${tower.color}20` : 'none',
                      }}
                    >
                      {isStart && <span style={{ fontSize: CELL_SIZE * 0.55, filter: `drop-shadow(0 0 6px ${theme.success})`, animation: 'pulse 2s ease-in-out infinite' }}>üö™</span>}
                      {isEnd && <span style={{ fontSize: CELL_SIZE * 0.55, filter: `drop-shadow(0 0 6px ${theme.error})`, animation: 'pulse 2s ease-in-out infinite' }}>üè†</span>}
                      {tower && (
                        <span style={{
                          fontSize: CELL_SIZE * 0.55,
                          filter: `drop-shadow(0 0 4px ${tower.color})`,
                          animation: tower.beamTarget ? 'glow 0.3s ease-in-out infinite' : 'none',
                        }}>{tower.emoji}</span>
                      )}
                      {tower && tower.level > 0 && (
                        <div style={{
                          position: 'absolute',
                          bottom: '1px',
                          right: '2px',
                          fontSize: '8px',
                          fontWeight: 900,
                          color: theme.gold,
                        }}>‚òÖ{tower.level}</div>
                      )}
                      {isHovered && canPlace && !tower && (
                        <span style={{ fontSize: CELL_SIZE * 0.5, opacity: 0.5 }}>{towerTypes[selectedTower].emoji}</span>
                      )}
                    </div>
                  );
                }))}

                {/* Range indicator */}
                {(hoveredCell && selectedTower && canPlaceTower(hoveredCell.row, hoveredCell.col)) && (
                  <div style={{
                    position: 'absolute',
                    left: hoveredCell.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    top: hoveredCell.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    width: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    height: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px dashed ${towerTypes[selectedTower].color}40`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${towerTypes[selectedTower].color}08 0%, transparent 70%)`,
                  }} />
                )}

                {/* Selected tower range */}
                {selectedTowerForUpgrade && (
                  <div style={{
                    position: 'absolute',
                    left: selectedTowerForUpgrade.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    top: selectedTowerForUpgrade.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    width: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    height: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px solid ${selectedTowerForUpgrade.color}60`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${selectedTowerForUpgrade.color}10 0%, transparent 70%)`,
                  }} />
                )}

                {/* Beams */}
                {towers.filter(t => t.beam && t.beamTarget).map(tower => {
                  const fromX = tower.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET;
                  const fromY = tower.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET;
                  const toX = tower.beamTarget.x + GRID_OFFSET;
                  const toY = tower.beamTarget.y + GRID_OFFSET;
                  const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                  const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);

                  return (
                    <React.Fragment key={`beam-${tower.id}`}>
                      {/* Outer glow */}
                      <div style={{
                        position: 'absolute',
                        left: fromX,
                        top: fromY - 3,
                        width: length,
                        height: '10px',
                        background: `linear-gradient(90deg, ${tower.color}60 0%, ${tower.color}20 100%)`,
                        transform: `rotate(${angle}deg)`,
                        transformOrigin: '0 50%',
                        pointerEvents: 'none',
                        filter: 'blur(4px)',
                        zIndex: 14,
                      }} />
                      {/* Core beam */}
                      <div style={{
                        position: 'absolute',
                        left: fromX,
                        top: fromY - 1,
                        width: length,
                        height: '4px',
                        background: `linear-gradient(90deg, #fff 0%, ${tower.color} 20%, ${tower.color} 80%, #fff 100%)`,
                        transform: `rotate(${angle}deg)`,
                        transformOrigin: '0 50%',
                        pointerEvents: 'none',
                        boxShadow: `0 0 12px ${tower.color}, 0 0 24px ${tower.color}80, 0 0 4px #fff`,
                        zIndex: 15,
                        borderRadius: '2px',
                      }} />
                    </React.Fragment>
                  );
                })}

                {/* Enemies */}
                {enemies.map(enemy => {
                  const size = (CELL_SIZE * 0.55) * (enemy.size || 1);
                  const bobOffset = Math.sin(enemy.animPhase * 4) * 2;
                  const scaleEffect = 1 + Math.sin(enemy.animPhase * 2) * 0.03;

                  return (
                    <div
                      key={enemy.id}
                      style={{
                        position: 'absolute',
                        left: enemy.x - size / 2 + GRID_OFFSET,
                        top: enemy.y - size / 2 + GRID_OFFSET + bobOffset,
                        width: size,
                        height: size,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        pointerEvents: 'none',
                        zIndex: 10,
                        filter: enemy.hitFlash > 0 ? `brightness(${1 + enemy.hitFlash * 1.5}) drop-shadow(0 0 8px #fff)`
                          : enemy.poisonedUntil > Date.now() ? `drop-shadow(0 0 6px ${theme.poison}) drop-shadow(0 0 2px ${theme.poison})`
                          : enemy.slowedUntil > Date.now() ? `drop-shadow(0 0 6px ${theme.frost}) drop-shadow(0 0 2px ${theme.frost})`
                          : `drop-shadow(0 0 4px ${enemy.color})`,
                        transition: 'filter 0.1s ease',
                        transform: `scale(${scaleEffect})`,
                      }}
                    >
                      <span style={{
                        fontSize: enemy.isBoss ? CELL_SIZE * 0.8 : size * 0.8,
                        transform: `scaleX(${enemy.rotation > -Math.PI / 2 && enemy.rotation < Math.PI / 2 ? 1 : -1})`,
                      }}>{enemy.emoji}</span>

                      {/* Health bar */}
                      <div style={{
                        position: 'absolute',
                        bottom: -8,
                        width: size + 6,
                        height: enemy.isBoss ? 6 : 4,
                        background: 'rgba(0,0,0,0.7)',
                        borderRadius: '3px',
                        overflow: 'hidden',
                        border: '1px solid rgba(255,255,255,0.1)',
                        boxShadow: '0 1px 3px rgba(0,0,0,0.4)',
                      }}>
                        {enemy.maxShield > 0 && (
                          <div style={{
                            position: 'absolute',
                            width: `${(enemy.currentShield / enemy.maxShield) * 100}%`,
                            height: '100%',
                            background: 'linear-gradient(180deg, #9db3c9 0%, #778ca3 100%)',
                            transition: 'width 0.1s ease',
                          }} />
                        )}
                        <div style={{
                          width: `${(enemy.currentHealth / enemy.maxHealth) * 100}%`,
                          height: '100%',
                          background: enemy.currentHealth > enemy.maxHealth * 0.5
                            ? `linear-gradient(180deg, ${theme.success} 0%, #1fab54 100%)`
                            : enemy.currentHealth > enemy.maxHealth * 0.25
                            ? `linear-gradient(180deg, ${theme.gold} 0%, #e6c200 100%)`
                            : `linear-gradient(180deg, ${theme.error} 0%, #cc3847 100%)`,
                          transition: 'width 0.15s ease',
                          boxShadow: enemy.currentHealth <= enemy.maxHealth * 0.25 ? `0 0 4px ${theme.error}` : 'none',
                        }} />
                      </div>

                      {enemy.slowedUntil > Date.now() && <div style={{ position: 'absolute', top: -8, fontSize: '8px' }}>‚ùÑÔ∏è</div>}
                      {enemy.poisonedUntil > Date.now() && <div style={{ position: 'absolute', top: -8, left: enemy.slowedUntil > Date.now() ? 10 : 0, fontSize: '8px' }}>‚ò†Ô∏è</div>}
                    </div>
                  );
                })}

                {/* Projectiles */}
                {projectiles.map(proj => {
                  const x = proj.fromX + (proj.toX - proj.fromX) * proj.progress;
                  const y = proj.fromY + (proj.toY - proj.fromY) * proj.progress;

                  return (
                    <React.Fragment key={proj.id}>
                      {proj.trail.map((point, i) => (
                        <div key={`trail-${proj.id}-${i}`} style={{
                          position: 'absolute',
                          left: point.x - proj.size * 0.3 + GRID_OFFSET,
                          top: point.y - proj.size * 0.3 + GRID_OFFSET,
                          width: proj.size * 0.6,
                          height: proj.size * 0.6,
                          background: `radial-gradient(circle, ${proj.color} 0%, transparent 70%)`,
                          borderRadius: '50%',
                          opacity: (i / proj.trail.length) * 0.5,
                          pointerEvents: 'none',
                          zIndex: 18,
                        }} />
                      ))}
                      <div style={{
                        position: 'absolute',
                        left: x - proj.size / 2 + GRID_OFFSET,
                        top: y - proj.size / 2 + GRID_OFFSET,
                        width: proj.size,
                        height: proj.size,
                        background: `radial-gradient(circle, #fff 0%, ${proj.color} 50%, transparent 100%)`,
                        borderRadius: '50%',
                        boxShadow: `0 0 ${proj.size * 1.5}px ${proj.color}, 0 0 ${proj.size * 0.5}px #fff`,
                        pointerEvents: 'none',
                        zIndex: 20,
                      }} />
                    </React.Fragment>
                  );
                })}

                {/* Particles */}
                {particles.map(p => (
                  <div key={p.id} style={{
                    position: 'absolute',
                    left: p.x - p.size / 2 + GRID_OFFSET,
                    top: p.y - p.size / 2 + GRID_OFFSET,
                    width: p.size,
                    height: p.size,
                    background: `radial-gradient(circle, ${p.color} 0%, ${p.color}80 50%, transparent 100%)`,
                    borderRadius: '50%',
                    opacity: Math.pow(p.life / p.maxLife, 0.7),
                    pointerEvents: 'none',
                    zIndex: 25,
                    transform: `scale(${0.5 + (p.life / p.maxLife) * 0.5}) rotate(${p.rotation}deg)`,
                    boxShadow: `0 0 ${p.size * 1.2}px ${p.color}`,
                  }} />
                ))}

                {/* Floating texts */}
                {floatingTexts.map(t => (
                  <div key={t.id} style={{
                    position: 'absolute',
                    left: t.x + GRID_OFFSET,
                    top: t.y + GRID_OFFSET,
                    fontSize: `${t.size}px`,
                    fontWeight: 800,
                    color: t.color,
                    pointerEvents: 'none',
                    zIndex: 30,
                    opacity: t.life / t.maxLife,
                    transform: `translate(-50%, -50%) scale(${t.isCrit ? 1.2 : 1})`,
                    textShadow: `0 0 8px ${t.color}, 0 2px 3px rgba(0,0,0,0.5)`,
                    animation: t.isCrit ? 'shake 0.2s ease-out' : 'none',
                  }}>{t.text}</div>
                ))}

                {/* Announcements */}
                {announcements.map((a, i) => (
                  <div key={a.id} style={{
                    position: 'absolute',
                    left: '50%',
                    top: 60 + i * 40,
                    transform: 'translateX(-50%)',
                    fontSize: '18px',
                    fontWeight: 900,
                    color: a.color,
                    textShadow: `0 0 20px ${a.color}, 0 2px 4px rgba(0,0,0,0.5)`,
                    pointerEvents: 'none',
                    zIndex: 50,
                    opacity: Math.min(1, a.life / 500),
                    animation: 'popIn 0.2s ease-out',
                  }}>{a.text}</div>
                ))}

                {/* Game Over */}
                {gameState === 'lost' && (
                  <div style={{
                    position: 'absolute',
                    inset: 0,
                    background: 'rgba(10, 10, 18, 0.95)',
                    borderRadius: '10px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 100,
                    animation: 'slideIn 0.4s ease-out',
                  }}>
                    <div style={{ fontSize: '60px', marginBottom: '16px' }}>üíÄ</div>
                    <div style={{ fontSize: '28px', fontWeight: 900, color: theme.error, marginBottom: '8px' }}>GAME OVER</div>
                    <div style={{ fontSize: '14px', color: theme.textSecondary, marginBottom: '16px' }}>
                      Wave {wave} ‚Ä¢ Score {totalScore.toLocaleString()}
                    </div>
                    <div style={{ display: 'flex', gap: '16px', fontSize: '11px', color: theme.textMuted, marginBottom: '20px' }}>
                      <span>üéØ {killCount} kills</span>
                      <span>üî• {maxCombo} max combo</span>
                    </div>
                    <button onClick={startGame} className="btn" style={{
                      padding: '12px 32px',
                      fontSize: '14px',
                      fontWeight: 700,
                      background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                      border: 'none',
                      borderRadius: '10px',
                      color: '#fff',
                      boxShadow: `0 4px 16px ${theme.accentGlow}`,
                    }}>PLAY AGAIN</button>
                  </div>
                )}
              </div>

              {/* Wave preview */}
              {!waveInProgress && wavePreview && (
                <div style={{
                  marginTop: '8px',
                  padding: '8px 12px',
                  background: theme.bgPanel,
                  borderRadius: '8px',
                  border: `1px solid ${theme.border}`,
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '11px',
                }}>
                  <span style={{ color: theme.textMuted }}>Next:</span>
                  {Object.entries(wavePreview).map(([type, count]) => (
                    <span key={`preview-${type}`} style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                      <span>{enemyTypes[type].emoji}</span>
                      <span style={{ color: enemyTypes[type].color, fontWeight: 600 }}>√ó{count}</span>
                    </span>
                  ))}
                </div>
              )}
            </div>

            {/* Right Panel */}
            <div style={{
              background: theme.bgPanel,
              borderRadius: '12px',
              padding: '12px',
              border: `1px solid ${theme.border}`,
              width: '170px',
              flexShrink: 0,
            }}>
              {selectedTowerForUpgrade ? (
                <>
                  <div style={{ fontSize: '10px', fontWeight: 700, color: selectedTowerForUpgrade.color, letterSpacing: '1px', marginBottom: '8px' }}>
                    {selectedTowerForUpgrade.name.toUpperCase()}
                  </div>
                  <div style={{ textAlign: 'center', marginBottom: '10px' }}>
                    <span style={{ fontSize: '36px' }}>{selectedTowerForUpgrade.emoji}</span>
                    <div style={{ fontSize: '10px', color: theme.gold, fontWeight: 600 }}>Level {selectedTowerForUpgrade.level + 1}</div>
                  </div>
                  <div style={{ fontSize: '9px', color: theme.textSecondary, marginBottom: '10px', background: theme.bgDark, padding: '8px', borderRadius: '6px' }}>
                    <div>DMG: <span style={{ color: theme.text, fontWeight: 600 }}>{selectedTowerForUpgrade.damage}</span></div>
                    <div>RNG: <span style={{ color: theme.text, fontWeight: 600 }}>{selectedTowerForUpgrade.range}</span></div>
                    <div>DPS: <span style={{ color: theme.gold, fontWeight: 600 }}>{(selectedTowerForUpgrade.damage * 1000 / selectedTowerForUpgrade.fireRate).toFixed(1)}</span></div>
                    <div style={{ marginTop: '4px', borderTop: `1px solid ${theme.border}`, paddingTop: '4px' }}>
                      Kills: <span style={{ color: theme.error, fontWeight: 600 }}>{selectedTowerForUpgrade.kills}</span>
                    </div>
                  </div>

                  {selectedTowerForUpgrade.level < towerTypes[selectedTowerForUpgrade.type].upgrades.length ? (
                    <>
                      <div style={{ fontSize: '9px', color: theme.textMuted, marginBottom: '4px' }}>UPGRADE:</div>
                      <div style={{ background: theme.bgDark, padding: '8px', borderRadius: '6px', marginBottom: '8px' }}>
                        <div style={{ fontSize: '10px', fontWeight: 600, color: theme.gold }}>
                          {towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].name}
                        </div>
                        <div style={{ fontSize: '10px', color: theme.textSecondary }}>
                          üí∞ {towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost}
                        </div>
                      </div>
                      <button
                        onClick={() => upgradeTower(selectedTowerForUpgrade.id)}
                        disabled={gold < towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost}
                        className="btn"
                        style={{
                          width: '100%',
                          padding: '8px',
                          fontSize: '11px',
                          fontWeight: 700,
                          background: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost
                            ? `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`
                            : theme.bgDark,
                          border: 'none',
                          borderRadius: '6px',
                          color: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost ? '#fff' : theme.textMuted,
                          marginBottom: '6px',
                        }}
                      >UPGRADE [U]</button>
                    </>
                  ) : (
                    <div style={{ fontSize: '10px', color: theme.gold, textAlign: 'center', padding: '8px', background: `${theme.gold}10`, borderRadius: '6px', marginBottom: '8px' }}>
                      ‚ú® MAX LEVEL
                    </div>
                  )}
                  <button
                    onClick={() => sellTower(selectedTowerForUpgrade.id)}
                    className="btn"
                    style={{
                      width: '100%',
                      padding: '8px',
                      fontSize: '11px',
                      fontWeight: 700,
                      background: 'transparent',
                      border: `1px solid ${theme.error}`,
                      borderRadius: '6px',
                      color: theme.error,
                    }}
                  >SELL [S]</button>
                </>
              ) : (
                <>
                  <div style={{ fontSize: '10px', fontWeight: 700, color: theme.accent, letterSpacing: '1px', marginBottom: '10px' }}>ENEMIES</div>
                  {Object.values(enemyTypes).slice(0, 6).map(enemy => (
                    <div key={`info-${enemy.id}`} style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: '6px',
                      padding: '4px 6px',
                      marginBottom: '4px',
                      background: theme.bgDark,
                      borderRadius: '6px',
                    }}>
                      <span style={{ fontSize: '14px' }}>{enemy.emoji}</span>
                      <div>
                        <div style={{ fontSize: '9px', fontWeight: 600, color: enemy.color }}>{enemy.name}</div>
                        <div style={{ fontSize: '8px', color: theme.textMuted }}>HP:{enemy.health} üí∞{enemy.reward}</div>
                      </div>
                    </div>
                  ))}
                  <div style={{ marginTop: '12px', fontSize: '10px', fontWeight: 700, color: theme.accent, letterSpacing: '1px', marginBottom: '6px' }}>STATS</div>
                  <div style={{ fontSize: '9px', color: theme.textSecondary, background: theme.bgDark, padding: '8px', borderRadius: '6px' }}>
                    <div>Score: <span style={{ color: theme.gold, fontWeight: 600 }}>{totalScore.toLocaleString()}</span></div>
                    <div>Kills: <span style={{ color: theme.error, fontWeight: 600 }}>{killCount}</span></div>
                    <div>Best Combo: <span style={{ color: theme.accent, fontWeight: 600 }}>{maxCombo}</span></div>
                  </div>
                </>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TowerDefenseGame />);
  </script>
</body>
</html>

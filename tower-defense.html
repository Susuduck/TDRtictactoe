<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a12; overflow: hidden; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
const TowerDefenseGame = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  // Constants
  const GRID_SIZE = 15;
  const CELL_SIZE = 42;
  const GRID_OFFSET = 8;

  // Game state
  const [gameState, setGameState] = useState('menu');
  const [grid, setGrid] = useState(() => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)));
  const [towers, setTowers] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [projectiles, setProjectiles] = useState([]);
  const [particles, setParticles] = useState([]);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const [wave, setWave] = useState(1);
  const [lives, setLives] = useState(20);
  const [gold, setGold] = useState(150);
  const [selectedTower, setSelectedTower] = useState(null);
  const [hoveredCell, setHoveredCell] = useState(null);
  const [hoveredTower, setHoveredTower] = useState(null);
  const [path, setPath] = useState([]);
  const [waveInProgress, setWaveInProgress] = useState(false);
  const [enemiesSpawned, setEnemiesSpawned] = useState(0);
  const [totalEnemiesInWave, setTotalEnemiesInWave] = useState(0);
  const [totalScore, setTotalScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [comboTimer, setComboTimer] = useState(0);
  const [screenShake, setScreenShake] = useState({ x: 0, y: 0 });
  const [selectedTowerForUpgrade, setSelectedTowerForUpgrade] = useState(null);
  const [killCount, setKillCount] = useState(0);
  const [waveEnemies, setWaveEnemies] = useState([]);
  const [isPaused, setIsPaused] = useState(false);
  const [gameSpeed, setGameSpeed] = useState(1);

  // Refs
  const gameLoopRef = useRef(null);
  const lastTimeRef = useRef(0);
  const spawnTimerRef = useRef(null);
  const enemiesRef = useRef(enemies);
  const towersRef = useRef(towers);
  const pathRef = useRef(path);

  // Keep refs in sync
  useEffect(() => { enemiesRef.current = enemies; }, [enemies]);
  useEffect(() => { towersRef.current = towers; }, [towers]);
  useEffect(() => { pathRef.current = path; }, [path]);

  const theme = {
    bg: '#0a0a12',
    bgPanel: '#12121f',
    bgDark: '#08080d',
    bgCell: '#0d0d18',
    accent: '#7c6aed',
    accentBright: '#9d8cff',
    accentGlow: 'rgba(124, 106, 237, 0.6)',
    gold: '#ffd700',
    goldGlow: 'rgba(255, 215, 0, 0.5)',
    error: '#ff4757',
    errorGlow: 'rgba(255, 71, 87, 0.5)',
    success: '#2ed573',
    successGlow: 'rgba(46, 213, 115, 0.5)',
    frost: '#70c9ff',
    frostGlow: 'rgba(112, 201, 255, 0.6)',
    fire: '#ff6b35',
    fireGlow: 'rgba(255, 107, 53, 0.6)',
    lightning: '#fff200',
    lightningGlow: 'rgba(255, 242, 0, 0.7)',
    poison: '#a55eea',
    poisonGlow: 'rgba(165, 94, 234, 0.6)',
    text: '#f0f0ff',
    textSecondary: '#a0a0c0',
    textMuted: '#505070',
    border: '#252540',
    pathColor: 'rgba(124, 106, 237, 0.12)',
    critColor: '#ff0',
  };

  const towerTypes = {
    arrow: {
      id: 'arrow', name: 'Arrow Tower', emoji: 'üèπ', cost: 30,
      damage: 12, range: 3.5, fireRate: 700, color: '#2ed573',
      projectileSpeed: 18, projectileSize: 4, critChance: 0.15,
      description: 'Fast attacks, can crit for 2x damage',
      upgrades: [
        { cost: 40, damage: 18, fireRate: 600, name: 'Sharp Arrows' },
        { cost: 80, damage: 28, fireRate: 500, critChance: 0.25, name: 'Precision' },
        { cost: 150, damage: 40, fireRate: 400, critChance: 0.35, range: 4, name: 'Marksman' },
      ]
    },
    cannon: {
      id: 'cannon', name: 'Cannon', emoji: 'üí£', cost: 60,
      damage: 45, range: 2.8, fireRate: 1800, color: '#ff6b35',
      splash: 1.2, projectileSpeed: 10, projectileSize: 8,
      description: 'Slow but powerful splash damage',
      upgrades: [
        { cost: 50, damage: 65, splash: 1.4, name: 'Bigger Bombs' },
        { cost: 100, damage: 90, splash: 1.6, fireRate: 1600, name: 'Heavy Artillery' },
        { cost: 180, damage: 130, splash: 2, fireRate: 1400, name: 'Devastator' },
      ]
    },
    sniper: {
      id: 'sniper', name: 'Sniper', emoji: 'üéØ', cost: 80,
      damage: 75, range: 6, fireRate: 2200, color: '#5352ed',
      projectileSpeed: 30, projectileSize: 3, piercing: false,
      description: 'Extreme range, high single-target damage',
      upgrades: [
        { cost: 60, damage: 110, range: 7, name: 'Scope Upgrade' },
        { cost: 120, damage: 160, piercing: true, name: 'Armor Piercing' },
        { cost: 200, damage: 250, range: 8, fireRate: 1800, name: 'Railgun' },
      ]
    },
    frost: {
      id: 'frost', name: 'Frost Tower', emoji: '‚ùÑÔ∏è', cost: 50,
      damage: 8, range: 3, fireRate: 500, color: '#70c9ff',
      slow: 0.4, slowDuration: 2500, projectileSpeed: 14, projectileSize: 6,
      description: 'Slows enemies significantly',
      upgrades: [
        { cost: 45, slow: 0.5, slowDuration: 3000, name: 'Deep Freeze' },
        { cost: 90, slow: 0.6, slowDuration: 3500, damage: 15, name: 'Permafrost' },
        { cost: 160, slow: 0.7, slowDuration: 4000, damage: 25, range: 3.5, name: 'Absolute Zero' },
      ]
    },
    lightning: {
      id: 'lightning', name: 'Tesla Tower', emoji: '‚ö°', cost: 100,
      damage: 20, range: 3.2, fireRate: 350, color: '#fff200',
      chain: 4, chainDamageDecay: 0.7, projectileSpeed: 50, projectileSize: 2,
      description: 'Fast chain lightning jumps between enemies',
      upgrades: [
        { cost: 70, damage: 30, chain: 5, name: 'Arc Extension' },
        { cost: 140, damage: 45, chain: 6, chainDamageDecay: 0.8, name: 'Overcharge' },
        { cost: 220, damage: 65, chain: 8, fireRate: 280, name: 'Storm Caller' },
      ]
    },
    poison: {
      id: 'poison', name: 'Plague Tower', emoji: '‚ò†Ô∏è', cost: 70,
      damage: 5, range: 2.5, fireRate: 1200, color: '#a55eea',
      poisonDamage: 8, poisonDuration: 4000, splashPoison: 0.8,
      projectileSpeed: 12, projectileSize: 7,
      description: 'Applies damage over time to groups',
      upgrades: [
        { cost: 55, poisonDamage: 14, poisonDuration: 5000, name: 'Virulent' },
        { cost: 110, poisonDamage: 22, splashPoison: 1.2, name: 'Pandemic' },
        { cost: 190, poisonDamage: 35, poisonDuration: 6000, damage: 15, name: 'Blight' },
      ]
    },
    laser: {
      id: 'laser', name: 'Laser Tower', emoji: 'üî¥', cost: 120,
      damage: 3, range: 4, fireRate: 50, color: '#ff4757',
      beam: true, projectileSpeed: 999, projectileSize: 3,
      description: 'Continuous beam, damage ramps up over time',
      upgrades: [
        { cost: 80, damage: 5, range: 4.5, name: 'Focused Beam' },
        { cost: 150, damage: 8, range: 5, name: 'High Intensity' },
        { cost: 250, damage: 12, range: 5.5, name: 'Death Ray' },
      ]
    },
  };

  const enemyTypes = {
    slime: { id: 'slime', name: 'Slime', emoji: 'üü¢', health: 40, speed: 0.9, reward: 8, color: '#2ed573', size: 1 },
    scout: { id: 'scout', name: 'Scout', emoji: 'üîµ', health: 25, speed: 1.8, reward: 12, color: '#5352ed', size: 0.9 },
    tank: { id: 'tank', name: 'Golem', emoji: 'üü§', health: 180, speed: 0.45, reward: 25, color: '#cd6133', size: 1.3 },
    swarm: { id: 'swarm', name: 'Bug', emoji: 'üêõ', health: 15, speed: 1.4, reward: 5, color: '#7bed9f', size: 0.7 },
    healer: { id: 'healer', name: 'Medic', emoji: 'üíö', health: 60, speed: 0.7, reward: 20, color: '#26de81', size: 1, heals: true },
    shielded: { id: 'shielded', name: 'Knight', emoji: 'üõ°Ô∏è', health: 100, speed: 0.6, reward: 30, color: '#778ca3', size: 1.1, shield: 50 },
    splitter: { id: 'splitter', name: 'Amoeba', emoji: 'ü´ß', health: 80, speed: 0.8, reward: 15, color: '#a55eea', size: 1.1, splits: 2 },
    boss: { id: 'boss', name: 'Dragon', emoji: 'üêâ', health: 800, speed: 0.35, reward: 150, color: '#ff4757', size: 1.8, isBoss: true },
    megaBoss: { id: 'megaBoss', name: 'Titan', emoji: 'üëπ', health: 2000, speed: 0.25, reward: 300, color: '#ff0000', size: 2.2, isBoss: true },
  };

  const START = { row: 0, col: Math.floor(GRID_SIZE / 2) };
  const END = { row: GRID_SIZE - 1, col: Math.floor(GRID_SIZE / 2) };

  // Pathfinding
  const findPath = useCallback((gridState) => {
    const queue = [[START.row, START.col]];
    const visited = new Set();
    const parent = new Map();
    visited.add(`${START.row},${START.col}`);
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    while (queue.length > 0) {
      const [row, col] = queue.shift();
      if (row === END.row && col === END.col) {
        const pathResult = [];
        let current = `${END.row},${END.col}`;
        while (current) {
          const [r, c] = current.split(',').map(Number);
          pathResult.unshift({ row: r, col: c });
          current = parent.get(current);
        }
        return pathResult;
      }
      for (const [dr, dc] of directions) {
        const newRow = row + dr;
        const newCol = col + dc;
        const key = `${newRow},${newCol}`;
        if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE &&
            !visited.has(key) && gridState[newRow][newCol] === null) {
          visited.add(key);
          parent.set(key, `${row},${col}`);
          queue.push([newRow, newCol]);
        }
      }
    }
    return null;
  }, []);

  // Spawn particles
  const spawnParticles = useCallback((x, y, color, count = 8, config = {}) => {
    const {
      speed = 3,
      size = 4,
      life = 500,
      spread = Math.PI * 2,
      direction = 0,
      gravity = 0,
      type = 'circle'
    } = config;

    const newParticles = Array(count).fill(null).map(() => {
      const angle = direction + (Math.random() - 0.5) * spread;
      const vel = (0.5 + Math.random() * 0.5) * speed;
      return {
        id: Math.random(),
        x, y,
        vx: Math.cos(angle) * vel,
        vy: Math.sin(angle) * vel,
        size: size * (0.5 + Math.random() * 0.5),
        color,
        life,
        maxLife: life,
        gravity,
        type,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
      };
    });
    setParticles(prev => [...prev, ...newParticles]);
  }, []);

  // Spawn floating text
  const spawnFloatingText = useCallback((x, y, text, color, size = 14, isCrit = false) => {
    setFloatingTexts(prev => [...prev, {
      id: Math.random(),
      x, y,
      text,
      color,
      size,
      life: 1000,
      maxLife: 1000,
      isCrit,
      vx: (Math.random() - 0.5) * 2,
      vy: -2,
    }]);
  }, []);

  // Trigger screen shake
  const triggerShake = useCallback((intensity = 5) => {
    const shake = () => {
      setScreenShake({
        x: (Math.random() - 0.5) * intensity,
        y: (Math.random() - 0.5) * intensity,
      });
    };
    shake();
    setTimeout(shake, 50);
    setTimeout(shake, 100);
    setTimeout(() => setScreenShake({ x: 0, y: 0 }), 150);
  }, []);

  // Tower placement
  const canPlaceTower = useCallback((row, col) => {
    if (grid[row][col] !== null) return false;
    if (row === START.row && col === START.col) return false;
    if (row === END.row && col === END.col) return false;
    const testGrid = grid.map(r => [...r]);
    testGrid[row][col] = 'tower';
    return findPath(testGrid) !== null;
  }, [grid, findPath]);

  const placeTower = useCallback((row, col, towerType) => {
    if (!canPlaceTower(row, col)) return false;
    const towerDef = towerTypes[towerType];
    if (gold < towerDef.cost) return false;

    const newTower = {
      id: Date.now(),
      row,
      col,
      type: towerType,
      ...towerDef,
      lastFired: 0,
      level: 0,
      totalDamage: 0,
      kills: 0,
      beamTarget: null,
      beamDamageAccum: 0,
    };

    setTowers(prev => [...prev, newTower]);
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[row][col] = 'tower';
      return newGrid;
    });
    setGold(prev => prev - towerDef.cost);
    setSelectedTower(null);

    // Placement particles
    const cx = col * CELL_SIZE + CELL_SIZE / 2;
    const cy = row * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(cx, cy, towerDef.color, 12, { speed: 4, size: 5, life: 400 });

    const newGrid = grid.map(r => [...r]);
    newGrid[row][col] = 'tower';
    setPath(findPath(newGrid) || []);
    return true;
  }, [canPlaceTower, gold, grid, findPath, spawnParticles]);

  const sellTower = useCallback((towerId) => {
    const tower = towers.find(t => t.id === towerId);
    if (!tower) return;

    const baseCost = towerTypes[tower.type].cost;
    const upgradeCost = towerTypes[tower.type].upgrades
      .slice(0, tower.level)
      .reduce((sum, u) => sum + u.cost, 0);
    const sellValue = Math.floor((baseCost + upgradeCost) * 0.6);

    setTowers(prev => prev.filter(t => t.id !== towerId));
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[tower.row][tower.col] = null;
      return newGrid;
    });
    setGold(prev => prev + sellValue);
    setSelectedTowerForUpgrade(null);

    const cx = tower.col * CELL_SIZE + CELL_SIZE / 2;
    const cy = tower.row * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(cx, cy, theme.gold, 10, { speed: 3, life: 600 });
    spawnFloatingText(cx, cy, `+${sellValue}`, theme.gold, 16);

    const newGrid = grid.map(r => [...r]);
    newGrid[tower.row][tower.col] = null;
    setPath(findPath(newGrid) || []);
  }, [towers, grid, findPath, spawnParticles, spawnFloatingText]);

  const upgradeTower = useCallback((towerId) => {
    setTowers(prev => prev.map(tower => {
      if (tower.id !== towerId) return tower;
      const upgrades = towerTypes[tower.type].upgrades;
      if (tower.level >= upgrades.length) return tower;

      const upgrade = upgrades[tower.level];
      if (gold < upgrade.cost) return tower;

      setGold(g => g - upgrade.cost);

      const cx = tower.col * CELL_SIZE + CELL_SIZE / 2;
      const cy = tower.row * CELL_SIZE + CELL_SIZE / 2;
      spawnParticles(cx, cy, theme.gold, 15, { speed: 5, size: 6, life: 500 });

      return { ...tower, ...upgrade, level: tower.level + 1 };
    }));
  }, [gold, spawnParticles]);

  // Enemy spawning
  const spawnEnemy = useCallback((type, pathOffset = 0) => {
    const enemyDef = enemyTypes[type];
    const waveMultiplier = 1 + (wave - 1) * 0.15;
    const newEnemy = {
      id: Date.now() + Math.random(),
      type,
      ...enemyDef,
      health: Math.floor(enemyDef.health * waveMultiplier),
      maxHealth: Math.floor(enemyDef.health * waveMultiplier),
      currentHealth: Math.floor(enemyDef.health * waveMultiplier),
      currentShield: enemyDef.shield ? Math.floor(enemyDef.shield * waveMultiplier) : 0,
      maxShield: enemyDef.shield ? Math.floor(enemyDef.shield * waveMultiplier) : 0,
      pathIndex: 0,
      pathProgress: 0,
      x: START.col * CELL_SIZE + CELL_SIZE / 2,
      y: START.row * CELL_SIZE + CELL_SIZE / 2 - pathOffset * 20,
      slowedUntil: 0,
      slowAmount: 1,
      poisonedUntil: 0,
      poisonDamage: 0,
      animPhase: Math.random() * Math.PI * 2,
      rotation: 0,
      lastHealTime: 0,
    };
    setEnemies(prev => [...prev, newEnemy]);
  }, [wave]);

  // Generate wave composition
  const generateWaveEnemies = useCallback((waveNum) => {
    const enemies = [];
    const baseCount = 8 + waveNum * 2;

    // Basic enemies
    for (let i = 0; i < baseCount; i++) enemies.push('slime');

    // Fast enemies start wave 2
    if (waveNum >= 2) {
      for (let i = 0; i < Math.floor(waveNum * 0.8); i++) enemies.push('scout');
    }

    // Tanks start wave 3
    if (waveNum >= 3) {
      for (let i = 0; i < Math.floor(waveNum / 2); i++) enemies.push('tank');
    }

    // Swarms start wave 4
    if (waveNum >= 4) {
      for (let i = 0; i < waveNum; i++) enemies.push('swarm');
    }

    // Healers start wave 5
    if (waveNum >= 5) {
      for (let i = 0; i < Math.floor(waveNum / 4); i++) enemies.push('healer');
    }

    // Shielded enemies start wave 6
    if (waveNum >= 6) {
      for (let i = 0; i < Math.floor(waveNum / 3); i++) enemies.push('shielded');
    }

    // Splitters start wave 7
    if (waveNum >= 7) {
      for (let i = 0; i < Math.floor(waveNum / 4); i++) enemies.push('splitter');
    }

    // Boss every 5 waves
    if (waveNum % 5 === 0) {
      enemies.push('boss');
    }

    // Mega boss every 10 waves
    if (waveNum % 10 === 0) {
      enemies.push('megaBoss');
    }

    // Shuffle
    for (let i = enemies.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [enemies[i], enemies[j]] = [enemies[j], enemies[i]];
    }

    return enemies;
  }, []);

  const startWave = useCallback(() => {
    if (waveInProgress) return;
    setWaveInProgress(true);
    setEnemiesSpawned(0);

    const waveEnemyList = generateWaveEnemies(wave);
    setWaveEnemies(waveEnemyList);
    setTotalEnemiesInWave(waveEnemyList.length);

    let spawnIndex = 0;
    const spawnDelay = Math.max(300, 700 - wave * 20);

    spawnTimerRef.current = setInterval(() => {
      if (spawnIndex < waveEnemyList.length) {
        spawnEnemy(waveEnemyList[spawnIndex], spawnIndex % 3);
        spawnIndex++;
        setEnemiesSpawned(spawnIndex);
      } else {
        clearInterval(spawnTimerRef.current);
      }
    }, spawnDelay);
  }, [wave, waveInProgress, spawnEnemy, generateWaveEnemies]);

  // Main game loop using requestAnimationFrame
  useEffect(() => {
    if (gameState !== 'playing' || isPaused) return;

    let animationId;
    let lastTime = performance.now();

    const tick = (currentTime) => {
      const deltaTime = Math.min(currentTime - lastTime, 50) * gameSpeed;
      lastTime = currentTime;
      const now = Date.now();

      // Update enemies
      setEnemies(prevEnemies => {
        const newEnemies = [];
        const enemiesToSpawn = [];

        for (const enemy of prevEnemies) {
          // Check if reached end
          if (enemy.pathIndex >= pathRef.current.length) {
            setLives(l => {
              const damage = enemy.isBoss ? 5 : 1;
              const newLives = l - damage;
              if (newLives <= 0) setGameState('lost');
              return Math.max(0, newLives);
            });
            triggerShake(10);
            continue;
          }

          // Poison damage
          if (enemy.poisonedUntil > now && enemy.poisonDamage > 0) {
            const poisonTick = enemy.poisonDamage * deltaTime / 1000;
            enemy.currentHealth -= poisonTick;
            if (Math.random() < 0.1) {
              spawnParticles(enemy.x, enemy.y, theme.poison, 2, { speed: 1, size: 3, life: 300 });
            }
          }

          // Healer ability
          if (enemy.heals && now - enemy.lastHealTime > 2000) {
            for (const other of prevEnemies) {
              if (other.id !== enemy.id) {
                const dx = other.x - enemy.x;
                const dy = other.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < CELL_SIZE * 2) {
                  other.currentHealth = Math.min(other.maxHealth, other.currentHealth + 10);
                  spawnParticles(other.x, other.y, theme.success, 4, { speed: 2, size: 3, life: 400 });
                }
              }
            }
            enemy.lastHealTime = now;
            spawnParticles(enemy.x, enemy.y, theme.success, 6, { speed: 2, size: 4, life: 500 });
          }

          // Check death
          if (enemy.currentHealth <= 0) {
            // Reward
            const comboBonus = Math.floor(enemy.reward * combo * 0.1);
            const totalReward = enemy.reward + comboBonus;
            setGold(g => g + totalReward);
            setTotalScore(s => s + totalReward * 10);
            setKillCount(k => k + 1);

            // Combo
            setCombo(c => Math.min(c + 1, 50));
            setComboTimer(3000);

            // Death particles
            spawnParticles(enemy.x, enemy.y, enemy.color, 15, { speed: 4, size: 6, life: 600 });
            if (enemy.isBoss) {
              spawnParticles(enemy.x, enemy.y, theme.gold, 25, { speed: 6, size: 8, life: 800 });
              triggerShake(15);
            }

            // Floating text
            const textColor = comboBonus > 0 ? theme.gold : theme.success;
            spawnFloatingText(enemy.x, enemy.y - 10, `+${totalReward}`, textColor, comboBonus > 0 ? 18 : 14);

            // Splitter spawns mini enemies
            if (enemy.splits && enemy.splits > 0) {
              for (let i = 0; i < enemy.splits; i++) {
                enemiesToSpawn.push({
                  type: 'swarm',
                  x: enemy.x + (Math.random() - 0.5) * 20,
                  y: enemy.y + (Math.random() - 0.5) * 20,
                  pathIndex: enemy.pathIndex,
                });
              }
            }

            continue;
          }

          // Movement
          const target = pathRef.current[enemy.pathIndex];
          if (target) {
            const targetX = target.col * CELL_SIZE + CELL_SIZE / 2;
            const targetY = target.row * CELL_SIZE + CELL_SIZE / 2;
            const dx = targetX - enemy.x;
            const dy = targetY - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            let speed = enemy.speed * (deltaTime / 16);
            if (enemy.slowedUntil > now) speed *= enemy.slowAmount;

            // Calculate rotation towards movement direction
            enemy.rotation = Math.atan2(dy, dx);

            if (dist < speed * 2) {
              enemy.pathIndex++;
            } else {
              enemy.x += (dx / dist) * speed * 2;
              enemy.y += (dy / dist) * speed * 2;
            }
          }

          // Animation phase
          enemy.animPhase += deltaTime * 0.01;

          newEnemies.push(enemy);
        }

        // Spawn split enemies
        for (const spawn of enemiesToSpawn) {
          const enemyDef = enemyTypes[spawn.type];
          newEnemies.push({
            id: Date.now() + Math.random(),
            type: spawn.type,
            ...enemyDef,
            health: enemyDef.health,
            maxHealth: enemyDef.health,
            currentHealth: enemyDef.health,
            currentShield: 0,
            maxShield: 0,
            pathIndex: spawn.pathIndex,
            pathProgress: 0,
            x: spawn.x,
            y: spawn.y,
            slowedUntil: 0,
            slowAmount: 1,
            poisonedUntil: 0,
            poisonDamage: 0,
            animPhase: Math.random() * Math.PI * 2,
            rotation: 0,
            lastHealTime: 0,
          });
        }

        return newEnemies;
      });

      // Update towers and fire
      setTowers(prevTowers => {
        return prevTowers.map(tower => {
          const towerX = tower.col * CELL_SIZE + CELL_SIZE / 2;
          const towerY = tower.row * CELL_SIZE + CELL_SIZE / 2;

          // Beam tower continuous damage
          if (tower.beam) {
            let target = null;
            let minDist = Infinity;

            for (const enemy of enemiesRef.current) {
              const dx = enemy.x - towerX;
              const dy = enemy.y - towerY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= tower.range * CELL_SIZE && dist < minDist) {
                target = enemy;
                minDist = dist;
              }
            }

            if (target) {
              tower.beamTarget = { x: target.x, y: target.y, id: target.id };
              tower.beamDamageAccum += tower.damage * deltaTime / 16;

              if (tower.beamDamageAccum >= 1) {
                const damage = Math.floor(tower.beamDamageAccum);
                tower.beamDamageAccum -= damage;

                setEnemies(enemies => enemies.map(e => {
                  if (e.id === target.id) {
                    const newHealth = e.currentHealth - damage;
                    if (newHealth <= 0) {
                      tower.kills++;
                      tower.totalDamage += damage;
                    }
                    return { ...e, currentHealth: newHealth };
                  }
                  return e;
                }));
              }

              // Beam particles
              if (Math.random() < 0.3) {
                spawnParticles(target.x, target.y, tower.color, 1, { speed: 1, size: 3, life: 200 });
              }
            } else {
              tower.beamTarget = null;
            }

            return tower;
          }

          // Regular tower firing
          if (now - tower.lastFired < tower.fireRate) return tower;

          let target = null;
          let maxProgress = -1;

          for (const enemy of enemiesRef.current) {
            const dx = enemy.x - towerX;
            const dy = enemy.y - towerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= tower.range * CELL_SIZE && enemy.pathIndex > maxProgress) {
              target = enemy;
              maxProgress = enemy.pathIndex;
            }
          }

          if (target) {
            // Check for crit
            const isCrit = tower.critChance && Math.random() < tower.critChance;
            const damage = isCrit ? tower.damage * 2 : tower.damage;

            // Create projectile
            setProjectiles(p => [...p, {
              id: Date.now() + Math.random(),
              fromX: towerX,
              fromY: towerY,
              toX: target.x,
              toY: target.y,
              targetId: target.id,
              damage,
              color: tower.color,
              splash: tower.splash,
              slow: tower.slow,
              slowDuration: tower.slowDuration,
              chain: tower.chain,
              chainDamageDecay: tower.chainDamageDecay || 0.7,
              chainedEnemies: [],
              poisonDamage: tower.poisonDamage,
              poisonDuration: tower.poisonDuration,
              splashPoison: tower.splashPoison,
              progress: 0,
              speed: tower.projectileSpeed || 15,
              size: tower.projectileSize || 5,
              isCrit,
              trail: [],
              towerId: tower.id,
            }]);

            // Muzzle flash particles
            const angle = Math.atan2(target.y - towerY, target.x - towerX);
            spawnParticles(towerX, towerY, tower.color, 4, {
              speed: 3, size: 4, life: 150, spread: 0.5, direction: angle
            });

            return { ...tower, lastFired: now };
          }

          return tower;
        });
      });

      // Update projectiles
      setProjectiles(prevProjectiles => {
        const newProjectiles = [];

        for (const proj of prevProjectiles) {
          // Add trail
          proj.trail.push({ x: proj.fromX + (proj.toX - proj.fromX) * proj.progress, y: proj.fromY + (proj.toY - proj.fromY) * proj.progress });
          if (proj.trail.length > 8) proj.trail.shift();

          proj.progress += (proj.speed / 100) * (deltaTime / 16);

          if (proj.progress >= 1) {
            // Hit!
            let hitSomething = false;

            setEnemies(enemies => {
              const newEnemies = enemies.map(enemy => {
                if (enemy.id === proj.targetId || proj.chainedEnemies.includes(enemy.id)) {
                  return enemy; // Already hit by chain
                }

                if (enemy.id === proj.targetId) {
                  hitSomething = true;

                  // Shield absorbs damage first
                  let remainingDamage = proj.damage;
                  if (enemy.currentShield > 0) {
                    const shieldDamage = Math.min(enemy.currentShield, remainingDamage);
                    enemy.currentShield -= shieldDamage;
                    remainingDamage -= shieldDamage;
                    spawnParticles(enemy.x, enemy.y, '#778ca3', 6, { speed: 3, size: 4, life: 300 });
                  }

                  const newHealth = enemy.currentHealth - remainingDamage;

                  // Apply effects
                  if (proj.slow) {
                    enemy.slowedUntil = now + proj.slowDuration;
                    enemy.slowAmount = proj.slow;
                  }
                  if (proj.poisonDamage) {
                    enemy.poisonedUntil = now + proj.poisonDuration;
                    enemy.poisonDamage = proj.poisonDamage;
                  }

                  // Hit particles
                  spawnParticles(enemy.x, enemy.y, proj.color, 6, { speed: 3, size: 4, life: 300 });

                  // Crit text
                  if (proj.isCrit) {
                    spawnFloatingText(enemy.x, enemy.y - 15, 'CRIT!', theme.critColor, 16, true);
                  }

                  // Update tower stats
                  setTowers(towers => towers.map(t => {
                    if (t.id === proj.towerId) {
                      return {
                        ...t,
                        totalDamage: t.totalDamage + proj.damage,
                        kills: newHealth <= 0 ? t.kills + 1 : t.kills,
                      };
                    }
                    return t;
                  }));

                  return { ...enemy, currentHealth: newHealth };
                }

                // Splash damage
                if (proj.splash) {
                  const dx = enemy.x - proj.toX;
                  const dy = enemy.y - proj.toY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist <= proj.splash * CELL_SIZE) {
                    const splashDamage = proj.damage * 0.5;
                    const newHealth = enemy.currentHealth - splashDamage;

                    if (proj.splashPoison) {
                      enemy.poisonedUntil = now + (proj.poisonDuration || 3000);
                      enemy.poisonDamage = proj.poisonDamage * 0.5;
                    }

                    spawnParticles(enemy.x, enemy.y, proj.color, 3, { speed: 2, size: 3, life: 200 });
                    return { ...enemy, currentHealth: newHealth };
                  }
                }

                return enemy;
              }).filter(e => e !== null);

              return newEnemies;
            });

            // Splash explosion particles
            if (proj.splash) {
              spawnParticles(proj.toX, proj.toY, proj.color, 12, { speed: 5, size: 6, life: 400 });
              spawnParticles(proj.toX, proj.toY, '#fff', 8, { speed: 3, size: 3, life: 300 });
              triggerShake(3);
            }

            // Chain lightning
            if (proj.chain && proj.chain > 0) {
              let lastX = proj.toX;
              let lastY = proj.toY;
              const chainedIds = [proj.targetId];

              for (let i = 0; i < proj.chain; i++) {
                let nearestEnemy = null;
                let nearestDist = CELL_SIZE * 3;

                for (const enemy of enemiesRef.current) {
                  if (chainedIds.includes(enemy.id)) continue;
                  const dx = enemy.x - lastX;
                  const dy = enemy.y - lastY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                  }
                }

                if (nearestEnemy) {
                  chainedIds.push(nearestEnemy.id);
                  const chainDamage = proj.damage * Math.pow(proj.chainDamageDecay, i + 1);

                  setProjectiles(p => [...p, {
                    id: Date.now() + Math.random(),
                    fromX: lastX,
                    fromY: lastY,
                    toX: nearestEnemy.x,
                    toY: nearestEnemy.y,
                    targetId: nearestEnemy.id,
                    damage: chainDamage,
                    color: proj.color,
                    progress: 0,
                    speed: 50,
                    size: 3,
                    chain: 0,
                    chainedEnemies: chainedIds,
                    trail: [],
                    isChain: true,
                    towerId: proj.towerId,
                  }]);

                  lastX = nearestEnemy.x;
                  lastY = nearestEnemy.y;
                }
              }
            }

            continue;
          }

          newProjectiles.push(proj);
        }

        return newProjectiles;
      });

      // Update particles
      setParticles(prev => prev.map(p => ({
        ...p,
        x: p.x + p.vx * (deltaTime / 16),
        y: p.y + p.vy * (deltaTime / 16) + p.gravity * (deltaTime / 16),
        vy: p.vy + p.gravity * 0.1,
        life: p.life - deltaTime,
        rotation: p.rotation + p.rotationSpeed,
      })).filter(p => p.life > 0));

      // Update floating texts
      setFloatingTexts(prev => prev.map(t => ({
        ...t,
        x: t.x + t.vx * (deltaTime / 16),
        y: t.y + t.vy * (deltaTime / 16),
        vy: t.vy - 0.05,
        life: t.life - deltaTime,
      })).filter(t => t.life > 0));

      // Update combo timer
      setComboTimer(prev => {
        const newTimer = prev - deltaTime;
        if (newTimer <= 0) {
          setCombo(0);
          return 0;
        }
        return newTimer;
      });

      // Check wave end
      if (waveInProgress && enemiesRef.current.length === 0 && enemiesSpawned >= totalEnemiesInWave && totalEnemiesInWave > 0) {
        setWaveInProgress(false);
        const waveBonus = 30 + wave * 10;
        setGold(g => g + waveBonus);
        spawnFloatingText(GRID_SIZE * CELL_SIZE / 2, GRID_SIZE * CELL_SIZE / 2, `Wave ${wave} Complete! +${waveBonus}`, theme.gold, 24);
        setWave(w => w + 1);
      }

      animationId = requestAnimationFrame(tick);
    };

    animationId = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(animationId);
  }, [gameState, isPaused, gameSpeed, waveInProgress, enemiesSpawned, totalEnemiesInWave, wave, triggerShake, spawnParticles, spawnFloatingText]);

  // Initialize path
  useEffect(() => {
    setPath(findPath(grid) || []);
  }, []);

  // Start game
  const startGame = () => {
    const emptyGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    setGrid(emptyGrid);
    setTowers([]);
    setEnemies([]);
    setProjectiles([]);
    setParticles([]);
    setFloatingTexts([]);
    setWave(1);
    setLives(20);
    setGold(150);
    setWaveInProgress(false);
    setEnemiesSpawned(0);
    setTotalEnemiesInWave(0);
    setTotalScore(0);
    setCombo(0);
    setComboTimer(0);
    setKillCount(0);
    setSelectedTowerForUpgrade(null);
    setPath(findPath(emptyGrid) || []);
    setGameState('playing');
  };

  const styles = `
    @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');

    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
    @keyframes slideIn { 0% { transform: translateY(30px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes float { 0%, 100% { transform: translateY(0px); } 50% { transform: translateY(-10px); } }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    * { box-sizing: border-box; }

    .tower-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .start-btn:hover { transform: scale(1.05); }
    .cell:hover { background: rgba(255,255,255,0.05) !important; }
  `;

  const gridWidth = GRID_SIZE * CELL_SIZE + GRID_OFFSET * 2;

  return (
    <div style={{
      width: '100%',
      minHeight: '100vh',
      background: `radial-gradient(ellipse at center, #15152a 0%, #0a0a12 70%)`,
      fontFamily: "'Nunito', sans-serif",
      color: theme.text,
      position: 'relative',
      overflow: 'hidden'
    }}>
      <style>{styles}</style>

      {/* Background grid effect */}
      <div style={{
        position: 'fixed',
        inset: 0,
        backgroundImage: `
          linear-gradient(rgba(124,106,237,0.03) 1px, transparent 1px),
          linear-gradient(90deg, rgba(124,106,237,0.03) 1px, transparent 1px)
        `,
        backgroundSize: '50px 50px',
        pointerEvents: 'none',
      }} />

      <div style={{
        position: 'relative',
        zIndex: 5,
        minHeight: '100vh',
        padding: '20px',
        transform: `translate(${screenShake.x}px, ${screenShake.y}px)`,
      }}>

        {/* MENU */}
        {gameState === 'menu' && (
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: 'calc(100vh - 40px)' }}>
            <div style={{ textAlign: 'center', animation: 'slideIn 0.6s ease-out' }}>
              <div style={{ marginBottom: '30px', animation: 'float 3s ease-in-out infinite' }}>
                <div style={{
                  width: 140, height: 140,
                  background: `linear-gradient(135deg, ${theme.accent}30 0%, ${theme.accent}10 100%)`,
                  borderRadius: '28px',
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  fontSize: 70,
                  boxShadow: `0 0 60px ${theme.accentGlow}, inset 0 0 30px rgba(255,255,255,0.1)`,
                  border: `3px solid ${theme.accent}`,
                  margin: '0 auto',
                }}>üè∞</div>
              </div>
              <h1 style={{
                fontSize: '52px',
                fontWeight: 900,
                marginBottom: '12px',
                background: `linear-gradient(135deg, ${theme.gold} 0%, ${theme.accent} 50%, ${theme.accentBright} 100%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                textShadow: `0 0 60px ${theme.goldGlow}`,
              }}>TOWER DEFENSE</h1>
              <p style={{ fontSize: '16px', color: theme.textSecondary, marginBottom: '40px', maxWidth: '400px', margin: '0 auto 40px' }}>
                Build towers. Create mazes. Survive the onslaught!
              </p>
              <button
                onClick={startGame}
                className="start-btn"
                style={{
                  padding: '18px 60px',
                  fontSize: '20px',
                  fontWeight: 800,
                  fontFamily: 'inherit',
                  background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                  border: 'none',
                  borderRadius: '16px',
                  color: '#fff',
                  cursor: 'pointer',
                  boxShadow: `0 4px 30px ${theme.accentGlow}`,
                  transition: 'all 0.2s ease',
                }}
              >
                START GAME
              </button>

              <div style={{ marginTop: '40px', display: 'flex', gap: '20px', justifyContent: 'center', flexWrap: 'wrap', maxWidth: '500px', margin: '40px auto 0' }}>
                {Object.values(towerTypes).slice(0, 4).map(tower => (
                  <div key={tower.id} style={{
                    background: theme.bgPanel,
                    padding: '12px 16px',
                    borderRadius: '12px',
                    border: `1px solid ${theme.border}`,
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px',
                  }}>
                    <span style={{ fontSize: '24px' }}>{tower.emoji}</span>
                    <span style={{ fontSize: '12px', color: tower.color, fontWeight: 700 }}>{tower.name}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* PLAYING */}
        {(gameState === 'playing' || gameState === 'lost') && (
          <div style={{ display: 'flex', gap: '16px', justifyContent: 'center', alignItems: 'flex-start' }}>

            {/* Left Panel - Towers */}
            <div style={{
              background: `linear-gradient(180deg, ${theme.bgPanel} 0%, ${theme.bgDark} 100%)`,
              borderRadius: '16px',
              padding: '16px',
              border: `1px solid ${theme.border}`,
              width: '200px',
              boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
            }}>
              <h3 style={{ fontSize: '12px', fontWeight: 800, marginBottom: '12px', color: theme.gold, letterSpacing: '2px' }}>TOWERS</h3>

              {Object.values(towerTypes).map(tower => (
                <div
                  key={tower.id}
                  onClick={() => gold >= tower.cost && setSelectedTower(tower.id)}
                  className="tower-btn"
                  style={{
                    background: selectedTower === tower.id ? `${tower.color}25` : theme.bgDark,
                    borderRadius: '10px',
                    padding: '10px',
                    marginBottom: '8px',
                    cursor: gold >= tower.cost ? 'pointer' : 'not-allowed',
                    opacity: gold >= tower.cost ? 1 : 0.4,
                    border: selectedTower === tower.id ? `2px solid ${tower.color}` : `1px solid ${theme.border}`,
                    transition: 'all 0.2s ease',
                    position: 'relative',
                    overflow: 'hidden',
                  }}
                >
                  {selectedTower === tower.id && (
                    <div style={{
                      position: 'absolute',
                      inset: 0,
                      background: `radial-gradient(circle at center, ${tower.color}20 0%, transparent 70%)`,
                      animation: 'pulse 1s ease-in-out infinite',
                    }} />
                  )}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px', position: 'relative' }}>
                    <span style={{ fontSize: '22px' }}>{tower.emoji}</span>
                    <span style={{ fontSize: '11px', fontWeight: 700, color: tower.color }}>{tower.name}</span>
                  </div>
                  <div style={{ fontSize: '9px', color: theme.textMuted, marginBottom: '4px', position: 'relative' }}>{tower.description}</div>
                  <div style={{ fontSize: '11px', color: theme.gold, fontWeight: 700, position: 'relative' }}>üí∞ {tower.cost}</div>
                </div>
              ))}

              <div style={{ marginTop: '12px', padding: '10px', background: theme.bgDark, borderRadius: '10px', fontSize: '10px', color: theme.textMuted }}>
                <div style={{ fontWeight: 700, marginBottom: '4px', color: theme.textSecondary }}>CONTROLS</div>
                ‚Ä¢ Click tower, then grid<br/>
                ‚Ä¢ Click placed tower to upgrade<br/>
                ‚Ä¢ Right-click to sell<br/>
                ‚Ä¢ Don't block the path!
              </div>
            </div>

            {/* Center - Game Grid */}
            <div style={{ position: 'relative' }}>
              {/* Top Stats Bar */}
              <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '12px',
                padding: '12px 16px',
                background: `linear-gradient(90deg, ${theme.bgPanel} 0%, ${theme.bgDark} 100%)`,
                borderRadius: '12px',
                border: `1px solid ${theme.border}`,
                boxShadow: '0 4px 15px rgba(0,0,0,0.2)',
              }}>
                <div style={{ display: 'flex', gap: '20px' }}>
                  <div style={{ textAlign: 'center' }}>
                    <span style={{ fontSize: '9px', color: theme.textMuted, letterSpacing: '1px' }}>WAVE</span>
                    <div style={{ fontSize: '22px', fontWeight: 900, color: theme.accent }}>{wave}</div>
                  </div>
                  <div style={{ textAlign: 'center' }}>
                    <span style={{ fontSize: '9px', color: theme.textMuted, letterSpacing: '1px' }}>LIVES</span>
                    <div style={{
                      fontSize: '22px',
                      fontWeight: 900,
                      color: lives <= 5 ? theme.error : theme.success,
                      animation: lives <= 5 ? 'blink 0.5s ease-in-out infinite' : 'none',
                    }}>‚ù§Ô∏è {lives}</div>
                  </div>
                  <div style={{ textAlign: 'center' }}>
                    <span style={{ fontSize: '9px', color: theme.textMuted, letterSpacing: '1px' }}>GOLD</span>
                    <div style={{ fontSize: '22px', fontWeight: 900, color: theme.gold }}>üí∞ {gold}</div>
                  </div>
                  <div style={{ textAlign: 'center' }}>
                    <span style={{ fontSize: '9px', color: theme.textMuted, letterSpacing: '1px' }}>SCORE</span>
                    <div style={{ fontSize: '22px', fontWeight: 900, color: theme.text }}>{totalScore.toLocaleString()}</div>
                  </div>
                  {combo > 0 && (
                    <div style={{ textAlign: 'center' }}>
                      <span style={{ fontSize: '9px', color: theme.textMuted, letterSpacing: '1px' }}>COMBO</span>
                      <div style={{
                        fontSize: '22px',
                        fontWeight: 900,
                        color: combo >= 10 ? theme.gold : theme.accent,
                        animation: combo >= 10 ? 'rainbow 2s linear infinite' : 'none',
                      }}>üî• x{combo}</div>
                    </div>
                  )}
                </div>

                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                  <button
                    onClick={() => setGameSpeed(gameSpeed === 1 ? 2 : gameSpeed === 2 ? 3 : 1)}
                    style={{
                      padding: '8px 16px',
                      fontSize: '12px',
                      fontWeight: 700,
                      fontFamily: 'inherit',
                      background: theme.bgDark,
                      border: `1px solid ${theme.border}`,
                      borderRadius: '8px',
                      color: theme.textSecondary,
                      cursor: 'pointer',
                    }}
                  >
                    {gameSpeed}x
                  </button>
                  <button
                    onClick={startWave}
                    disabled={waveInProgress}
                    style={{
                      padding: '10px 24px',
                      fontSize: '14px',
                      fontWeight: 800,
                      fontFamily: 'inherit',
                      background: waveInProgress ? theme.bgDark : `linear-gradient(135deg, ${theme.success} 0%, #1fab54 100%)`,
                      border: 'none',
                      borderRadius: '10px',
                      color: waveInProgress ? theme.textMuted : '#fff',
                      cursor: waveInProgress ? 'not-allowed' : 'pointer',
                      boxShadow: waveInProgress ? 'none' : `0 4px 15px ${theme.successGlow}`,
                      transition: 'all 0.2s ease',
                    }}
                  >
                    {waveInProgress ? `${enemiesSpawned}/${totalEnemiesInWave}` : `START WAVE ${wave}`}
                  </button>
                </div>
              </div>

              {/* Wave Progress Bar */}
              {waveInProgress && (
                <div style={{
                  position: 'absolute',
                  top: '70px',
                  left: 0,
                  right: 0,
                  height: '4px',
                  background: theme.bgDark,
                  borderRadius: '2px',
                  overflow: 'hidden',
                  zIndex: 50,
                }}>
                  <div style={{
                    width: `${(enemiesSpawned / totalEnemiesInWave) * 100}%`,
                    height: '100%',
                    background: `linear-gradient(90deg, ${theme.accent} 0%, ${theme.success} 100%)`,
                    transition: 'width 0.3s ease',
                    boxShadow: `0 0 10px ${theme.accentGlow}`,
                  }} />
                </div>
              )}

              {/* Game Grid */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`,
                gap: '2px',
                background: theme.bgDark,
                padding: `${GRID_OFFSET}px`,
                borderRadius: '16px',
                border: `2px solid ${theme.border}`,
                position: 'relative',
                boxShadow: `0 8px 40px rgba(0,0,0,0.4), inset 0 0 60px rgba(0,0,0,0.3)`,
              }}>
                {grid.map((row, rowIdx) => row.map((cell, colIdx) => {
                  const isStart = rowIdx === START.row && colIdx === START.col;
                  const isEnd = rowIdx === END.row && colIdx === END.col;
                  const isPath = path.some(p => p.row === rowIdx && p.col === colIdx);
                  const isHovered = hoveredCell?.row === rowIdx && hoveredCell?.col === colIdx;
                  const tower = towers.find(t => t.row === rowIdx && t.col === colIdx);
                  const canPlace = selectedTower && canPlaceTower(rowIdx, colIdx) && gold >= towerTypes[selectedTower].cost;
                  const isSelected = selectedTowerForUpgrade?.id === tower?.id;

                  return (
                    <div
                      key={`${rowIdx}-${colIdx}`}
                      className="cell"
                      onClick={() => {
                        if (selectedTower && canPlace) {
                          placeTower(rowIdx, colIdx, selectedTower);
                        } else if (tower && !selectedTower) {
                          setSelectedTowerForUpgrade(isSelected ? null : tower);
                        }
                      }}
                      onContextMenu={(e) => { e.preventDefault(); if (tower) sellTower(tower.id); }}
                      onMouseEnter={() => setHoveredCell({ row: rowIdx, col: colIdx })}
                      onMouseLeave={() => setHoveredCell(null)}
                      style={{
                        width: CELL_SIZE,
                        height: CELL_SIZE,
                        background: isStart ? `radial-gradient(circle, ${theme.success}50 0%, ${theme.success}20 70%)`
                          : isEnd ? `radial-gradient(circle, ${theme.error}50 0%, ${theme.error}20 70%)`
                          : tower ? `radial-gradient(circle, ${tower.color}40 0%, ${tower.color}15 70%)`
                          : isHovered && canPlace ? `${towerTypes[selectedTower].color}30`
                          : isHovered && selectedTower && !canPlace ? `${theme.error}30`
                          : isPath ? theme.pathColor
                          : theme.bgCell,
                        borderRadius: '6px',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        cursor: canPlace || tower ? 'pointer' : 'default',
                        position: 'relative',
                        transition: 'background 0.15s ease',
                        border: isSelected ? `2px solid ${tower.color}` : isStart || isEnd ? `1px solid ${isStart ? theme.success : theme.error}40` : 'none',
                        boxShadow: tower ? `inset 0 0 15px ${tower.color}30` : 'none',
                      }}
                    >
                      {isStart && <span style={{ fontSize: '20px', filter: 'drop-shadow(0 0 8px rgba(46,213,115,0.8))' }}>üö™</span>}
                      {isEnd && <span style={{ fontSize: '20px', filter: 'drop-shadow(0 0 8px rgba(255,71,87,0.8))' }}>üè†</span>}
                      {tower && (
                        <>
                          <span style={{
                            fontSize: '24px',
                            filter: `drop-shadow(0 0 8px ${tower.color})`,
                            animation: tower.beamTarget ? 'glow 0.3s ease-in-out infinite' : 'none',
                          }}>{tower.emoji}</span>
                          {tower.level > 0 && (
                            <div style={{
                              position: 'absolute',
                              bottom: '2px',
                              right: '2px',
                              fontSize: '8px',
                              fontWeight: 900,
                              color: theme.gold,
                              textShadow: `0 0 4px ${theme.goldGlow}`,
                            }}>‚òÖ{tower.level}</div>
                          )}
                        </>
                      )}
                      {isHovered && canPlace && !tower && (
                        <span style={{ fontSize: '24px', opacity: 0.5 }}>{towerTypes[selectedTower].emoji}</span>
                      )}
                    </div>
                  );
                }))}

                {/* Tower Range Indicator */}
                {(hoveredCell && selectedTower && canPlaceTower(hoveredCell.row, hoveredCell.col)) && (
                  <div style={{
                    position: 'absolute',
                    left: hoveredCell.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    top: hoveredCell.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    width: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    height: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px dashed ${towerTypes[selectedTower].color}50`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${towerTypes[selectedTower].color}10 0%, transparent 70%)`,
                  }} />
                )}

                {/* Selected Tower Range */}
                {selectedTowerForUpgrade && (
                  <div style={{
                    position: 'absolute',
                    left: selectedTowerForUpgrade.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    top: selectedTowerForUpgrade.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    width: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    height: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px solid ${selectedTowerForUpgrade.color}80`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${selectedTowerForUpgrade.color}15 0%, transparent 70%)`,
                    animation: 'pulse 2s ease-in-out infinite',
                  }} />
                )}

                {/* Laser Beams */}
                {towers.filter(t => t.beam && t.beamTarget).map(tower => {
                  const fromX = tower.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET;
                  const fromY = tower.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET;
                  const toX = tower.beamTarget.x + GRID_OFFSET;
                  const toY = tower.beamTarget.y + GRID_OFFSET;
                  const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                  const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);

                  return (
                    <div key={`beam-${tower.id}`} style={{
                      position: 'absolute',
                      left: fromX,
                      top: fromY,
                      width: length,
                      height: '4px',
                      background: `linear-gradient(90deg, ${tower.color} 0%, ${tower.color}80 100%)`,
                      transform: `rotate(${angle}deg)`,
                      transformOrigin: '0 50%',
                      pointerEvents: 'none',
                      boxShadow: `0 0 10px ${tower.color}, 0 0 20px ${tower.color}80`,
                      zIndex: 15,
                    }} />
                  );
                })}

                {/* Enemies */}
                {enemies.map(enemy => {
                  const size = 20 * (enemy.size || 1);
                  const bobOffset = Math.sin(enemy.animPhase * 3) * 2;

                  return (
                    <div
                      key={enemy.id}
                      style={{
                        position: 'absolute',
                        left: enemy.x - size / 2 + GRID_OFFSET,
                        top: enemy.y - size / 2 + GRID_OFFSET + bobOffset,
                        width: size,
                        height: size,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        flexDirection: 'column',
                        pointerEvents: 'none',
                        zIndex: 10,
                        filter: enemy.poisonedUntil > Date.now() ? `drop-shadow(0 0 6px ${theme.poison})`
                          : enemy.slowedUntil > Date.now() ? `drop-shadow(0 0 6px ${theme.frost})`
                          : `drop-shadow(0 0 4px ${enemy.color})`,
                        transition: 'filter 0.2s ease',
                      }}
                    >
                      <span style={{
                        fontSize: enemy.isBoss ? '32px' : `${14 * (enemy.size || 1)}px`,
                        transform: `scaleX(${enemy.rotation > -Math.PI / 2 && enemy.rotation < Math.PI / 2 ? 1 : -1})`,
                      }}>{enemy.emoji}</span>

                      {/* Health bar */}
                      <div style={{
                        position: 'absolute',
                        bottom: -8,
                        width: size + 4,
                        height: enemy.isBoss ? 6 : 4,
                        background: 'rgba(0,0,0,0.7)',
                        borderRadius: '3px',
                        border: '1px solid rgba(255,255,255,0.1)',
                        overflow: 'hidden',
                      }}>
                        {/* Shield bar */}
                        {enemy.maxShield > 0 && (
                          <div style={{
                            position: 'absolute',
                            width: `${(enemy.currentShield / enemy.maxShield) * 100}%`,
                            height: '100%',
                            background: '#778ca3',
                            borderRadius: '2px',
                            transition: 'width 0.1s ease',
                          }} />
                        )}
                        {/* Health bar */}
                        <div style={{
                          width: `${(enemy.currentHealth / enemy.maxHealth) * 100}%`,
                          height: '100%',
                          background: enemy.currentHealth > enemy.maxHealth * 0.5 ? theme.success
                            : enemy.currentHealth > enemy.maxHealth * 0.25 ? theme.gold
                            : theme.error,
                          borderRadius: '2px',
                          transition: 'width 0.1s ease',
                          boxShadow: enemy.currentHealth <= enemy.maxHealth * 0.25 ? `0 0 6px ${theme.error}` : 'none',
                        }} />
                      </div>

                      {/* Slow indicator */}
                      {enemy.slowedUntil > Date.now() && (
                        <div style={{
                          position: 'absolute',
                          top: -6,
                          fontSize: '10px',
                        }}>‚ùÑÔ∏è</div>
                      )}

                      {/* Poison indicator */}
                      {enemy.poisonedUntil > Date.now() && (
                        <div style={{
                          position: 'absolute',
                          top: -6,
                          left: enemy.slowedUntil > Date.now() ? 12 : 0,
                          fontSize: '10px',
                        }}>‚ò†Ô∏è</div>
                      )}
                    </div>
                  );
                })}

                {/* Projectiles */}
                {projectiles.map(proj => {
                  const x = proj.fromX + (proj.toX - proj.fromX) * proj.progress;
                  const y = proj.fromY + (proj.toY - proj.fromY) * proj.progress;
                  const angle = Math.atan2(proj.toY - proj.fromY, proj.toX - proj.fromX);

                  return (
                    <React.Fragment key={proj.id}>
                      {/* Trail */}
                      {proj.trail.map((point, i) => (
                        <div key={i} style={{
                          position: 'absolute',
                          left: point.x - proj.size * 0.3 + GRID_OFFSET,
                          top: point.y - proj.size * 0.3 + GRID_OFFSET,
                          width: proj.size * 0.6,
                          height: proj.size * 0.6,
                          background: proj.color,
                          borderRadius: '50%',
                          opacity: (i / proj.trail.length) * 0.5,
                          pointerEvents: 'none',
                          zIndex: 18,
                        }} />
                      ))}

                      {/* Projectile */}
                      <div style={{
                        position: 'absolute',
                        left: x - proj.size / 2 + GRID_OFFSET,
                        top: y - proj.size / 2 + GRID_OFFSET,
                        width: proj.size * (proj.isChain ? 1.5 : 1),
                        height: proj.size * (proj.isChain ? 1.5 : 1),
                        background: proj.isChain
                          ? `radial-gradient(circle, #fff 0%, ${proj.color} 50%, transparent 100%)`
                          : `radial-gradient(circle, #fff 0%, ${proj.color} 70%)`,
                        borderRadius: '50%',
                        boxShadow: `0 0 ${proj.size * 2}px ${proj.color}, 0 0 ${proj.size * 4}px ${proj.color}80`,
                        pointerEvents: 'none',
                        zIndex: 20,
                        transform: proj.isChain ? 'none' : `rotate(${angle}rad)`,
                      }} />
                    </React.Fragment>
                  );
                })}

                {/* Particles */}
                {particles.map(p => (
                  <div
                    key={p.id}
                    style={{
                      position: 'absolute',
                      left: p.x - p.size / 2 + GRID_OFFSET,
                      top: p.y - p.size / 2 + GRID_OFFSET,
                      width: p.size,
                      height: p.size,
                      background: p.color,
                      borderRadius: p.type === 'square' ? '2px' : '50%',
                      opacity: p.life / p.maxLife,
                      pointerEvents: 'none',
                      zIndex: 25,
                      transform: `rotate(${p.rotation}deg) scale(${p.life / p.maxLife})`,
                      boxShadow: `0 0 ${p.size}px ${p.color}`,
                    }}
                  />
                ))}

                {/* Floating Texts */}
                {floatingTexts.map(t => (
                  <div
                    key={t.id}
                    style={{
                      position: 'absolute',
                      left: t.x + GRID_OFFSET,
                      top: t.y + GRID_OFFSET,
                      fontSize: `${t.size}px`,
                      fontWeight: 900,
                      color: t.color,
                      pointerEvents: 'none',
                      zIndex: 30,
                      opacity: t.life / t.maxLife,
                      transform: `translate(-50%, -50%) scale(${t.isCrit ? 1.2 : 1})`,
                      textShadow: `0 0 10px ${t.color}, 0 2px 4px rgba(0,0,0,0.5)`,
                      animation: t.isCrit ? 'shake 0.3s ease-out' : 'none',
                    }}
                  >
                    {t.text}
                  </div>
                ))}

                {/* Game Over Overlay */}
                {gameState === 'lost' && (
                  <div style={{
                    position: 'absolute',
                    inset: 0,
                    background: 'rgba(10, 10, 18, 0.95)',
                    borderRadius: '14px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 100,
                    animation: 'slideIn 0.5s ease-out',
                  }}>
                    <div style={{ fontSize: '80px', marginBottom: '20px' }}>üíÄ</div>
                    <div style={{ fontSize: '40px', fontWeight: 900, color: theme.error, marginBottom: '12px' }}>GAME OVER</div>
                    <div style={{ fontSize: '18px', color: theme.textSecondary, marginBottom: '24px' }}>
                      Wave {wave} ‚Ä¢ Score: {totalScore.toLocaleString()} ‚Ä¢ Kills: {killCount}
                    </div>
                    <button
                      onClick={startGame}
                      style={{
                        padding: '14px 40px',
                        fontSize: '18px',
                        fontWeight: 800,
                        fontFamily: 'inherit',
                        background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                        border: 'none',
                        borderRadius: '12px',
                        color: '#fff',
                        cursor: 'pointer',
                        boxShadow: `0 4px 20px ${theme.accentGlow}`,
                      }}
                    >
                      TRY AGAIN
                    </button>
                  </div>
                )}
              </div>
            </div>

            {/* Right Panel - Info & Upgrades */}
            <div style={{
              background: `linear-gradient(180deg, ${theme.bgPanel} 0%, ${theme.bgDark} 100%)`,
              borderRadius: '16px',
              padding: '16px',
              border: `1px solid ${theme.border}`,
              width: '200px',
              boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
            }}>
              {/* Tower Upgrade Panel */}
              {selectedTowerForUpgrade ? (
                <>
                  <h3 style={{ fontSize: '12px', fontWeight: 800, marginBottom: '12px', color: selectedTowerForUpgrade.color, letterSpacing: '2px' }}>
                    {selectedTowerForUpgrade.name.toUpperCase()}
                  </h3>

                  <div style={{ textAlign: 'center', marginBottom: '12px' }}>
                    <span style={{ fontSize: '40px' }}>{selectedTowerForUpgrade.emoji}</span>
                    <div style={{ fontSize: '11px', color: theme.gold, fontWeight: 700 }}>
                      Level {selectedTowerForUpgrade.level + 1}
                    </div>
                  </div>

                  <div style={{ fontSize: '10px', color: theme.textSecondary, marginBottom: '12px', background: theme.bgDark, padding: '8px', borderRadius: '8px' }}>
                    <div>Damage: <span style={{ color: theme.text, fontWeight: 700 }}>{selectedTowerForUpgrade.damage}</span></div>
                    <div>Range: <span style={{ color: theme.text, fontWeight: 700 }}>{selectedTowerForUpgrade.range}</span></div>
                    <div>Fire Rate: <span style={{ color: theme.text, fontWeight: 700 }}>{(1000 / selectedTowerForUpgrade.fireRate).toFixed(1)}/s</span></div>
                    <div style={{ marginTop: '6px', borderTop: `1px solid ${theme.border}`, paddingTop: '6px' }}>
                      Total Damage: <span style={{ color: theme.gold, fontWeight: 700 }}>{Math.floor(selectedTowerForUpgrade.totalDamage)}</span>
                    </div>
                    <div>Kills: <span style={{ color: theme.error, fontWeight: 700 }}>{selectedTowerForUpgrade.kills}</span></div>
                  </div>

                  {selectedTowerForUpgrade.level < towerTypes[selectedTowerForUpgrade.type].upgrades.length ? (
                    <>
                      <div style={{ fontSize: '10px', color: theme.textMuted, marginBottom: '6px' }}>NEXT UPGRADE:</div>
                      <div style={{
                        background: theme.bgDark,
                        padding: '10px',
                        borderRadius: '8px',
                        marginBottom: '10px',
                        border: `1px solid ${theme.border}`,
                      }}>
                        <div style={{ fontSize: '11px', fontWeight: 700, color: theme.gold, marginBottom: '4px' }}>
                          {towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].name}
                        </div>
                        <div style={{ fontSize: '10px', color: theme.textSecondary }}>
                          Cost: <span style={{ color: theme.gold, fontWeight: 700 }}>
                            üí∞ {towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost}
                          </span>
                        </div>
                      </div>
                      <button
                        onClick={() => upgradeTower(selectedTowerForUpgrade.id)}
                        disabled={gold < towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost}
                        style={{
                          width: '100%',
                          padding: '10px',
                          fontSize: '12px',
                          fontWeight: 700,
                          fontFamily: 'inherit',
                          background: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost
                            ? `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`
                            : theme.bgDark,
                          border: 'none',
                          borderRadius: '8px',
                          color: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost ? '#fff' : theme.textMuted,
                          cursor: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost ? 'pointer' : 'not-allowed',
                          marginBottom: '8px',
                        }}
                      >
                        UPGRADE
                      </button>
                    </>
                  ) : (
                    <div style={{
                      fontSize: '11px',
                      color: theme.gold,
                      textAlign: 'center',
                      padding: '10px',
                      background: `${theme.gold}15`,
                      borderRadius: '8px',
                      marginBottom: '8px',
                    }}>
                      ‚ú® MAX LEVEL ‚ú®
                    </div>
                  )}

                  <button
                    onClick={() => sellTower(selectedTowerForUpgrade.id)}
                    style={{
                      width: '100%',
                      padding: '10px',
                      fontSize: '12px',
                      fontWeight: 700,
                      fontFamily: 'inherit',
                      background: 'transparent',
                      border: `1px solid ${theme.error}`,
                      borderRadius: '8px',
                      color: theme.error,
                      cursor: 'pointer',
                    }}
                  >
                    SELL (60%)
                  </button>
                </>
              ) : (
                <>
                  <h3 style={{ fontSize: '12px', fontWeight: 800, marginBottom: '12px', color: theme.accent, letterSpacing: '2px' }}>ENEMIES</h3>

                  {Object.values(enemyTypes).slice(0, 6).map(enemy => (
                    <div key={enemy.id} style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: '8px',
                      padding: '6px 8px',
                      marginBottom: '6px',
                      background: theme.bgDark,
                      borderRadius: '8px',
                      border: `1px solid ${theme.border}`,
                    }}>
                      <span style={{ fontSize: '16px' }}>{enemy.emoji}</span>
                      <div>
                        <div style={{ fontSize: '10px', fontWeight: 700, color: enemy.color }}>{enemy.name}</div>
                        <div style={{ fontSize: '9px', color: theme.textMuted }}>
                          HP: {enemy.health} ‚Ä¢ üí∞{enemy.reward}
                        </div>
                      </div>
                    </div>
                  ))}

                  <div style={{ marginTop: '16px' }}>
                    <h3 style={{ fontSize: '12px', fontWeight: 800, marginBottom: '8px', color: theme.accent, letterSpacing: '2px' }}>TIPS</h3>
                    <div style={{ fontSize: '10px', color: theme.textSecondary, lineHeight: 1.5 }}>
                      ‚Ä¢ Create mazes for longer paths<br/>
                      ‚Ä¢ Frost + Damage = deadly combo<br/>
                      ‚Ä¢ Click towers to upgrade<br/>
                      ‚Ä¢ Combos give bonus gold!
                    </div>
                  </div>
                </>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TowerDefenseGame />);
  </script>
</body>
</html>

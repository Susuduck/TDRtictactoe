<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: #0a0a12;
      overflow: hidden;
      height: 100%;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    #root { height: 100%; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
const TowerDefenseGame = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  // Responsive scaling
  const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({ width: window.innerWidth, height: window.innerHeight });
      setIsLandscape(window.innerWidth > window.innerHeight);
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Detect reduced motion preference
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setPrefersReducedMotion(mediaQuery.matches);
    const handler = (e) => setPrefersReducedMotion(e.matches);
    mediaQuery.addEventListener('change', handler);
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  // Calculate responsive cell size with better grid calculation
  const GRID_SIZE = 15;
  // Account for portrait mode - reduce side panel width
  const panelWidth = isLandscape ? 170 : 120;
  const headerHeight = isLandscape ? 180 : 220;
  const maxGridHeight = windowSize.height - headerHeight;
  const maxGridWidth = windowSize.width - (isLandscape ? panelWidth * 2 + 50 : 30);
  const CELL_SIZE = Math.max(20, Math.min(42, Math.floor(Math.min(maxGridHeight, maxGridWidth) / GRID_SIZE) - 2));
  const GRID_OFFSET = 8;

  // Game state
  const [gameState, setGameState] = useState('menu');
  const [grid, setGrid] = useState(() => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)));
  const [towers, setTowers] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [projectiles, setProjectiles] = useState([]);
  const [particles, setParticles] = useState([]);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const [announcements, setAnnouncements] = useState([]);
  const [wave, setWave] = useState(1);
  const [lives, setLives] = useState(20);
  const [gold, setGold] = useState(100);
  const [selectedTower, setSelectedTower] = useState(null);
  const [hoveredCell, setHoveredCell] = useState(null);
  const [path, setPath] = useState([]);
  const [waveInProgress, setWaveInProgress] = useState(false);
  const [enemiesSpawned, setEnemiesSpawned] = useState(0);
  const [totalEnemiesInWave, setTotalEnemiesInWave] = useState(0);
  const [totalScore, setTotalScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [maxCombo, setMaxCombo] = useState(0);
  const [comboTimer, setComboTimer] = useState(0);
  const [screenShake, setScreenShake] = useState({ x: 0, y: 0 });
  const [selectedTowerForUpgrade, setSelectedTowerForUpgrade] = useState(null);
  const [killCount, setKillCount] = useState(0);
  const [waveEnemyList, setWaveEnemyList] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(1);
  const [showHotkeys, setShowHotkeys] = useState(true);
  const [lastDamageTime, setLastDamageTime] = useState(0);
  const [totalDamageDealt, setTotalDamageDealt] = useState(0);
  const [displayGold, setDisplayGold] = useState(100); // Animated gold display
  const [waveCountdown, setWaveCountdown] = useState(0); // Countdown timer between waves
  const [lastWaveEndTime, setLastWaveEndTime] = useState(0); // When last wave ended
  const [deathMarks, setDeathMarks] = useState([]); // Visual marks where enemies died
  const [pathFlowOffset, setPathFlowOffset] = useState(0); // Animated path flow
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);
  const [isLandscape, setIsLandscape] = useState(window.innerWidth > window.innerHeight);
  const [currentFps, setCurrentFps] = useState(60);
  const fpsHistoryRef = useRef([]);

  // Refs
  const spawnTimerRef = useRef(null);
  const enemiesRef = useRef(enemies);
  const towersRef = useRef(towers);
  const pathRef = useRef(path);
  const goldRef = useRef(gold);
  const beamDamageRef = useRef([]); // PERF: Collect beam damage to apply in batch

  useEffect(() => { enemiesRef.current = enemies; }, [enemies]);
  useEffect(() => { towersRef.current = towers; }, [towers]);
  useEffect(() => { pathRef.current = path; }, [path]);
  useEffect(() => { goldRef.current = gold; }, [gold]);

  const theme = {
    bg: '#0a0a12',
    bgPanel: '#14141f',
    bgDark: '#0a0a10',
    bgCell: '#0e0e16',
    accent: '#7c6aed',
    accentBright: '#9d8cff',
    accentGlow: 'rgba(124, 106, 237, 0.6)',
    gold: '#ffd700',
    goldGlow: 'rgba(255, 215, 0, 0.5)',
    error: '#ff4757',
    errorGlow: 'rgba(255, 71, 87, 0.5)',
    success: '#2ed573',
    successGlow: 'rgba(46, 213, 115, 0.5)',
    frost: '#70c9ff',
    fire: '#ff6b35',
    lightning: '#fff200',
    poison: '#a55eea',
    text: '#f0f0ff',
    textSecondary: '#9090b0',
    textMuted: '#505068',
    border: '#252540',
    pathColor: 'rgba(124, 106, 237, 0.25)',
    pathGlow: 'rgba(124, 106, 237, 0.4)',
  };

  // Tower damage types for resistance calculations
  const towerTypes = {
    arrow: {
      id: 'arrow', name: 'Arrow', emoji: 'ðŸ¹', cost: 30, hotkey: '1',
      damage: 12, range: 3.5, fireRate: 700, color: '#2ed573',
      projectileSpeed: 18, projectileSize: 4, critChance: 0.15,
      damageType: 'physical',
      desc: 'Fast â€¢ 15% crit',
      upgrades: [
        { cost: 40, damage: 18, fireRate: 600, name: 'Sharp' },
        { cost: 80, damage: 28, fireRate: 500, critChance: 0.25, name: 'Precise' },
        { cost: 150, damage: 40, fireRate: 400, critChance: 0.35, range: 4, name: 'Master' },
      ]
    },
    cannon: {
      id: 'cannon', name: 'Cannon', emoji: 'ðŸ’£', cost: 60, hotkey: '2',
      damage: 45, range: 2.8, fireRate: 1800, color: '#ff6b35',
      splash: 1.2, projectileSpeed: 10, projectileSize: 8,
      damageType: 'fire',
      desc: 'Splash damage',
      upgrades: [
        { cost: 50, damage: 65, splash: 1.4, name: 'Big' },
        { cost: 100, damage: 90, splash: 1.6, fireRate: 1600, name: 'Heavy' },
        { cost: 180, damage: 130, splash: 2, fireRate: 1400, name: 'Mega' },
      ]
    },
    sniper: {
      id: 'sniper', name: 'Sniper', emoji: 'ðŸŽ¯', cost: 80, hotkey: '3',
      damage: 75, range: 6, fireRate: 2200, color: '#5352ed',
      projectileSpeed: 30, projectileSize: 3,
      damageType: 'physical',
      desc: 'Long range',
      upgrades: [
        { cost: 60, damage: 110, range: 7, name: 'Scope' },
        { cost: 120, damage: 160, name: 'Pierce' },
        { cost: 200, damage: 250, range: 8, fireRate: 1800, name: 'Rail' },
      ]
    },
    frost: {
      id: 'frost', name: 'Frost', emoji: 'â„ï¸', cost: 50, hotkey: '4',
      damage: 8, range: 3, fireRate: 500, color: '#70c9ff',
      slow: 0.4, slowDuration: 2500, projectileSpeed: 14, projectileSize: 6,
      damageType: 'frost',
      desc: 'Slows 40%',
      upgrades: [
        { cost: 45, slow: 0.5, slowDuration: 3000, name: 'Deep' },
        { cost: 90, slow: 0.6, slowDuration: 3500, damage: 15, name: 'Perma' },
        { cost: 160, slow: 0.7, slowDuration: 4000, damage: 25, range: 3.5, name: 'Zero' },
      ]
    },
    lightning: {
      id: 'lightning', name: 'Tesla', emoji: 'âš¡', cost: 100, hotkey: '5',
      damage: 20, range: 3.2, fireRate: 350, color: '#fff200',
      chain: 4, chainDamageDecay: 0.7, projectileSpeed: 50, projectileSize: 2,
      damageType: 'lightning',
      desc: 'Chain Ã—4',
      upgrades: [
        { cost: 70, damage: 30, chain: 5, name: 'Arc' },
        { cost: 140, damage: 45, chain: 6, chainDamageDecay: 0.8, name: 'Over' },
        { cost: 220, damage: 65, chain: 8, fireRate: 280, name: 'Storm' },
      ]
    },
    poison: {
      id: 'poison', name: 'Plague', emoji: 'â˜ ï¸', cost: 70, hotkey: '6',
      damage: 5, range: 2.5, fireRate: 1200, color: '#a55eea',
      poisonDamage: 8, poisonDuration: 4000, splashPoison: 0.8,
      projectileSpeed: 12, projectileSize: 7,
      damageType: 'poison',
      desc: 'DoT + AoE',
      upgrades: [
        { cost: 55, poisonDamage: 14, poisonDuration: 5000, name: 'Viral' },
        { cost: 110, poisonDamage: 22, splashPoison: 1.2, name: 'Plague' },
        { cost: 190, poisonDamage: 35, poisonDuration: 6000, damage: 15, name: 'Blight' },
      ]
    },
    laser: {
      id: 'laser', name: 'Laser', emoji: 'ðŸ”´', cost: 120, hotkey: '7',
      damage: 3, range: 4, fireRate: 50, color: '#ff4757',
      beam: true, projectileSpeed: 999, projectileSize: 3,
      damageType: 'fire',
      desc: 'Continuous',
      upgrades: [
        { cost: 80, damage: 5, range: 4.5, name: 'Focus' },
        { cost: 150, damage: 8, range: 5, name: 'High' },
        { cost: 250, damage: 12, range: 5.5, name: 'Death' },
      ]
    },
  };

  // Enemy resistances: physical (arrow/sniper), fire (cannon), frost, lightning, poison
  // Values: 0 = normal, >0 = resistant (takes less), <0 = weak (takes more)
  const enemyTypes = {
    slime: { id: 'slime', name: 'Slime', emoji: 'ðŸŸ¢', health: 40, speed: 0.9, reward: 6, color: '#2ed573', size: 1,
      resist: { physical: 0, fire: 0, frost: -0.2, lightning: 0.2, poison: 0.3 } },
    scout: { id: 'scout', name: 'Scout', emoji: 'ðŸ”µ', health: 25, speed: 1.8, reward: 8, color: '#5352ed', size: 0.9,
      resist: { physical: -0.2, fire: 0, frost: 0.3, lightning: -0.2, poison: 0 } },
    tank: { id: 'tank', name: 'Golem', emoji: 'ðŸŸ¤', health: 180, speed: 0.45, reward: 18, color: '#cd6133', size: 1.3,
      resist: { physical: 0.4, fire: -0.3, frost: 0.2, lightning: -0.2, poison: 0.5 } },
    swarm: { id: 'swarm', name: 'Bug', emoji: 'ðŸ›', health: 15, speed: 1.4, reward: 4, color: '#7bed9f', size: 0.7,
      resist: { physical: 0, fire: -0.5, frost: 0, lightning: -0.3, poison: -0.2 } },
    healer: { id: 'healer', name: 'Medic', emoji: 'ðŸ’š', health: 60, speed: 0.7, reward: 14, color: '#26de81', size: 1, heals: true,
      resist: { physical: 0, fire: 0, frost: 0, lightning: 0, poison: 0.8 } },
    shielded: { id: 'shielded', name: 'Knight', emoji: 'ðŸ›¡ï¸', health: 100, speed: 0.6, reward: 21, color: '#778ca3', size: 1.1, shield: 50,
      resist: { physical: 0.3, fire: 0, frost: 0, lightning: -0.4, poison: 0 } },
    splitter: { id: 'splitter', name: 'Amoeba', emoji: 'ðŸ«§', health: 80, speed: 0.8, reward: 10, color: '#a55eea', size: 1.1, splits: 2,
      resist: { physical: 0.2, fire: -0.2, frost: 0, lightning: 0, poison: 0.6 } },
    boss: { id: 'boss', name: 'Dragon', emoji: 'ðŸ‰', health: 800, speed: 0.35, reward: 100, color: '#ff4757', size: 1.8, isBoss: true,
      resist: { physical: 0.2, fire: 0.5, frost: -0.3, lightning: 0.1, poison: 0.3 } },
    megaBoss: { id: 'megaBoss', name: 'Titan', emoji: 'ðŸ‘¹', health: 2000, speed: 0.25, reward: 200, color: '#ff0000', size: 2.2, isBoss: true,
      resist: { physical: 0.3, fire: 0.3, frost: 0.3, lightning: 0.3, poison: 0.3 } },
  };

  const START = { row: 0, col: Math.floor(GRID_SIZE / 2) };
  const END = { row: GRID_SIZE - 1, col: Math.floor(GRID_SIZE / 2) };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (gameState !== 'playing') return;

      const key = e.key;
      const towerKeys = { '1': 'arrow', '2': 'cannon', '3': 'sniper', '4': 'frost', '5': 'lightning', '6': 'poison', '7': 'laser' };

      if (towerKeys[key] && goldRef.current >= towerTypes[towerKeys[key]].cost) {
        setSelectedTower(towerKeys[key]);
        setSelectedTowerForUpgrade(null);
      }
      if (key === 'Escape') {
        setSelectedTower(null);
        setSelectedTowerForUpgrade(null);
      }
      if (key === ' ' && !waveInProgress) {
        e.preventDefault();
        startWave();
      }
      if (key === 'u' && selectedTowerForUpgrade) {
        upgradeTower(selectedTowerForUpgrade.id);
      }
      if (key === 's' && selectedTowerForUpgrade) {
        sellTower(selectedTowerForUpgrade.id);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState, waveInProgress, selectedTowerForUpgrade]);

  // Pathfinding
  const findPath = useCallback((gridState) => {
    const queue = [[START.row, START.col]];
    const visited = new Set();
    const parent = new Map();
    visited.add(`${START.row},${START.col}`);
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    while (queue.length > 0) {
      const [row, col] = queue.shift();
      if (row === END.row && col === END.col) {
        const pathResult = [];
        let current = `${END.row},${END.col}`;
        while (current) {
          const [r, c] = current.split(',').map(Number);
          pathResult.unshift({ row: r, col: c });
          current = parent.get(current);
        }
        return pathResult;
      }
      for (const [dr, dc] of directions) {
        const newRow = row + dr;
        const newCol = col + dc;
        const key = `${newRow},${newCol}`;
        if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE &&
            !visited.has(key) && gridState[newRow][newCol] === null) {
          visited.add(key);
          parent.set(key, `${row},${col}`);
          queue.push([newRow, newCol]);
        }
      }
    }
    return null;
  }, []);

  // Spawn particles with performance throttling
  const spawnParticles = useCallback((x, y, color, count = 8, config = {}) => {
    // Reduce particles if reduced motion is preferred or FPS is low
    const avgFps = fpsHistoryRef.current.length > 0
      ? fpsHistoryRef.current.reduce((a, b) => a + b, 0) / fpsHistoryRef.current.length
      : 60;
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const fpsMultiplier = avgFps < 30 ? 0.3 : avgFps < 45 ? 0.6 : 1;
    const actualCount = reducedMotion ? Math.ceil(count * 0.3) : Math.ceil(count * fpsMultiplier);

    const { speed = 3, size = 4, life = 500, spread = Math.PI * 2, direction = 0, gravity = 0 } = config;
    const newParticles = Array(actualCount).fill(null).map(() => {
      const angle = direction + (Math.random() - 0.5) * spread;
      const vel = (0.5 + Math.random() * 0.5) * speed;
      return {
        id: Math.random(),
        x, y,
        vx: Math.cos(angle) * vel,
        vy: Math.sin(angle) * vel,
        size: size * (0.5 + Math.random() * 0.5),
        color,
        life,
        maxLife: life,
        gravity,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
      };
    });
    setParticles(prev => [...prev, ...newParticles]);
  }, []);

  // Spawn floating text with logarithmic size scaling for damage numbers
  const spawnFloatingText = useCallback((x, y, text, color, size = 14, isCrit = false) => {
    // Logarithmic size scaling: big numbers don't get too huge
    // Parse numeric value from text if it starts with + (gold/damage)
    let finalSize = size;
    const numMatch = text.match(/^\+?(\d+)/);
    if (numMatch) {
      const value = parseInt(numMatch[1]);
      // Scale: base size + log2(value) * 2, capped between 10-28
      finalSize = Math.min(28, Math.max(10, size + Math.log2(Math.max(1, value)) * 1.5));
    }
    setFloatingTexts(prev => [...prev, {
      id: Math.random(),
      x, y,
      text,
      color,
      size: finalSize,
      life: 800,
      maxLife: 800,
      isCrit,
      vx: (Math.random() - 0.5) * 1.5,
      vy: -2.5,
    }]);
  }, []);

  // Spawn announcement
  const announce = useCallback((text, color = theme.gold, duration = 2000) => {
    const id = Math.random();
    setAnnouncements(prev => [...prev, { id, text, color, life: duration, maxLife: duration }]);
  }, []);

  // Screen shake
  const triggerShake = useCallback((intensity = 5) => {
    let count = 0;
    const shake = () => {
      if (count++ < 4) {
        setScreenShake({
          x: (Math.random() - 0.5) * intensity * (1 - count * 0.2),
          y: (Math.random() - 0.5) * intensity * (1 - count * 0.2),
        });
        setTimeout(shake, 40);
      } else {
        setScreenShake({ x: 0, y: 0 });
      }
    };
    shake();
  }, []);

  // Tower placement
  const canPlaceTower = useCallback((row, col) => {
    if (grid[row][col] !== null) return false;
    if (row === START.row && col === START.col) return false;
    if (row === END.row && col === END.col) return false;
    const testGrid = grid.map(r => [...r]);
    testGrid[row][col] = 'tower';
    return findPath(testGrid) !== null;
  }, [grid, findPath]);

  // PERF: Pre-compute placeable cells once when grid changes (avoids 225 BFS calls per render)
  const placeableCells = useMemo(() => {
    const placeable = new Set();
    for (let row = 0; row < GRID_SIZE; row++) {
      for (let col = 0; col < GRID_SIZE; col++) {
        if (grid[row][col] !== null) continue;
        if (row === START.row && col === START.col) continue;
        if (row === END.row && col === END.col) continue;
        const testGrid = grid.map(r => [...r]);
        testGrid[row][col] = 'tower';
        if (findPath(testGrid) !== null) {
          placeable.add(`${row},${col}`);
        }
      }
    }
    return placeable;
  }, [grid, findPath]);

  // Fast check using pre-computed cache
  const canPlaceTowerFast = useCallback((row, col) => {
    return placeableCells.has(`${row},${col}`);
  }, [placeableCells]);

  // PERF: Pre-compute path cells Set for O(1) lookup instead of O(n) path.some() per cell
  const pathCellsSet = useMemo(() => {
    const pathSet = new Set();
    for (const p of path) {
      pathSet.add(`${p.row},${p.col}`);
    }
    return pathSet;
  }, [path]);

  // PERF: Pre-compute tower positions Map for O(1) lookup instead of O(n) towers.find() per cell
  const towersByPosition = useMemo(() => {
    const towerMap = new Map();
    for (const tower of towers) {
      towerMap.set(`${tower.row},${tower.col}`, tower);
    }
    return towerMap;
  }, [towers]);

  const placeTower = useCallback((row, col, towerType) => {
    if (!canPlaceTower(row, col)) return false;
    const towerDef = towerTypes[towerType];
    if (gold < towerDef.cost) return false;

    const newTower = {
      id: Date.now(),
      row, col,
      type: towerType,
      ...towerDef,
      lastFired: 0,
      level: 0,
      totalDamage: 0,
      kills: 0,
      xpLevel: 0, // XP from kills, grants +2% damage per level
      targetingMode: 'first', // first, last, strongest, weakest, closest
      rotation: 0, // Tower rotation angle toward target
      beamTarget: null,
      beamDamageAccum: 0,
      pulsePhase: 0,
    };

    setTowers(prev => [...prev, newTower]);
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[row][col] = 'tower';
      return newGrid;
    });
    setGold(prev => prev - towerDef.cost);
    setSelectedTower(null);

    const cx = col * CELL_SIZE + CELL_SIZE / 2;
    const cy = row * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(cx, cy, towerDef.color, 12, { speed: 4, size: 5, life: 400 });

    const newGrid = grid.map(r => [...r]);
    newGrid[row][col] = 'tower';
    setPath(findPath(newGrid) || []);
    return true;
  }, [canPlaceTower, gold, grid, findPath, spawnParticles, CELL_SIZE]);

  const sellTower = useCallback((towerId) => {
    const tower = towers.find(t => t.id === towerId);
    if (!tower) return;

    const baseCost = towerTypes[tower.type].cost;
    const upgradeCost = towerTypes[tower.type].upgrades.slice(0, tower.level).reduce((sum, u) => sum + u.cost, 0);
    const sellValue = Math.floor((baseCost + upgradeCost) * 0.6);

    setTowers(prev => prev.filter(t => t.id !== towerId));
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[tower.row][tower.col] = null;
      return newGrid;
    });
    setGold(prev => prev + sellValue);
    setSelectedTowerForUpgrade(null);

    const cx = tower.col * CELL_SIZE + CELL_SIZE / 2;
    const cy = tower.row * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(cx, cy, theme.gold, 10, { speed: 3, life: 600 });
    spawnFloatingText(cx, cy, `+${sellValue}`, theme.gold, 16);

    const newGrid = grid.map(r => [...r]);
    newGrid[tower.row][tower.col] = null;
    setPath(findPath(newGrid) || []);
  }, [towers, grid, findPath, spawnParticles, spawnFloatingText, CELL_SIZE]);

  const upgradeTower = useCallback((towerId) => {
    setTowers(prev => prev.map(tower => {
      if (tower.id !== towerId) return tower;
      const upgrades = towerTypes[tower.type].upgrades;
      if (tower.level >= upgrades.length) return tower;

      const upgrade = upgrades[tower.level];
      if (gold < upgrade.cost) return tower;

      setGold(g => g - upgrade.cost);

      const cx = tower.col * CELL_SIZE + CELL_SIZE / 2;
      const cy = tower.row * CELL_SIZE + CELL_SIZE / 2;
      spawnParticles(cx, cy, theme.gold, 15, { speed: 5, size: 6, life: 500 });
      announce(`${tower.name} â†’ ${upgrade.name}!`, tower.color, 1500);

      return { ...tower, ...upgrade, level: tower.level + 1 };
    }));
  }, [gold, spawnParticles, announce, CELL_SIZE]);

  // Enemy spawning with Infinitode 2-style exponential scaling
  const spawnEnemy = useCallback((type, pathOffset = 0) => {
    const enemyDef = enemyTypes[type];
    // Exponential health scaling: wave^1.25 (inspired by Infinitode 2's wave^1.27)
    const waveMultiplier = Math.pow(wave, 1.25);
    // Boss-specific scaling: baseHealth * wave * sqrt(wave) for extra challenge
    const bossMultiplier = enemyDef.isBoss ? wave * Math.sqrt(wave) * 0.5 : waveMultiplier;
    const healthMultiplier = enemyDef.isBoss ? bossMultiplier : waveMultiplier;
    // Small random offset to prevent stacking, but keep enemies centered on path
    const offsetX = (Math.random() - 0.5) * CELL_SIZE * 0.2;
    const offsetY = -pathOffset * CELL_SIZE * 0.3; // Stagger spawns slightly above the start
    const newEnemy = {
      id: Date.now() + Math.random(),
      type,
      ...enemyDef,
      health: Math.floor(enemyDef.health * healthMultiplier),
      maxHealth: Math.floor(enemyDef.health * healthMultiplier),
      currentHealth: Math.floor(enemyDef.health * healthMultiplier),
      currentShield: enemyDef.shield ? Math.floor(enemyDef.shield * healthMultiplier) : 0,
      maxShield: enemyDef.shield ? Math.floor(enemyDef.shield * healthMultiplier) : 0,
      pathIndex: 0,
      x: START.col * CELL_SIZE + CELL_SIZE / 2 + offsetX,
      y: START.row * CELL_SIZE + CELL_SIZE / 2 + offsetY,
      slowedUntil: 0,
      slowAmount: 1,
      poisonedUntil: 0,
      poisonDamage: 0,
      animPhase: Math.random() * Math.PI * 2,
      hitFlash: 0,
      rotation: 0,
      lastHealTime: 0,
    };
    setEnemies(prev => [...prev, newEnemy]);
  }, [wave, CELL_SIZE]);

  // Generate wave with escalating composition
  const generateWaveEnemies = useCallback((waveNum) => {
    const enemies = [];
    // Slime count grows slower at higher waves - more specials proportionally
    const slimeCount = Math.floor(6 + waveNum * 1.2);

    for (let i = 0; i < slimeCount; i++) enemies.push('slime');
    // Scouts - fast and numerous
    if (waveNum >= 2) for (let i = 0; i < Math.floor(waveNum * 1.0); i++) enemies.push('scout');
    // Tanks - more at higher waves
    if (waveNum >= 3) for (let i = 0; i < Math.floor(waveNum * 0.6); i++) enemies.push('tank');
    // Swarms - scale aggressively
    if (waveNum >= 4) for (let i = 0; i < Math.floor(waveNum * 1.5); i++) enemies.push('swarm');
    // Healers - every 3rd after wave 5
    if (waveNum >= 5) for (let i = 0; i < Math.floor(waveNum / 3); i++) enemies.push('healer');
    // Shielded - more frequent
    if (waveNum >= 6) for (let i = 0; i < Math.floor(waveNum * 0.4); i++) enemies.push('shielded');
    // Splitters - medium frequency
    if (waveNum >= 7) for (let i = 0; i < Math.floor(waveNum / 3); i++) enemies.push('splitter');
    // Bosses and mega bosses
    if (waveNum % 5 === 0) enemies.push('boss');
    if (waveNum % 10 === 0) enemies.push('megaBoss');
    // Extra boss every 3 waves after wave 15
    if (waveNum > 15 && waveNum % 3 === 0) enemies.push('boss');

    // Shuffle the enemies
    for (let i = enemies.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [enemies[i], enemies[j]] = [enemies[j], enemies[i]];
    }
    return enemies;
  }, []);

  const startWave = useCallback(() => {
    if (waveInProgress) return;
    setWaveInProgress(true);
    setEnemiesSpawned(0);

    // Early start bonus - get gold for remaining countdown time
    if (waveCountdown > 0 && wave > 1) {
      const earlyBonus = Math.floor(waveCountdown / 1000) * 2; // 2 gold per second remaining
      if (earlyBonus > 0) {
        setGold(g => g + earlyBonus);
        announce(`â±ï¸ Early Start! +${earlyBonus}ðŸ’°`, theme.gold, 1500);
      }
    }
    setWaveCountdown(0);

    const waveEnemies = generateWaveEnemies(wave);
    setWaveEnemyList(waveEnemies);
    setTotalEnemiesInWave(waveEnemies.length);

    // Boss warning
    if (wave % 5 === 0) {
      announce(wave % 10 === 0 ? 'âš ï¸ TITAN INCOMING!' : 'âš ï¸ BOSS WAVE!', theme.error, 2500);
      triggerShake(8);
    }

    let spawnIndex = 0;
    // More aggressive spawn rate - faster spawns as waves progress
    const spawnDelay = Math.max(150, 600 - wave * 25);

    spawnTimerRef.current = setInterval(() => {
      if (spawnIndex < waveEnemies.length) {
        spawnEnemy(waveEnemies[spawnIndex], spawnIndex % 3);
        spawnIndex++;
        setEnemiesSpawned(spawnIndex);
      } else {
        clearInterval(spawnTimerRef.current);
      }
    }, spawnDelay);
  }, [wave, waveInProgress, spawnEnemy, generateWaveEnemies, announce, triggerShake]);

  // Main game loop
  useEffect(() => {
    if (gameState !== 'playing') return;

    let animationId;
    let lastTime = performance.now();

    const tick = (currentTime) => {
      const deltaTime = Math.min(currentTime - lastTime, 50) * gameSpeed;
      const actualDelta = currentTime - lastTime;
      lastTime = currentTime;
      const now = Date.now();

      // FPS tracking for performance throttling
      if (actualDelta > 0) {
        const fps = 1000 / actualDelta;
        fpsHistoryRef.current.push(fps);
        if (fpsHistoryRef.current.length > 30) fpsHistoryRef.current.shift();
        const avgFps = fpsHistoryRef.current.reduce((a, b) => a + b, 0) / fpsHistoryRef.current.length;
        setCurrentFps(Math.round(avgFps));
      }

      // Update enemies
      setEnemies(prevEnemies => {
        const newEnemies = [];
        const enemiesToSpawn = [];

        for (const enemy of prevEnemies) {
          // Check if enemy has completed the path
          const pathLength = pathRef.current.length;
          const endX = END.col * CELL_SIZE + CELL_SIZE / 2;
          const endY = END.row * CELL_SIZE + CELL_SIZE / 2;
          const distToEnd = Math.sqrt((enemy.x - endX) ** 2 + (enemy.y - endY) ** 2);

          // Remove enemy if they reached the end (either by pathIndex or by position)
          if (enemy.pathIndex >= pathLength || (pathLength > 0 && enemy.pathIndex >= pathLength - 1 && distToEnd < CELL_SIZE * 0.5)) {
            setLives(l => {
              const damage = enemy.isBoss ? 5 : 1;
              const newLives = l - damage;
              if (newLives <= 0) setGameState('lost');
              return Math.max(0, newLives);
            });
            setLastDamageTime(now);
            triggerShake(12);
            announce(`-${enemy.isBoss ? 5 : 1} â¤ï¸`, theme.error, 1000);
            continue;
          }

          // Poison tick
          if (enemy.poisonedUntil > now && enemy.poisonDamage > 0) {
            const poisonTick = enemy.poisonDamage * deltaTime / 1000;
            enemy.currentHealth -= poisonTick;
            if (Math.random() < 0.08) {
              spawnParticles(enemy.x, enemy.y, theme.poison, 2, { speed: 1, size: 3, life: 300 });
            }
          }

          // Healer - PERF: Use squared distance and early exit
          if (enemy.heals && now - enemy.lastHealTime > 2000) {
            const healRangeSq = (CELL_SIZE * 2) * (CELL_SIZE * 2); // Pre-compute squared range
            for (const other of prevEnemies) {
              if (other.id !== enemy.id) {
                const dx = other.x - enemy.x;
                // PERF: Early exit if X distance alone exceeds range
                if (dx * dx > healRangeSq) continue;
                const dy = other.y - enemy.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < healRangeSq) {
                  other.currentHealth = Math.min(other.maxHealth, other.currentHealth + 10);
                  spawnParticles(other.x, other.y, theme.success, 3, { speed: 2, size: 3, life: 400 });
                }
              }
            }
            enemy.lastHealTime = now;
          }

          // Hit flash decay
          if (enemy.hitFlash > 0) enemy.hitFlash -= deltaTime * 0.01;

          // Death
          if (enemy.currentHealth <= 0) {
            const comboBonus = Math.floor(enemy.reward * combo * 0.1);
            const totalReward = enemy.reward + comboBonus;
            setGold(g => g + totalReward);
            setTotalScore(s => s + totalReward * 10);
            setKillCount(k => k + 1);
            setTotalDamageDealt(d => d + enemy.maxHealth);

            const newCombo = Math.min(combo + 1, 50);
            setCombo(newCombo);
            setMaxCombo(m => Math.max(m, newCombo));
            setComboTimer(3000);

            // Kill streak announcements
            if (newCombo === 5) announce('ðŸ”¥ KILLING SPREE!', '#ff9500', 1500);
            else if (newCombo === 10) announce('âš¡ RAMPAGE!', '#ff6b00', 1500);
            else if (newCombo === 20) announce('ðŸ’€ UNSTOPPABLE!', '#ff0000', 2000);
            else if (newCombo === 50) announce('ðŸ‘‘ GODLIKE!', theme.gold, 3000);

            spawnParticles(enemy.x, enemy.y, enemy.color, 15, { speed: 4, size: 6, life: 600 });

            // Spawn death crater mark
            setDeathMarks(prev => [...prev.slice(-30), { // Keep only last 30 marks
              id: Math.random(),
              x: enemy.x, y: enemy.y,
              color: enemy.color,
              size: enemy.isBoss ? 25 : 12,
              life: enemy.isBoss ? 15000 : 8000, // Boss marks last longer
            }]);

            if (enemy.isBoss) {
              spawnParticles(enemy.x, enemy.y, theme.gold, 25, { speed: 6, size: 8, life: 800 });
              triggerShake(15);
              announce(enemy.type === 'megaBoss' ? 'ðŸ‘¹ TITAN SLAIN!' : 'ðŸ‰ BOSS DEFEATED!', theme.gold, 2500);
            }

            const textColor = comboBonus > 0 ? theme.gold : theme.success;
            spawnFloatingText(enemy.x, enemy.y - 10, `+${totalReward}`, textColor, comboBonus > 0 ? 18 : 14);

            if (enemy.splits) {
              for (let i = 0; i < enemy.splits; i++) {
                enemiesToSpawn.push({
                  type: 'swarm',
                  x: enemy.x + (Math.random() - 0.5) * 20,
                  y: enemy.y + (Math.random() - 0.5) * 20,
                  pathIndex: enemy.pathIndex,
                });
              }
            }
            continue;
          }

          // Movement
          const target = pathRef.current[enemy.pathIndex];
          if (target) {
            const targetX = target.col * CELL_SIZE + CELL_SIZE / 2;
            const targetY = target.row * CELL_SIZE + CELL_SIZE / 2;
            const dx = targetX - enemy.x;
            const dy = targetY - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            let speed = enemy.speed * (deltaTime / 16);
            if (enemy.slowedUntil > now) speed *= enemy.slowAmount;

            enemy.rotation = Math.atan2(dy, dx);

            // Use a reasonable threshold based on cell size for path advancement
            const advanceThreshold = Math.max(speed * 2, CELL_SIZE * 0.15);
            if (dist < advanceThreshold) {
              enemy.pathIndex++;
              // Snap to center when advancing to prevent drift
              enemy.x = targetX;
              enemy.y = targetY;
            } else {
              enemy.x += (dx / dist) * speed * 2;
              enemy.y += (dy / dist) * speed * 2;
            }
          }

          enemy.animPhase += deltaTime * 0.008;
          newEnemies.push(enemy);
        }

        // Spawn split enemies
        for (const spawn of enemiesToSpawn) {
          const enemyDef = enemyTypes[spawn.type];
          newEnemies.push({
            id: Date.now() + Math.random(),
            type: spawn.type,
            ...enemyDef,
            health: enemyDef.health,
            maxHealth: enemyDef.health,
            currentHealth: enemyDef.health,
            currentShield: 0,
            maxShield: 0,
            pathIndex: spawn.pathIndex,
            x: spawn.x,
            y: spawn.y,
            slowedUntil: 0,
            slowAmount: 1,
            poisonedUntil: 0,
            poisonDamage: 0,
            animPhase: Math.random() * Math.PI * 2,
            hitFlash: 0,
            rotation: 0,
            lastHealTime: 0,
          });
        }

        return newEnemies;
      });

      // Update towers
      setTowers(prevTowers => {
        return prevTowers.map(tower => {
          const towerX = tower.col * CELL_SIZE + CELL_SIZE / 2;
          const towerY = tower.row * CELL_SIZE + CELL_SIZE / 2;
          tower.pulsePhase = (tower.pulsePhase || 0) + deltaTime * 0.005;

          // Beam tower - PERF: Use squared distance to avoid sqrt
          if (tower.beam) {
            let target = null;
            let minDistSq = Infinity;
            const rangeSq = (tower.range * CELL_SIZE) * (tower.range * CELL_SIZE);

            for (const enemy of enemiesRef.current) {
              const dx = enemy.x - towerX;
              const dy = enemy.y - towerY;
              const distSq = dx * dx + dy * dy;
              if (distSq <= rangeSq && distSq < minDistSq) {
                target = enemy;
                minDistSq = distSq;
              }
            }

            if (target) {
              tower.beamTarget = { x: target.x, y: target.y, id: target.id };
              tower.beamDamageAccum += tower.damage * deltaTime / 16;

              if (tower.beamDamageAccum >= 1) {
                const damage = Math.floor(tower.beamDamageAccum);
                tower.beamDamageAccum -= damage;

                // PERF: Collect beam damage to apply in batch instead of calling setEnemies per tower
                beamDamageRef.current.push({
                  targetId: target.id,
                  damage,
                  damageType: tower.damageType,
                  towerId: tower.id,
                });
              }

              if (Math.random() < 0.2) {
                spawnParticles(target.x, target.y, tower.color, 1, { speed: 1, size: 3, life: 200 });
              }
            } else {
              tower.beamTarget = null;
            }
            return tower;
          }

          // Regular tower
          if (now - tower.lastFired < tower.fireRate) return tower;

          // Calculate XP level from kills: every 10 kills = 1 level (capped at level 10)
          const xpLevel = Math.min(10, Math.floor(tower.kills / 10));
          tower.xpLevel = xpLevel;

          // Targeting mode logic - PERF: Use squared distance for range check
          let target = null;
          let bestValue = tower.targetingMode === 'first' || tower.targetingMode === 'strongest' ? -Infinity : Infinity;
          const enemiesInRange = [];
          const rangeSq = (tower.range * CELL_SIZE) * (tower.range * CELL_SIZE);

          for (const enemy of enemiesRef.current) {
            const dx = enemy.x - towerX;
            const dy = enemy.y - towerY;
            const distSq = dx * dx + dy * dy;
            if (distSq <= rangeSq) {
              // Only compute sqrt for 'closest' mode, otherwise store squared
              const dist = tower.targetingMode === 'closest' ? Math.sqrt(distSq) : distSq;
              enemiesInRange.push({ enemy, dist, distSq });
            }
          }

          let targetDistSq = 0;
          for (const { enemy, dist, distSq } of enemiesInRange) {
            let value;
            let selected = false;
            switch (tower.targetingMode) {
              case 'first': value = enemy.pathIndex; if (value > bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'last': value = enemy.pathIndex; if (value < bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'strongest': value = enemy.currentHealth; if (value > bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'weakest': value = enemy.currentHealth; if (value < bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'closest': if (dist < bestValue) { bestValue = dist; target = enemy; selected = true; } break;
              default: value = enemy.pathIndex; if (value > bestValue) { bestValue = value; target = enemy; selected = true; }
            }
            if (selected) targetDistSq = distSq;
          }

          // Update tower rotation toward target
          if (target) {
            const targetAngle = Math.atan2(target.y - towerY, target.x - towerX);
            tower.rotation = targetAngle;
          }

          if (target) {
            const isCrit = tower.critChance && Math.random() < tower.critChance;
            // Apply XP bonus: +2% damage per XP level
            const xpBonus = 1 + (xpLevel * 0.02);
            const baseDamage = isCrit ? tower.damage * 2 : tower.damage;
            const damage = Math.floor(baseDamage * xpBonus);

            // Predictive targeting: lead the target based on speed
            // PERF: Use cached squared distance, compute sqrt only when needed
            const dist = Math.sqrt(targetDistSq);
            const projectileSpeed = tower.projectileSpeed || 15;
            const timeToTarget = dist / (projectileSpeed * 2); // Approximate time in frames

            // Calculate target's movement direction from current path
            const targetPath = pathRef.current[target.pathIndex];
            let predictedX = target.x;
            let predictedY = target.y;
            if (targetPath) {
              const pathTargetX = targetPath.col * CELL_SIZE + CELL_SIZE / 2;
              const pathTargetY = targetPath.row * CELL_SIZE + CELL_SIZE / 2;
              const moveDir = Math.atan2(pathTargetY - target.y, pathTargetX - target.x);
              const effectiveSpeed = target.speed * (target.slowedUntil > now ? target.slowAmount : 1);
              predictedX = target.x + Math.cos(moveDir) * effectiveSpeed * timeToTarget * 2;
              predictedY = target.y + Math.sin(moveDir) * effectiveSpeed * timeToTarget * 2;
            }

            // Check if this is an arcing projectile (cannon)
            const isArcing = tower.splash && tower.projectileSpeed <= 12;

            setProjectiles(p => [...p, {
              id: Date.now() + Math.random(),
              fromX: towerX,
              fromY: towerY,
              toX: predictedX,
              toY: predictedY,
              targetId: target.id,
              damage,
              damageType: tower.damageType || 'physical',
              color: tower.color,
              splash: tower.splash,
              slow: tower.slow,
              slowDuration: tower.slowDuration,
              chain: tower.chain,
              chainDamageDecay: tower.chainDamageDecay || 0.7,
              chainedEnemies: [],
              poisonDamage: tower.poisonDamage,
              poisonDuration: tower.poisonDuration,
              splashPoison: tower.splashPoison,
              progress: 0,
              speed: tower.projectileSpeed || 15,
              size: tower.projectileSize || 5,
              isCrit,
              trail: [],
              towerId: tower.id,
              arcing: isArcing, // Enable arcing for cannon
              arcHeight: isArcing ? Math.min(50, dist * 0.3) : 0, // Arc height based on distance
            }]);

            const angle = Math.atan2(target.y - towerY, target.x - towerX);
            spawnParticles(towerX, towerY, tower.color, 3, { speed: 3, size: 3, life: 120, spread: 0.5, direction: angle });

            return { ...tower, lastFired: now };
          }

          return tower;
        });
      });

      // PERF: Apply batched beam damage in single setEnemies call
      if (beamDamageRef.current.length > 0) {
        const pendingDamage = beamDamageRef.current;
        beamDamageRef.current = [];

        setEnemies(enemies => enemies.map(e => {
          const damageEntry = pendingDamage.find(d => d.targetId === e.id);
          if (damageEntry) {
            const beamResist = e.resist?.[damageEntry.damageType] || 0;
            const resistedDamage = Math.floor(damageEntry.damage * (1 - beamResist));
            const newHealth = e.currentHealth - resistedDamage;
            // Update tower stats via ref (towers already updated in this tick)
            const tower = towersRef.current.find(t => t.id === damageEntry.towerId);
            if (tower && newHealth <= 0) {
              tower.kills++;
              tower.totalDamage += resistedDamage;
            }
            return { ...e, currentHealth: newHealth, hitFlash: 1 };
          }
          return e;
        }));
      }

      // Update projectiles
      setProjectiles(prevProjectiles => {
        const newProjectiles = [];

        for (const proj of prevProjectiles) {
          proj.trail.push({ x: proj.fromX + (proj.toX - proj.fromX) * proj.progress, y: proj.fromY + (proj.toY - proj.fromY) * proj.progress });
          if (proj.trail.length > 6) proj.trail.shift();

          proj.progress += (proj.speed / 100) * (deltaTime / 16);

          if (proj.progress >= 1) {
            setEnemies(enemies => {
              return enemies.map(enemy => {
                if (proj.chainedEnemies.includes(enemy.id)) return enemy;

                if (enemy.id === proj.targetId) {
                  // Apply resistance: positive = takes less damage, negative = takes more
                  const resistance = enemy.resist?.[proj.damageType] || 0;
                  const resistMult = 1 - resistance; // 0.3 resist = 0.7x damage, -0.3 weakness = 1.3x
                  let remainingDamage = Math.floor(proj.damage * resistMult);
                  if (enemy.currentShield > 0) {
                    const shieldDamage = Math.min(enemy.currentShield, remainingDamage);
                    enemy.currentShield -= shieldDamage;
                    remainingDamage -= shieldDamage;
                    spawnParticles(enemy.x, enemy.y, '#778ca3', 5, { speed: 3, size: 4, life: 300 });
                  }

                  const newHealth = enemy.currentHealth - remainingDamage;
                  enemy.hitFlash = 1;

                  if (proj.slow) {
                    enemy.slowedUntil = now + proj.slowDuration;
                    // Diminishing returns for slows: 1 - (1-current)*(1-new), capped at 70%
                    const currentSlow = enemy.slowAmount || 0;
                    const newSlow = 1 - (1 - currentSlow) * (1 - proj.slow);
                    enemy.slowAmount = Math.min(0.7, newSlow); // 70% max slow cap
                  }
                  if (proj.poisonDamage) {
                    enemy.poisonedUntil = now + proj.poisonDuration;
                    // Poison damage cap at 3% of max HP per second
                    const maxPoisonDPS = enemy.maxHealth * 0.03;
                    enemy.poisonDamage = Math.min(proj.poisonDamage, maxPoisonDPS);
                  }

                  spawnParticles(enemy.x, enemy.y, proj.color, 5, { speed: 3, size: 4, life: 300 });

                  if (proj.isCrit) {
                    spawnFloatingText(enemy.x, enemy.y - 15, 'CRIT!', '#ff0', 16, true);
                  }

                  setTowers(towers => towers.map(t => {
                    if (t.id === proj.towerId) {
                      return { ...t, totalDamage: t.totalDamage + proj.damage, kills: newHealth <= 0 ? t.kills + 1 : t.kills };
                    }
                    return t;
                  }));

                  return { ...enemy, currentHealth: newHealth };
                }

                if (proj.splash) {
                  const dx = enemy.x - proj.toX;
                  const dy = enemy.y - proj.toY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist <= proj.splash * CELL_SIZE) {
                    // Apply resistance to splash damage too
                    const splashResist = enemy.resist?.[proj.damageType] || 0;
                    const splashDamage = Math.floor(proj.damage * 0.5 * (1 - splashResist));
                    const newHealth = enemy.currentHealth - splashDamage;
                    enemy.hitFlash = 0.5;

                    if (proj.splashPoison) {
                      enemy.poisonedUntil = now + (proj.poisonDuration || 3000);
                      enemy.poisonDamage = proj.poisonDamage * 0.5;
                    }

                    spawnParticles(enemy.x, enemy.y, proj.color, 2, { speed: 2, size: 3, life: 200 });
                    return { ...enemy, currentHealth: newHealth };
                  }
                }

                return enemy;
              }).filter(Boolean);
            });

            if (proj.splash) {
              spawnParticles(proj.toX, proj.toY, proj.color, 15, { speed: 6, size: 7, life: 500 });
              spawnParticles(proj.toX, proj.toY, '#fff', 8, { speed: 4, size: 4, life: 350 });
              // Damage-based screenshake: scale from 2-8 based on damage
              const shakeIntensity = Math.min(8, 2 + Math.log2(proj.damage) * 0.8);
              triggerShake(shakeIntensity);
              // Spawn explosion shockwave particle
              setParticles(prev => [...prev, {
                id: Math.random(),
                x: proj.toX, y: proj.toY,
                vx: 0, vy: 0,
                size: proj.splash * CELL_SIZE * 0.5,
                color: proj.color,
                life: 300,
                maxLife: 300,
                gravity: 0,
                rotation: 0,
                rotationSpeed: 0,
                isShockwave: true, // Special rendering flag
              }]);
            }

            // Chain lightning
            if (proj.chain && proj.chain > 0) {
              let lastX = proj.toX;
              let lastY = proj.toY;
              const chainedIds = [proj.targetId];

              for (let i = 0; i < proj.chain; i++) {
                let nearestEnemy = null;
                let nearestDist = CELL_SIZE * 3;

                for (const enemy of enemiesRef.current) {
                  if (chainedIds.includes(enemy.id)) continue;
                  const dx = enemy.x - lastX;
                  const dy = enemy.y - lastY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                  }
                }

                if (nearestEnemy) {
                  chainedIds.push(nearestEnemy.id);
                  const chainDamage = proj.damage * Math.pow(proj.chainDamageDecay, i + 1);

                  setProjectiles(p => [...p, {
                    id: Date.now() + Math.random(),
                    fromX: lastX,
                    fromY: lastY,
                    toX: nearestEnemy.x,
                    toY: nearestEnemy.y,
                    targetId: nearestEnemy.id,
                    damage: chainDamage,
                    color: proj.color,
                    progress: 0,
                    speed: 50,
                    size: 3,
                    chain: 0,
                    chainedEnemies: chainedIds,
                    trail: [],
                    isChain: true,
                    towerId: proj.towerId,
                  }]);

                  lastX = nearestEnemy.x;
                  lastY = nearestEnemy.y;
                }
              }
            }
            continue;
          }
          newProjectiles.push(proj);
        }
        return newProjectiles;
      });

      // Update particles
      setParticles(prev => prev.map(p => ({
        ...p,
        x: p.x + p.vx * (deltaTime / 16),
        y: p.y + p.vy * (deltaTime / 16) + p.gravity * (deltaTime / 16),
        vy: p.vy + p.gravity * 0.1,
        life: p.life - deltaTime,
        rotation: p.rotation + p.rotationSpeed,
      })).filter(p => p.life > 0));

      // Update floating texts
      setFloatingTexts(prev => prev.map(t => ({
        ...t,
        x: t.x + t.vx * (deltaTime / 16),
        y: t.y + t.vy * (deltaTime / 16),
        vy: t.vy - 0.03,
        life: t.life - deltaTime,
      })).filter(t => t.life > 0));

      // Update announcements
      setAnnouncements(prev => prev.map(a => ({ ...a, life: a.life - deltaTime })).filter(a => a.life > 0));

      // Combo decay
      setComboTimer(prev => {
        const newTimer = prev - deltaTime;
        if (newTimer <= 0) {
          setCombo(0);
          return 0;
        }
        return newTimer;
      });

      // Animated gold counter - smoothly interpolate toward actual gold
      setDisplayGold(prev => {
        const diff = goldRef.current - prev;
        if (Math.abs(diff) < 1) return goldRef.current;
        return prev + diff * 0.15; // Smooth interpolation
      });

      // Wave countdown timer (shows time until early start bonus expires)
      if (!waveInProgress && waveCountdown > 0) {
        setWaveCountdown(prev => Math.max(0, prev - deltaTime));
      }

      // Death marks decay
      setDeathMarks(prev => prev.map(m => ({ ...m, life: m.life - deltaTime })).filter(m => m.life > 0));

      // Animated path flow
      setPathFlowOffset(prev => (prev + deltaTime * 0.02) % 1);

      // Wave complete
      if (waveInProgress && enemiesRef.current.length === 0 && enemiesSpawned >= totalEnemiesInWave && totalEnemiesInWave > 0) {
        setWaveInProgress(false);
        setLastWaveEndTime(now);
        setWaveCountdown(10000); // 10 second countdown for early start bonus
        const waveBonus = 30 + wave * 10;
        setGold(g => g + waveBonus);
        announce(`Wave ${wave} Complete! +${waveBonus}ðŸ’°`, theme.success, 2000);
        setWave(w => w + 1);
      }

      animationId = requestAnimationFrame(tick);
    };

    animationId = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(animationId);
  }, [gameState, gameSpeed, waveInProgress, enemiesSpawned, totalEnemiesInWave, wave, triggerShake, spawnParticles, spawnFloatingText, announce, CELL_SIZE]);

  useEffect(() => {
    setPath(findPath(grid) || []);
  }, []);

  const startGame = () => {
    const emptyGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    setGrid(emptyGrid);
    setTowers([]);
    setEnemies([]);
    setProjectiles([]);
    setParticles([]);
    setFloatingTexts([]);
    setAnnouncements([]);
    setWave(1);
    setLives(20);
    setGold(100);
    setWaveInProgress(false);
    setEnemiesSpawned(0);
    setTotalEnemiesInWave(0);
    setTotalScore(0);
    setCombo(0);
    setMaxCombo(0);
    setComboTimer(0);
    setKillCount(0);
    setTotalDamageDealt(0);
    setSelectedTowerForUpgrade(null);
    setPath(findPath(emptyGrid) || []);
    setGameState('playing');
  };

  const gridWidth = GRID_SIZE * CELL_SIZE + GRID_OFFSET * 2 + 4;
  const gridHeight = GRID_SIZE * CELL_SIZE + GRID_OFFSET * 2 + 4;

  // Wave preview
  const wavePreview = useMemo(() => {
    if (waveInProgress) return null;
    const enemies = generateWaveEnemies(wave);
    const counts = {};
    enemies.forEach(e => { counts[e] = (counts[e] || 0) + 1; });
    return counts;
  }, [wave, waveInProgress, generateWaveEnemies]);

  const styles = `
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');

    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.03); } }
    @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.4); } }
    @keyframes slideIn { 0% { transform: translateY(20px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes slideDown { 0% { transform: translateY(-30px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
    @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    @keyframes rainbow { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }
    @keyframes shimmer { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
    @keyframes towerPulse { 0%, 100% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.05); filter: brightness(1.1); } }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    * { box-sizing: border-box; font-family: 'Inter', -apple-system, sans-serif; }

    /* Scalable font sizes using clamp() */
    :root {
      --font-xs: clamp(8px, 1.5vw, 10px);
      --font-sm: clamp(10px, 2vw, 12px);
      --font-md: clamp(12px, 2.5vw, 14px);
      --font-lg: clamp(14px, 3vw, 18px);
      --font-xl: clamp(18px, 4vw, 24px);
    }

    .btn {
      cursor: pointer;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-user-select: none;
      min-height: 44px; /* Touch-friendly minimum */
      min-width: 44px;
    }
    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(0) scale(0.98); }

    .tower-card {
      transition: all 0.15s ease;
      cursor: pointer;
      min-height: 44px; /* Touch-friendly minimum */
    }
    .tower-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .tower-card:active { transform: translateY(0) scale(0.98); }

    .cell { transition: all 0.1s ease; }
    .cell:hover { filter: brightness(1.2); }

    /* Touch device improvements */
    @media (hover: none) and (pointer: coarse) {
      .btn:hover, .tower-card:hover, .cell:hover { transform: none; }
    }
  `;

  // PERF: Cache current time for render to avoid multiple Date.now() calls
  const renderTime = Date.now();

  return (
    <div style={{
      width: '100%',
      height: '100%',
      minHeight: '100vh',
      background: `radial-gradient(ellipse at 50% 30%, #181828 0%, #0a0a12 70%)`,
      color: theme.text,
      position: 'relative',
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
    }}>
      <style>{styles}</style>

      {/* Background pattern */}
      <div style={{
        position: 'fixed',
        inset: 0,
        backgroundImage: `linear-gradient(rgba(124,106,237,0.02) 1px, transparent 1px),
                          linear-gradient(90deg, rgba(124,106,237,0.02) 1px, transparent 1px)`,
        backgroundSize: '40px 40px',
        pointerEvents: 'none',
      }} />

      <div style={{
        position: 'relative',
        zIndex: 5,
        flex: 1,
        display: 'flex',
        flexDirection: 'column',
        padding: '12px',
        transform: `translate(${screenShake.x}px, ${screenShake.y}px)`,
      }}>

        {/* MENU */}
        {gameState === 'menu' && (
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', flex: 1 }}>
            <div style={{ textAlign: 'center', animation: 'slideIn 0.5s ease-out' }}>
              <div style={{ marginBottom: '24px', animation: 'float 3s ease-in-out infinite' }}>
                <div style={{
                  width: 100, height: 100,
                  background: `linear-gradient(135deg, ${theme.accent}30 0%, ${theme.accent}10 100%)`,
                  borderRadius: '24px',
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  fontSize: 50,
                  boxShadow: `0 0 40px ${theme.accentGlow}`,
                  border: `2px solid ${theme.accent}`,
                  margin: '0 auto',
                }}>ðŸ°</div>
              </div>
              <h1 style={{
                fontSize: 'clamp(28px, 5vw, 42px)',
                fontWeight: 900,
                marginBottom: '8px',
                background: `linear-gradient(135deg, ${theme.gold} 0%, ${theme.accentBright} 100%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
              }}>TOWER DEFENSE</h1>
              <p style={{ fontSize: '14px', color: theme.textSecondary, marginBottom: '32px' }}>
                Build towers â€¢ Create mazes â€¢ Survive
              </p>
              <button
                onClick={startGame}
                className="btn"
                style={{
                  padding: '14px 48px',
                  fontSize: '16px',
                  fontWeight: 700,
                  background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                  border: 'none',
                  borderRadius: '12px',
                  color: '#fff',
                  boxShadow: `0 4px 20px ${theme.accentGlow}`,
                }}
              >
                START GAME
              </button>
              <div style={{ marginTop: '24px', fontSize: '12px', color: theme.textMuted }}>
                Press 1-7 to select towers â€¢ Space to start wave
              </div>
            </div>
          </div>
        )}

        {/* PLAYING */}
        {(gameState === 'playing' || gameState === 'lost') && (
          <div style={{
            display: 'flex',
            flexDirection: isLandscape ? 'row' : 'column',
            gap: '12px',
            justifyContent: 'center',
            alignItems: isLandscape ? 'flex-start' : 'center',
            flex: 1,
            overflow: isLandscape ? 'visible' : 'auto',
          }}>

            {/* Left Panel - Hidden in portrait, shown as bottom bar */}
            {isLandscape && <div style={{
              background: theme.bgPanel,
              borderRadius: '12px',
              padding: '12px',
              border: `1px solid ${theme.border}`,
              width: `${panelWidth}px`,
              flexShrink: 0,
            }}>
              <div style={{ fontSize: '10px', fontWeight: 700, color: theme.gold, letterSpacing: '1px', marginBottom: '10px' }}>
                TOWERS
              </div>

              {Object.values(towerTypes).map((tower, idx) => {
                const canAfford = gold >= tower.cost;
                const isSelected = selectedTower === tower.id;

                return (
                  <div
                    key={tower.id}
                    onClick={() => canAfford && (setSelectedTower(tower.id), setSelectedTowerForUpgrade(null))}
                    className="tower-card"
                    style={{
                      background: isSelected ? `${tower.color}20` : theme.bgDark,
                      borderRadius: '8px',
                      padding: '8px 10px',
                      marginBottom: '6px',
                      opacity: canAfford ? 1 : 0.4,
                      border: isSelected ? `2px solid ${tower.color}` : `1px solid ${theme.border}`,
                      cursor: canAfford ? 'pointer' : 'not-allowed',
                    }}
                  >
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <span style={{ fontSize: '18px' }}>{tower.emoji}</span>
                      <div style={{ flex: 1, minWidth: 0 }}>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <span style={{ fontSize: '11px', fontWeight: 700, color: tower.color }}>{tower.name}</span>
                          {showHotkeys && <span style={{ fontSize: '9px', color: theme.textMuted, background: theme.bgDark, padding: '1px 4px', borderRadius: '3px' }}>{tower.hotkey}</span>}
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: '2px' }}>
                          <span style={{ fontSize: '9px', color: theme.textMuted }}>{tower.desc}</span>
                          <span style={{ fontSize: '10px', color: theme.gold, fontWeight: 600 }}>{tower.cost}ðŸ’°</span>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}

              <div style={{ marginTop: '10px', padding: '8px', background: theme.bgDark, borderRadius: '8px', fontSize: '9px', color: theme.textMuted }}>
                <div style={{ fontWeight: 600, color: theme.textSecondary, marginBottom: '4px' }}>Controls</div>
                <div>1-7: Select tower</div>
                <div>U: Upgrade â€¢ S: Sell</div>
                <div>Space: Start wave</div>
                <div>Esc: Deselect</div>
              </div>
            </div>}

            {/* Center - Game */}
            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              {/* Top bar */}
              <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '8px',
                padding: '8px 12px',
                background: theme.bgPanel,
                borderRadius: '10px',
                border: `1px solid ${theme.border}`,
                width: gridWidth,
              }}>
                <div style={{ display: 'flex', gap: '16px' }}>
                  {[
                    { label: 'WAVE', value: wave, color: theme.accent },
                    { label: 'LIVES', value: `â¤ï¸${lives}`, color: lives <= 5 ? theme.error : theme.success, blink: lives <= 5 },
                    {
                      label: 'GOLD',
                      value: `ðŸ’°${Math.floor(displayGold)}`,
                      color: displayGold > gold ? theme.error : displayGold < gold ? theme.success : theme.gold,
                      glow: Math.abs(gold - displayGold) > 5
                    },
                  ].map((stat, i) => (
                    <div key={i} style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted, letterSpacing: '0.5px' }}>{stat.label}</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: stat.color,
                        animation: stat.blink ? 'pulse 0.5s ease-in-out infinite' : 'none',
                        textShadow: stat.glow ? `0 0 10px ${stat.color}` : 'none',
                        transition: 'color 0.2s ease',
                      }}>{stat.value}</div>
                    </div>
                  ))}
                  {/* Wave countdown timer */}
                  {!waveInProgress && waveCountdown > 0 && (
                    <div style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted }}>BONUS</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: theme.gold,
                        animation: 'pulse 1s ease-in-out infinite',
                      }}>â±ï¸{Math.ceil(waveCountdown / 1000)}s</div>
                    </div>
                  )}
                  {combo > 0 && (
                    <div style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted }}>COMBO</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: combo >= 20 ? theme.gold : combo >= 10 ? '#ff6b00' : theme.accent,
                        animation: combo >= 20 ? 'rainbow 2s linear infinite' : 'none',
                      }}>ðŸ”¥{combo}</div>
                    </div>
                  )}
                </div>

                <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
                  <button
                    onClick={() => setGameSpeed(s => s === 1 ? 2 : s === 2 ? 3 : 1)}
                    className="btn"
                    style={{
                      padding: '6px 12px',
                      fontSize: '11px',
                      fontWeight: 700,
                      background: theme.bgDark,
                      border: `1px solid ${theme.border}`,
                      borderRadius: '6px',
                      color: theme.textSecondary,
                    }}
                  >{gameSpeed}Ã—</button>
                  <button
                    onClick={startWave}
                    disabled={waveInProgress}
                    className="btn"
                    style={{
                      padding: '8px 16px',
                      fontSize: '12px',
                      fontWeight: 700,
                      background: waveInProgress ? theme.bgDark : `linear-gradient(135deg, ${theme.success} 0%, #1fab54 100%)`,
                      border: 'none',
                      borderRadius: '8px',
                      color: waveInProgress ? theme.textMuted : '#fff',
                      cursor: waveInProgress ? 'not-allowed' : 'pointer',
                      boxShadow: waveInProgress ? 'none' : `0 4px 12px ${theme.successGlow}`,
                    }}
                  >
                    {waveInProgress ? `${enemiesSpawned}/${totalEnemiesInWave}` : `â–¶ WAVE ${wave}`}
                  </button>
                </div>
              </div>

              {/* Wave progress */}
              {waveInProgress && (
                <div style={{
                  width: gridWidth,
                  height: '3px',
                  background: theme.bgDark,
                  borderRadius: '2px',
                  marginBottom: '8px',
                  overflow: 'hidden',
                }}>
                  <div style={{
                    width: `${(enemiesSpawned / totalEnemiesInWave) * 100}%`,
                    height: '100%',
                    background: `linear-gradient(90deg, ${theme.accent} 0%, ${theme.success} 100%)`,
                    transition: 'width 0.2s ease',
                  }} />
                </div>
              )}

              {/* Grid */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`,
                gap: '2px',
                background: `linear-gradient(145deg, ${theme.bgDark} 0%, #080810 100%)`,
                padding: `${GRID_OFFSET}px`,
                borderRadius: '16px',
                border: `2px solid ${theme.border}`,
                position: 'relative',
                boxShadow: `0 8px 32px rgba(0,0,0,0.5), 0 0 60px ${theme.accent}08, inset 0 0 60px rgba(0,0,0,0.3)`,
              }}>
                {grid.map((row, rowIdx) => row.map((cell, colIdx) => {
                  const isStart = rowIdx === START.row && colIdx === START.col;
                  const isEnd = rowIdx === END.row && colIdx === END.col;
                  const cellKey = `${rowIdx},${colIdx}`;
                  const isPath = pathCellsSet.has(cellKey);
                  const isHovered = hoveredCell?.row === rowIdx && hoveredCell?.col === colIdx;
                  const tower = towersByPosition.get(cellKey);
                  const canPlace = selectedTower && canPlaceTowerFast(rowIdx, colIdx) && gold >= towerTypes[selectedTower].cost;
                  const isSelected = tower && selectedTowerForUpgrade?.id === tower.id;

                  return (
                    <div
                      key={`${rowIdx}-${colIdx}`}
                      className="cell"
                      onClick={() => {
                        if (selectedTower && canPlace) placeTower(rowIdx, colIdx, selectedTower);
                        else if (tower && !selectedTower) setSelectedTowerForUpgrade(isSelected ? null : tower);
                      }}
                      onContextMenu={(e) => { e.preventDefault(); if (tower) sellTower(tower.id); }}
                      onMouseEnter={() => setHoveredCell({ row: rowIdx, col: colIdx })}
                      onMouseLeave={() => setHoveredCell(null)}
                      onTouchStart={() => setHoveredCell({ row: rowIdx, col: colIdx })}
                      style={{
                        width: CELL_SIZE,
                        height: CELL_SIZE,
                        background: isStart ? `radial-gradient(circle, ${theme.success}50 0%, ${theme.success}20 70%)`
                          : isEnd ? `radial-gradient(circle, ${theme.error}50 0%, ${theme.error}20 70%)`
                          : tower ? `radial-gradient(circle, ${tower.color}35 0%, ${tower.color}15 70%)`
                          : isHovered && canPlace ? `${towerTypes[selectedTower].color}30`
                          : isHovered && selectedTower && !canPlace ? `${theme.error}30`
                          : isPath ? `linear-gradient(135deg, ${theme.pathColor} 0%, ${theme.pathGlow} 100%)`
                          : theme.bgCell,
                        borderRadius: '6px',
                        boxShadow: isPath ? `inset 0 0 ${CELL_SIZE * 0.4}px ${theme.accent}15` : 'none',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        cursor: canPlace ? 'crosshair'
                          : tower ? 'pointer'
                          : selectedTower && !canPlace ? 'not-allowed'
                          : 'default',
                        position: 'relative',
                        border: isSelected ? `2px solid ${tower.color}` : isPath ? `1px solid ${theme.accent}20` : 'none',
                        boxShadow: tower ? `inset 0 0 ${CELL_SIZE/3}px ${tower.color}30, 0 0 8px ${tower.color}20` : 'none',
                      }}
                    >
                      {isStart && <span style={{ fontSize: CELL_SIZE * 0.55, filter: `drop-shadow(0 0 6px ${theme.success})`, animation: 'pulse 2s ease-in-out infinite' }}>ðŸšª</span>}
                      {isEnd && <span style={{ fontSize: CELL_SIZE * 0.55, filter: `drop-shadow(0 0 6px ${theme.error})`, animation: 'pulse 2s ease-in-out infinite' }}>ðŸ </span>}
                      {tower && (
                        <span style={{
                          fontSize: CELL_SIZE * 0.55,
                          filter: `drop-shadow(0 0 4px ${tower.color})`,
                          animation: tower.beamTarget ? 'glow 0.3s ease-in-out infinite' : 'none',
                        }}>{tower.emoji}</span>
                      )}
                      {tower && tower.level > 0 && (
                        <div style={{
                          position: 'absolute',
                          bottom: '1px',
                          right: '2px',
                          fontSize: '8px',
                          fontWeight: 900,
                          color: theme.gold,
                        }}>â˜…{tower.level}</div>
                      )}
                      {isHovered && canPlace && !tower && (
                        <span style={{ fontSize: CELL_SIZE * 0.5, opacity: 0.5 }}>{towerTypes[selectedTower].emoji}</span>
                      )}
                    </div>
                  );
                }))}

                {/* Death marks / craters */}
                {deathMarks.map(mark => (
                  <div key={mark.id} style={{
                    position: 'absolute',
                    left: mark.x - mark.size / 2 + GRID_OFFSET,
                    top: mark.y - mark.size / 2 + GRID_OFFSET,
                    width: mark.size,
                    height: mark.size,
                    background: `radial-gradient(circle, ${mark.color}40 0%, ${mark.color}20 40%, transparent 70%)`,
                    borderRadius: '50%',
                    opacity: Math.min(1, mark.life / 2000) * 0.6,
                    pointerEvents: 'none',
                    zIndex: 3,
                    boxShadow: `inset 0 0 ${mark.size/3}px ${mark.color}30`,
                  }} />
                ))}

                {/* Base health visualization - glow around the end based on remaining lives */}
                <div style={{
                  position: 'absolute',
                  left: END.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                  top: END.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                  width: CELL_SIZE * 2.5,
                  height: CELL_SIZE * 2.5,
                  transform: 'translate(-50%, -50%)',
                  borderRadius: '50%',
                  background: `radial-gradient(circle,
                    ${lives > 10 ? theme.success : lives > 5 ? theme.gold : theme.error}${Math.floor(lives / 20 * 40).toString(16).padStart(2, '0')} 0%,
                    transparent 70%)`,
                  pointerEvents: 'none',
                  zIndex: 2,
                  animation: lives <= 5 ? 'pulse 1s ease-in-out infinite' : 'none',
                }} />

                {/* Path flow particles */}
                {path.length > 1 && Array(5).fill(0).map((_, i) => {
                  const flowPos = (pathFlowOffset + i * 0.2) % 1;
                  const pathIdx = Math.floor(flowPos * (path.length - 1));
                  const t = (flowPos * (path.length - 1)) - pathIdx;
                  const p1 = path[pathIdx];
                  const p2 = path[Math.min(pathIdx + 1, path.length - 1)];
                  if (!p1 || !p2) return null;
                  const x = (p1.col + (p2.col - p1.col) * t) * CELL_SIZE + CELL_SIZE / 2;
                  const y = (p1.row + (p2.row - p1.row) * t) * CELL_SIZE + CELL_SIZE / 2;
                  return (
                    <div key={`flow-${i}`} style={{
                      position: 'absolute',
                      left: x - 3 + GRID_OFFSET,
                      top: y - 3 + GRID_OFFSET,
                      width: 6,
                      height: 6,
                      background: theme.accent,
                      borderRadius: '50%',
                      opacity: 0.3,
                      pointerEvents: 'none',
                      zIndex: 4,
                      boxShadow: `0 0 6px ${theme.accent}`,
                    }} />
                  );
                })}

                {/* Range indicator */}
                {(hoveredCell && selectedTower && canPlaceTowerFast(hoveredCell.row, hoveredCell.col)) && (
                  <div style={{
                    position: 'absolute',
                    left: hoveredCell.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    top: hoveredCell.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    width: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    height: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px dashed ${towerTypes[selectedTower].color}40`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${towerTypes[selectedTower].color}08 0%, transparent 70%)`,
                  }} />
                )}

                {/* Selected tower range */}
                {selectedTowerForUpgrade && (
                  <div style={{
                    position: 'absolute',
                    left: selectedTowerForUpgrade.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    top: selectedTowerForUpgrade.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET,
                    width: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    height: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px solid ${selectedTowerForUpgrade.color}60`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${selectedTowerForUpgrade.color}10 0%, transparent 70%)`,
                  }} />
                )}

                {/* Beams */}
                {towers.filter(t => t.beam && t.beamTarget).map(tower => {
                  const fromX = tower.col * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET;
                  const fromY = tower.row * CELL_SIZE + CELL_SIZE / 2 + GRID_OFFSET;
                  const toX = tower.beamTarget.x + GRID_OFFSET;
                  const toY = tower.beamTarget.y + GRID_OFFSET;
                  const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                  const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);

                  return (
                    <React.Fragment key={`beam-${tower.id}`}>
                      {/* Outer glow */}
                      <div style={{
                        position: 'absolute',
                        left: fromX,
                        top: fromY - 3,
                        width: length,
                        height: '10px',
                        background: `linear-gradient(90deg, ${tower.color}60 0%, ${tower.color}20 100%)`,
                        transform: `rotate(${angle}deg)`,
                        transformOrigin: '0 50%',
                        pointerEvents: 'none',
                        filter: 'blur(4px)',
                        zIndex: 14,
                      }} />
                      {/* Core beam */}
                      <div style={{
                        position: 'absolute',
                        left: fromX,
                        top: fromY - 1,
                        width: length,
                        height: '4px',
                        background: `linear-gradient(90deg, #fff 0%, ${tower.color} 20%, ${tower.color} 80%, #fff 100%)`,
                        transform: `rotate(${angle}deg)`,
                        transformOrigin: '0 50%',
                        pointerEvents: 'none',
                        boxShadow: `0 0 12px ${tower.color}, 0 0 24px ${tower.color}80, 0 0 4px #fff`,
                        zIndex: 15,
                        borderRadius: '2px',
                      }} />
                    </React.Fragment>
                  );
                })}

                {/* Enemies */}
                {enemies.map(enemy => {
                  const size = (CELL_SIZE * 0.55) * (enemy.size || 1);
                  const bobOffset = Math.sin(enemy.animPhase * 4) * 2;
                  const scaleEffect = 1 + Math.sin(enemy.animPhase * 2) * 0.03;

                  return (
                    <div
                      key={enemy.id}
                      style={{
                        position: 'absolute',
                        left: enemy.x - size / 2 + GRID_OFFSET,
                        top: enemy.y - size / 2 + GRID_OFFSET + bobOffset,
                        width: size,
                        height: size,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        pointerEvents: 'none',
                        zIndex: 10,
                        filter: enemy.hitFlash > 0 ? `brightness(${1 + enemy.hitFlash * 1.5}) drop-shadow(0 0 8px #fff)`
                          : enemy.poisonedUntil > renderTime ? `drop-shadow(0 0 6px ${theme.poison}) drop-shadow(0 0 2px ${theme.poison})`
                          : enemy.slowedUntil > renderTime ? `drop-shadow(0 0 6px ${theme.frost}) drop-shadow(0 0 2px ${theme.frost})`
                          : `drop-shadow(0 0 4px ${enemy.color})`,
                        transition: 'filter 0.1s ease',
                        transform: `scale(${scaleEffect})`,
                      }}
                    >
                      <span style={{
                        fontSize: enemy.isBoss ? CELL_SIZE * 0.8 : size * 0.8,
                        transform: `scaleX(${enemy.rotation > -Math.PI / 2 && enemy.rotation < Math.PI / 2 ? 1 : -1})`,
                      }}>{enemy.emoji}</span>

                      {/* Health bar */}
                      <div style={{
                        position: 'absolute',
                        bottom: -8,
                        width: size + 6,
                        height: enemy.isBoss ? 6 : 4,
                        background: 'rgba(0,0,0,0.7)',
                        borderRadius: '3px',
                        overflow: 'hidden',
                        border: '1px solid rgba(255,255,255,0.1)',
                        boxShadow: '0 1px 3px rgba(0,0,0,0.4)',
                      }}>
                        {enemy.maxShield > 0 && (
                          <div style={{
                            position: 'absolute',
                            width: `${(enemy.currentShield / enemy.maxShield) * 100}%`,
                            height: '100%',
                            background: 'linear-gradient(180deg, #9db3c9 0%, #778ca3 100%)',
                            transition: 'width 0.1s ease',
                          }} />
                        )}
                        <div style={{
                          width: `${(enemy.currentHealth / enemy.maxHealth) * 100}%`,
                          height: '100%',
                          background: enemy.currentHealth > enemy.maxHealth * 0.5
                            ? `linear-gradient(180deg, ${theme.success} 0%, #1fab54 100%)`
                            : enemy.currentHealth > enemy.maxHealth * 0.25
                            ? `linear-gradient(180deg, ${theme.gold} 0%, #e6c200 100%)`
                            : `linear-gradient(180deg, ${theme.error} 0%, #cc3847 100%)`,
                          transition: 'width 0.15s ease',
                          boxShadow: enemy.currentHealth <= enemy.maxHealth * 0.25 ? `0 0 4px ${theme.error}` : 'none',
                        }} />
                      </div>

                      {enemy.slowedUntil > renderTime && <div style={{ position: 'absolute', top: -8, fontSize: '8px' }}>â„ï¸</div>}
                      {enemy.poisonedUntil > renderTime && <div style={{ position: 'absolute', top: -8, left: enemy.slowedUntil > renderTime ? 10 : 0, fontSize: '8px' }}>â˜ ï¸</div>}
                    </div>
                  );
                })}

                {/* Projectiles */}
                {projectiles.map(proj => {
                  // Calculate position with optional arcing
                  let x = proj.fromX + (proj.toX - proj.fromX) * proj.progress;
                  let y = proj.fromY + (proj.toY - proj.fromY) * proj.progress;

                  // Arcing projectiles (cannon) - parabolic motion
                  if (proj.arcing && proj.arcHeight) {
                    const arcOffset = Math.sin(proj.progress * Math.PI) * proj.arcHeight;
                    y -= arcOffset;
                  }

                  // Elemental trail colors
                  const trailColors = {
                    fire: ['#ff6b35', '#ff9500', '#ffcc00'],
                    frost: ['#70c9ff', '#a8e6ff', '#ffffff'],
                    lightning: ['#fff200', '#ffff80', '#ffffff'],
                    poison: ['#a55eea', '#c990ff', '#e8c0ff'],
                    physical: [proj.color],
                  };
                  const elementTrail = trailColors[proj.damageType] || [proj.color];

                  return (
                    <React.Fragment key={proj.id}>
                      {/* Elemental trail */}
                      {proj.trail.map((point, i) => {
                        const trailY = proj.arcing && proj.arcHeight
                          ? point.y - Math.sin((i / proj.trail.length) * Math.PI) * proj.arcHeight * 0.3
                          : point.y;
                        const trailColor = elementTrail[i % elementTrail.length];
                        return (
                          <div key={`trail-${proj.id}-${i}`} style={{
                            position: 'absolute',
                            left: point.x - proj.size * 0.4 + GRID_OFFSET,
                            top: trailY - proj.size * 0.4 + GRID_OFFSET,
                            width: proj.size * 0.7,
                            height: proj.size * 0.7,
                            background: `radial-gradient(circle, ${trailColor} 0%, transparent 70%)`,
                            borderRadius: '50%',
                            opacity: (i / proj.trail.length) * 0.6,
                            pointerEvents: 'none',
                            zIndex: 18,
                          }} />
                        );
                      })}
                      {/* Main projectile */}
                      <div style={{
                        position: 'absolute',
                        left: x - proj.size / 2 + GRID_OFFSET,
                        top: y - proj.size / 2 + GRID_OFFSET,
                        width: proj.size,
                        height: proj.size,
                        background: `radial-gradient(circle, #fff 0%, ${proj.color} 50%, transparent 100%)`,
                        borderRadius: proj.arcing ? '30%' : '50%',
                        boxShadow: `0 0 ${proj.size * 1.5}px ${proj.color}, 0 0 ${proj.size * 0.5}px #fff`,
                        pointerEvents: 'none',
                        zIndex: 20,
                        transform: proj.arcing ? `rotate(${Math.atan2(proj.toY - proj.fromY, proj.toX - proj.fromX) + Math.PI/4}rad)` : 'none',
                      }} />
                      {/* Chain lightning special effect */}
                      {proj.isChain && (
                        <div style={{
                          position: 'absolute',
                          left: proj.fromX + GRID_OFFSET,
                          top: proj.fromY + GRID_OFFSET,
                          width: 2,
                          height: Math.sqrt((proj.toX - proj.fromX) ** 2 + (proj.toY - proj.fromY) ** 2),
                          background: `linear-gradient(180deg, ${proj.color} 0%, transparent 100%)`,
                          transform: `rotate(${Math.atan2(proj.toY - proj.fromY, proj.toX - proj.fromX) - Math.PI/2}rad)`,
                          transformOrigin: 'top center',
                          opacity: 1 - proj.progress,
                          pointerEvents: 'none',
                          zIndex: 19,
                          filter: 'blur(1px)',
                        }} />
                      )}
                    </React.Fragment>
                  );
                })}

                {/* Particles */}
                {particles.map(p => p.isShockwave ? (
                  // Explosion shockwave - expanding ring
                  <div key={p.id} style={{
                    position: 'absolute',
                    left: p.x - p.size * (2 - p.life / p.maxLife) + GRID_OFFSET,
                    top: p.y - p.size * (2 - p.life / p.maxLife) + GRID_OFFSET,
                    width: p.size * 2 * (2 - p.life / p.maxLife),
                    height: p.size * 2 * (2 - p.life / p.maxLife),
                    border: `3px solid ${p.color}`,
                    borderRadius: '50%',
                    opacity: p.life / p.maxLife * 0.7,
                    pointerEvents: 'none',
                    zIndex: 24,
                    boxShadow: `0 0 10px ${p.color}, inset 0 0 10px ${p.color}40`,
                  }} />
                ) : (
                  // Regular particle
                  <div key={p.id} style={{
                    position: 'absolute',
                    left: p.x - p.size / 2 + GRID_OFFSET,
                    top: p.y - p.size / 2 + GRID_OFFSET,
                    width: p.size,
                    height: p.size,
                    background: `radial-gradient(circle, ${p.color} 0%, ${p.color}80 50%, transparent 100%)`,
                    borderRadius: '50%',
                    opacity: Math.pow(p.life / p.maxLife, 0.7),
                    pointerEvents: 'none',
                    zIndex: 25,
                    transform: `scale(${0.5 + (p.life / p.maxLife) * 0.5}) rotate(${p.rotation}deg)`,
                    boxShadow: `0 0 ${p.size * 1.2}px ${p.color}`,
                  }} />
                ))}

                {/* Floating texts */}
                {floatingTexts.map(t => (
                  <div key={t.id} style={{
                    position: 'absolute',
                    left: t.x + GRID_OFFSET,
                    top: t.y + GRID_OFFSET,
                    fontSize: `${t.size}px`,
                    fontWeight: 800,
                    color: t.color,
                    pointerEvents: 'none',
                    zIndex: 30,
                    opacity: t.life / t.maxLife,
                    transform: `translate(-50%, -50%) scale(${t.isCrit ? 1.2 : 1})`,
                    textShadow: `0 0 8px ${t.color}, 0 2px 3px rgba(0,0,0,0.5)`,
                    animation: t.isCrit ? 'shake 0.2s ease-out' : 'none',
                  }}>{t.text}</div>
                ))}

                {/* Announcements */}
                {announcements.map((a, i) => (
                  <div key={a.id} style={{
                    position: 'absolute',
                    left: '50%',
                    top: 60 + i * 40,
                    transform: 'translateX(-50%)',
                    fontSize: '18px',
                    fontWeight: 900,
                    color: a.color,
                    textShadow: `0 0 20px ${a.color}, 0 2px 4px rgba(0,0,0,0.5)`,
                    pointerEvents: 'none',
                    zIndex: 50,
                    opacity: Math.min(1, a.life / 500),
                    animation: 'popIn 0.2s ease-out',
                  }}>{a.text}</div>
                ))}

                {/* Game Over */}
                {gameState === 'lost' && (
                  <div style={{
                    position: 'absolute',
                    inset: 0,
                    background: 'rgba(10, 10, 18, 0.95)',
                    borderRadius: '10px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    zIndex: 100,
                    animation: 'slideIn 0.4s ease-out',
                  }}>
                    <div style={{ fontSize: '60px', marginBottom: '16px' }}>ðŸ’€</div>
                    <div style={{ fontSize: '28px', fontWeight: 900, color: theme.error, marginBottom: '8px' }}>GAME OVER</div>
                    <div style={{ fontSize: '14px', color: theme.textSecondary, marginBottom: '16px' }}>
                      Wave {wave} â€¢ Score {totalScore.toLocaleString()}
                    </div>
                    <div style={{ display: 'flex', gap: '16px', fontSize: '11px', color: theme.textMuted, marginBottom: '20px' }}>
                      <span>ðŸŽ¯ {killCount} kills</span>
                      <span>ðŸ”¥ {maxCombo} max combo</span>
                    </div>
                    <button onClick={startGame} className="btn" style={{
                      padding: '12px 32px',
                      fontSize: '14px',
                      fontWeight: 700,
                      background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                      border: 'none',
                      borderRadius: '10px',
                      color: '#fff',
                      boxShadow: `0 4px 16px ${theme.accentGlow}`,
                    }}>PLAY AGAIN</button>
                  </div>
                )}
              </div>

              {/* Wave preview */}
              {!waveInProgress && wavePreview && (
                <div style={{
                  marginTop: '8px',
                  padding: '8px 12px',
                  background: theme.bgPanel,
                  borderRadius: '8px',
                  border: `1px solid ${theme.border}`,
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '11px',
                }}>
                  <span style={{ color: theme.textMuted }}>Next:</span>
                  {Object.entries(wavePreview).map(([type, count]) => (
                    <span key={`preview-${type}`} style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                      <span>{enemyTypes[type].emoji}</span>
                      <span style={{ color: enemyTypes[type].color, fontWeight: 600 }}>Ã—{count}</span>
                    </span>
                  ))}
                </div>
              )}
            </div>

            {/* Right Panel - Hidden in portrait */}
            {isLandscape && <div style={{
              background: theme.bgPanel,
              borderRadius: '12px',
              padding: '12px',
              border: `1px solid ${theme.border}`,
              width: `${panelWidth}px`,
              flexShrink: 0,
            }}>
              {selectedTowerForUpgrade ? (
                <>
                  <div style={{ fontSize: '10px', fontWeight: 700, color: selectedTowerForUpgrade.color, letterSpacing: '1px', marginBottom: '8px' }}>
                    {selectedTowerForUpgrade.name.toUpperCase()}
                  </div>
                  <div style={{ textAlign: 'center', marginBottom: '10px' }}>
                    <span style={{ fontSize: '36px' }}>{selectedTowerForUpgrade.emoji}</span>
                    <div style={{ fontSize: '10px', color: theme.gold, fontWeight: 600 }}>Level {selectedTowerForUpgrade.level + 1}</div>
                  </div>
                  <div style={{ fontSize: '9px', color: theme.textSecondary, marginBottom: '10px', background: theme.bgDark, padding: '8px', borderRadius: '6px' }}>
                    <div>DMG: <span style={{ color: theme.text, fontWeight: 600 }}>{selectedTowerForUpgrade.damage}</span>
                      {selectedTowerForUpgrade.xpLevel > 0 && <span style={{ color: theme.success, fontSize: '8px' }}> +{selectedTowerForUpgrade.xpLevel * 2}%</span>}
                    </div>
                    <div>RNG: <span style={{ color: theme.text, fontWeight: 600 }}>{selectedTowerForUpgrade.range}</span></div>
                    <div>DPS: <span style={{ color: theme.gold, fontWeight: 600 }}>{(selectedTowerForUpgrade.damage * 1000 / selectedTowerForUpgrade.fireRate).toFixed(1)}</span></div>
                    <div style={{ marginTop: '4px', borderTop: `1px solid ${theme.border}`, paddingTop: '4px' }}>
                      Kills: <span style={{ color: theme.error, fontWeight: 600 }}>{selectedTowerForUpgrade.kills}</span>
                      {selectedTowerForUpgrade.xpLevel > 0 && <span style={{ color: theme.accent, marginLeft: '6px' }}>â˜…{selectedTowerForUpgrade.xpLevel}</span>}
                    </div>
                  </div>

                  {/* Targeting Mode Selector */}
                  <div style={{ fontSize: '9px', color: theme.textMuted, marginBottom: '4px' }}>TARGET:</div>
                  <div style={{ display: 'flex', flexWrap: 'wrap', gap: '3px', marginBottom: '10px' }}>
                    {['first', 'last', 'strongest', 'weakest', 'closest'].map(mode => (
                      <button
                        key={mode}
                        onClick={() => setTowers(prev => prev.map(t =>
                          t.id === selectedTowerForUpgrade.id ? { ...t, targetingMode: mode } : t
                        ))}
                        style={{
                          padding: '3px 6px',
                          fontSize: '8px',
                          fontWeight: 600,
                          background: selectedTowerForUpgrade.targetingMode === mode ? theme.accent : theme.bgDark,
                          border: `1px solid ${selectedTowerForUpgrade.targetingMode === mode ? theme.accent : theme.border}`,
                          borderRadius: '4px',
                          color: selectedTowerForUpgrade.targetingMode === mode ? '#fff' : theme.textSecondary,
                          cursor: 'pointer',
                          textTransform: 'capitalize',
                        }}
                      >{mode}</button>
                    ))}
                  </div>

                  {selectedTowerForUpgrade.level < towerTypes[selectedTowerForUpgrade.type].upgrades.length ? (() => {
                    const nextUpgrade = towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level];
                    return (
                    <>
                      <div style={{ fontSize: '9px', color: theme.textMuted, marginBottom: '4px' }}>UPGRADE PREVIEW:</div>
                      <div style={{ background: theme.bgDark, padding: '8px', borderRadius: '6px', marginBottom: '8px', fontSize: '9px' }}>
                        <div style={{ fontWeight: 600, color: theme.gold, marginBottom: '4px' }}>
                          â†’ {nextUpgrade.name}
                        </div>
                        {nextUpgrade.damage && nextUpgrade.damage !== selectedTowerForUpgrade.damage && (
                          <div style={{ color: theme.success }}>DMG: {selectedTowerForUpgrade.damage} â†’ {nextUpgrade.damage}</div>
                        )}
                        {nextUpgrade.range && nextUpgrade.range !== selectedTowerForUpgrade.range && (
                          <div style={{ color: theme.success }}>RNG: {selectedTowerForUpgrade.range} â†’ {nextUpgrade.range}</div>
                        )}
                        {nextUpgrade.fireRate && nextUpgrade.fireRate !== selectedTowerForUpgrade.fireRate && (
                          <div style={{ color: theme.success }}>SPD: {(1000/selectedTowerForUpgrade.fireRate).toFixed(1)} â†’ {(1000/nextUpgrade.fireRate).toFixed(1)}/s</div>
                        )}
                        {nextUpgrade.slow && nextUpgrade.slow !== selectedTowerForUpgrade.slow && (
                          <div style={{ color: theme.frost }}>SLOW: {Math.round(selectedTowerForUpgrade.slow*100)}% â†’ {Math.round(nextUpgrade.slow*100)}%</div>
                        )}
                        {nextUpgrade.splash && nextUpgrade.splash !== selectedTowerForUpgrade.splash && (
                          <div style={{ color: theme.fire }}>AOE: {selectedTowerForUpgrade.splash} â†’ {nextUpgrade.splash}</div>
                        )}
                        {nextUpgrade.chain && nextUpgrade.chain !== selectedTowerForUpgrade.chain && (
                          <div style={{ color: theme.lightning }}>CHAIN: {selectedTowerForUpgrade.chain} â†’ {nextUpgrade.chain}</div>
                        )}
                        {nextUpgrade.poisonDamage && nextUpgrade.poisonDamage !== selectedTowerForUpgrade.poisonDamage && (
                          <div style={{ color: theme.poison }}>DOT: {selectedTowerForUpgrade.poisonDamage} â†’ {nextUpgrade.poisonDamage}</div>
                        )}
                        <div style={{ marginTop: '4px', color: theme.gold, fontWeight: 600 }}>ðŸ’° {nextUpgrade.cost}</div>
                      </div>
                      <button
                        onClick={() => upgradeTower(selectedTowerForUpgrade.id)}
                        disabled={gold < towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost}
                        className="btn"
                        style={{
                          width: '100%',
                          padding: '8px',
                          fontSize: '11px',
                          fontWeight: 700,
                          background: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost
                            ? `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`
                            : theme.bgDark,
                          border: 'none',
                          borderRadius: '6px',
                          color: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost ? '#fff' : theme.textMuted,
                          marginBottom: '6px',
                        }}
                      >UPGRADE [U]</button>
                    </>
                  )})() : (
                    <div style={{ fontSize: '10px', color: theme.gold, textAlign: 'center', padding: '8px', background: `${theme.gold}10`, borderRadius: '6px', marginBottom: '8px' }}>
                      âœ¨ MAX LEVEL
                    </div>
                  )}
                  <button
                    onClick={() => sellTower(selectedTowerForUpgrade.id)}
                    className="btn"
                    style={{
                      width: '100%',
                      padding: '8px',
                      fontSize: '11px',
                      fontWeight: 700,
                      background: 'transparent',
                      border: `1px solid ${theme.error}`,
                      borderRadius: '6px',
                      color: theme.error,
                    }}
                  >SELL [S]</button>
                </>
              ) : (
                <>
                  <div style={{ fontSize: '10px', fontWeight: 700, color: theme.accent, letterSpacing: '1px', marginBottom: '10px' }}>ENEMIES</div>
                  {Object.values(enemyTypes).slice(0, 6).map(enemy => (
                    <div key={`info-${enemy.id}`} style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: '6px',
                      padding: '4px 6px',
                      marginBottom: '4px',
                      background: theme.bgDark,
                      borderRadius: '6px',
                    }}>
                      <span style={{ fontSize: '14px' }}>{enemy.emoji}</span>
                      <div>
                        <div style={{ fontSize: '9px', fontWeight: 600, color: enemy.color }}>{enemy.name}</div>
                        <div style={{ fontSize: '8px', color: theme.textMuted }}>HP:{enemy.health} ðŸ’°{enemy.reward}</div>
                      </div>
                    </div>
                  ))}
                  <div style={{ marginTop: '12px', fontSize: '10px', fontWeight: 700, color: theme.accent, letterSpacing: '1px', marginBottom: '6px' }}>STATS</div>
                  <div style={{ fontSize: '9px', color: theme.textSecondary, background: theme.bgDark, padding: '8px', borderRadius: '6px' }}>
                    <div>Score: <span style={{ color: theme.gold, fontWeight: 600 }}>{totalScore.toLocaleString()}</span></div>
                    <div>Kills: <span style={{ color: theme.error, fontWeight: 600 }}>{killCount}</span></div>
                    <div>Best Combo: <span style={{ color: theme.accent, fontWeight: 600 }}>{maxCombo}</span></div>
                  </div>
                </>
              )}
            </div>}

            {/* Portrait mode: tower selection bar at bottom */}
            {!isLandscape && (
              <div style={{
                display: 'flex',
                gap: '6px',
                padding: '8px',
                background: theme.bgPanel,
                borderRadius: '10px',
                border: `1px solid ${theme.border}`,
                overflowX: 'auto',
                width: '100%',
                maxWidth: gridWidth,
              }}>
                {Object.values(towerTypes).map(tower => {
                  const canAfford = gold >= tower.cost;
                  const isSelected = selectedTower === tower.id;
                  return (
                    <div
                      key={tower.id}
                      onClick={() => canAfford && (setSelectedTower(tower.id), setSelectedTowerForUpgrade(null))}
                      style={{
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        padding: '6px 8px',
                        minWidth: '50px',
                        background: isSelected ? `${tower.color}30` : theme.bgDark,
                        borderRadius: '8px',
                        opacity: canAfford ? 1 : 0.4,
                        border: isSelected ? `2px solid ${tower.color}` : '1px solid transparent',
                        cursor: canAfford ? 'pointer' : 'not-allowed',
                      }}
                    >
                      <span style={{ fontSize: '20px' }}>{tower.emoji}</span>
                      <span style={{ fontSize: '9px', color: theme.gold }}>{tower.cost}</span>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TowerDefenseGame />);
  </script>
</body>
</html>

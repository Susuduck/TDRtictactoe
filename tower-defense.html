<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tower Defense</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: #0a0a12;
      overflow: hidden;
      height: 100%;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    #root { height: 100%; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
// ZzFX - Zuper Zmall Zound Zynth - Micro Edition (MIT License)
// https://github.com/KilledByAPixel/ZzFX
const zzfx=(...z)=>zzfxP(zzfxG(...z));const zzfxP=(...z)=>{let e=zzfxX.createBufferSource(),t=zzfxX.createBuffer(z.length,z[0].length,zzfxR);z.map((z,f)=>t.getChannelData(f).set(z)),e.buffer=t,e.connect(zzfxX.destination),e.start();return e};const zzfxG=(q=1,k=.05,c=220,e=0,t=0,u=.1,r=0,F=1,v=0,z=0,w=0,A=0,l=0,B=0,x=0,G=0,d=0,y=1,m=0,C=0)=>{let b=2*Math.PI,H=v*=500*b/zzfxR**2,I=(0<x?1:-1)*b/4,D=c*=(1+2*k*Math.random()-k)*b/zzfxR,Z=[],g=0,E=0,a=0,n=1,J=0,K=0,f=0,p,h;e=99+zzfxR*e;m*=zzfxR;t*=zzfxR;u*=zzfxR;d*=zzfxR;z*=500*b/zzfxR**3;x*=b/zzfxR;w*=b/zzfxR;A*=zzfxR;l=zzfxR*l|0;for(h=e+m+t+u+d|0;a<h;Z[a++]=f)++K%(100*G|0)||(f=r?1<r?2<r?3<r?Math.sin((g%b)**3):Math.max(Math.min(Math.tan(g),1),-1):1-(2*g/b%2+2)%2:1-4*Math.abs(Math.round(g/b)-g/b):Math.sin(g),f=(l?1-C+C*Math.sin(2*Math.PI*a/l):1)*(0<f?1:-1)*Math.abs(f)**F*q*zzfxV*(a<e?a/e:a<e+m?1-(a-e)/m*(1-y):a<e+m+t?y:a<h-d?(h-a-d)/u*y:0),f=d?f/2+(d>a?0:(a<h-d?1:(h-a)/d)/2)*Z[a-d|0]:f),p=(c+=v+=z)*Math.cos(I*J++),g+=p-p*B*(1-1E9*(Math.sin(a)+1)%2),n&&++n>A&&(c+=w,D+=w,n=0),!l||++E%l||(c=D,v=H,n=n||1);return Z};const zzfxV=.3,zzfxR=44100,zzfxX=new(window.AudioContext||window.webkitAudioContext);

// Sound effect presets
const SFX = {
  shoot: () => zzfx(...[.3,.05,400,.02,.02,.08,1,.5,,,,,,,,.1]),
  arrowShoot: () => zzfx(...[.2,.1,200,.01,.01,.05,2,2,,,,,,,,,.02]),
  cannonShoot: () => zzfx(...[.4,.2,150,.02,.05,.2,4,.5,,,,,,,.1,,.1]),
  frostShoot: () => zzfx(...[.2,.1,800,.01,.02,.1,2,1,,,200,.05,,,,,.05]),
  lightningShoot: () => zzfx(...[.3,.05,600,.01,.02,.05,3,1,20,,,,.02,,,,.03]),
  laserLoop: () => zzfx(...[.1,,200,,.1,.1,4,1,,,,,,,3]),
  poisonShoot: () => zzfx(...[.2,.2,100,.02,.08,.15,2,2,,,-50,.08,.1]),
  hit: () => zzfx(...[.2,.05,300,.01,.02,.05,4,.5,-10,,,,,,,,.02]),
  explosion: () => zzfx(...[.5,.2,150,.03,.15,.3,4,.5,,,,,,.5,,.2,.1]),
  enemyDeath: () => zzfx(...[.3,.1,200,.01,.05,.1,4,1.5,,-5,-50,.02,.05]),
  bossDeath: () => zzfx(...[.8,.3,80,.05,.4,.5,4,.5,,,-20,.1,.2,.1,,.5,.2]),
  goldPickup: () => zzfx(...[.3,.05,600,.02,.1,.1,1,2,,,400,.05]),
  upgrade: () => zzfx(...[.4,.1,400,.02,.15,.2,1,2,,,200,.05,.05]),
  place: () => zzfx(...[.3,.05,200,.01,.05,.1,1,1]),
  sell: () => zzfx(...[.2,.1,300,.01,.1,.1,2,1,,,-100,.02]),
  waveStart: () => zzfx(...[.5,.1,300,.02,.1,.2,1,1,,,100,.02,.05]),
  waveComplete: () => zzfx(...[.4,.1,500,.02,.2,.3,1,1.5,,,200,.05,.1]),
  bossWarning: () => zzfx(...[.6,.3,100,.05,.3,.4,3,.5,,,-20,.05,.1,,,.3,.1]),
  lifeLost: () => zzfx(...[.5,.2,200,.05,.1,.2,3,1,,,-100,.05]),
  abilityBomb: () => zzfx(...[.8,.3,100,.05,.3,.5,4,.3,,,,,,.5,,.4,.2]),
  abilityFreeze: () => zzfx(...[.4,.2,1000,.05,.3,.4,2,1,,,300,.1,.1]),
  crit: () => zzfx(...[.4,.05,500,.01,.03,.05,1,2,10]),
  worldUnlock: () => zzfx(...[.5,.1,400,.02,.3,.4,1,1.5,,,300,.05,.1]),
  worldSelect: () => zzfx(...[.3,.05,500,.01,.05,.1,1,1.5]),
};

// ==================== WORLD DEFINITIONS ====================
// 10 Worlds, each with 10 waves (wave 10 = boss)
const worldDefs = [
  {
    id: 0,
    name: 'Forest Fawn',
    title: 'The Woodland Guide',
    emoji: 'ðŸ¦Œ',
    color: '#50c878',
    bgGradient: 'linear-gradient(135deg, #1a3320 0%, #0d1a10 100%)',
    description: 'A gentle introduction to tower defense',
    enemyTypes: ['slime', 'swarm'],
    bossType: 'treant',
    gimmick: null, // Tutorial world - no gimmicks
    unlockRequirement: 0, // Always unlocked
  },
  {
    id: 1,
    name: 'Sandy Scorpion',
    title: 'The Desert Dweller',
    emoji: 'ðŸ¦‚',
    color: '#e8a840',
    bgGradient: 'linear-gradient(135deg, #3d2a1a 0%, #1a1008 100%)',
    description: 'Sandstorms reduce tower range',
    enemyTypes: ['scout', 'swarm', 'slime'],
    bossType: 'sandwurm',
    gimmick: 'sandstorm', // Periodically reduces all tower ranges
    unlockRequirement: 8, // Need 8 stars from previous world
  },
  {
    id: 2,
    name: 'Glacier Penguin',
    title: 'The Frozen Guardian',
    emoji: 'ðŸ§',
    color: '#70c9ff',
    bgGradient: 'linear-gradient(135deg, #1a2a3d 0%, #0a1520 100%)',
    description: 'Blizzards slow your towers',
    enemyTypes: ['tank', 'shielded', 'slime'],
    bossType: 'icegiant',
    gimmick: 'blizzard', // Slows tower attack speed
    unlockRequirement: 8,
  },
  {
    id: 3,
    name: 'Swamp Toad',
    title: 'The Murky Master',
    emoji: 'ðŸ¸',
    color: '#7cb342',
    bgGradient: 'linear-gradient(135deg, #1a2a1a 0%, #0a150a 100%)',
    description: 'Fog zones heal enemies',
    enemyTypes: ['healer', 'splitter', 'slime', 'swarm'],
    bossType: 'hydra',
    gimmick: 'fogzones', // Certain path areas heal enemies
    unlockRequirement: 8,
  },
  {
    id: 4,
    name: 'Volcano Dragon',
    title: 'The Flame Lord',
    emoji: 'ðŸ‰',
    color: '#ff6b35',
    bgGradient: 'linear-gradient(135deg, #3d1a1a 0%, #1a0808 100%)',
    description: 'Lava eruptions damage nearby towers',
    enemyTypes: ['tank', 'scout', 'slime'],
    bossType: 'elderdragon',
    gimmick: 'lavaerupt', // Random tiles erupt, damaging/disabling towers
    unlockRequirement: 8,
    enemyResists: { fire: 0.5 }, // Enemies here resist fire
  },
  {
    id: 5,
    name: 'Crystal Moth',
    title: 'The Light Seeker',
    emoji: 'ðŸ¦‹',
    color: '#c990ff',
    bgGradient: 'linear-gradient(135deg, #2a1a3d 0%, #150a20 100%)',
    description: 'Some enemies are invisible until revealed',
    enemyTypes: ['scout', 'swarm', 'slime'],
    bossType: 'shadowbeast',
    gimmick: 'invisible', // Some enemies invisible, need reveal towers
    unlockRequirement: 8,
  },
  {
    id: 6,
    name: 'Storm Eagle',
    title: 'The Sky Sovereign',
    emoji: 'ðŸ¦…',
    color: '#5090e8',
    bgGradient: 'linear-gradient(135deg, #1a2030 0%, #080a15 100%)',
    description: 'Lightning strikes random tiles',
    enemyTypes: ['scout', 'shielded', 'healer'],
    bossType: 'thunderroc',
    gimmick: 'lightning', // Random lightning damages towers/enemies
    unlockRequirement: 8,
    enemyResists: { lightning: 0.5 }, // Enemies resist lightning
  },
  {
    id: 7,
    name: 'Haunted Ghost',
    title: 'The Spirit Keeper',
    emoji: 'ðŸ‘»',
    color: '#a0a0c0',
    bgGradient: 'linear-gradient(135deg, #1a1a2a 0%, #0a0a15 100%)',
    description: 'Defeated enemies resurrect once',
    enemyTypes: ['splitter', 'healer', 'tank'],
    bossType: 'lichking',
    gimmick: 'resurrect', // Enemies come back at 50% HP once
    unlockRequirement: 8,
  },
  {
    id: 8,
    name: 'Clockwork Robot',
    title: 'The Machine Mind',
    emoji: 'ðŸ¤–',
    color: '#c0a080',
    bgGradient: 'linear-gradient(135deg, #2a2520 0%, #151210 100%)',
    description: 'Time warps speed up enemies in zones',
    enemyTypes: ['shielded', 'tank', 'scout'],
    bossType: 'mechtitan',
    gimmick: 'timewarp', // Speed zones on path
    unlockRequirement: 8,
  },
  {
    id: 9,
    name: 'Cosmic Owl',
    title: 'The Final Wisdom',
    emoji: 'ðŸ¦‰',
    color: '#d4a840',
    bgGradient: 'linear-gradient(135deg, #0a0820 0%, #000008 100%)',
    description: 'All chaos mechanics combined',
    enemyTypes: ['slime', 'scout', 'tank', 'swarm', 'healer', 'shielded', 'splitter'],
    bossType: 'voidemperor',
    gimmick: 'chaos', // Random gimmick each wave
    unlockRequirement: 8,
  },
];

// Boss definitions
const bossDefs = {
  treant: { name: 'Giant Treant', emoji: 'ðŸŒ³', health: 1500, speed: 0.3, reward: 100, size: 1.5, color: '#228b22', resist: { fire: -0.5, physical: 0.3 } },
  sandwurm: { name: 'Sand Wurm', emoji: 'ðŸ›', health: 2000, speed: 0.4, reward: 120, size: 1.6, color: '#daa520', resist: { physical: 0.3 }, splits: true },
  icegiant: { name: 'Ice Giant', emoji: 'ðŸ§Š', health: 3000, speed: 0.25, reward: 150, size: 1.7, color: '#70c9ff', resist: { frost: 0.8, fire: -0.5 }, shield: 500 },
  hydra: { name: 'Hydra', emoji: 'ðŸ', health: 2500, speed: 0.35, reward: 180, size: 1.5, color: '#7cb342', resist: { poison: 0.8 }, heals: true, splits: true },
  elderdragon: { name: 'Elder Dragon', emoji: 'ðŸ²', health: 4000, speed: 0.3, reward: 200, size: 1.8, color: '#ff4500', resist: { fire: 0.8, physical: 0.3 } },
  shadowbeast: { name: 'Shadow Beast', emoji: 'ðŸ‘¤', health: 2000, speed: 0.5, reward: 180, size: 1.4, color: '#4a0080', invisible: true },
  thunderroc: { name: 'Thunder Roc', emoji: 'ðŸ¦…', health: 3000, speed: 0.45, reward: 200, size: 1.6, color: '#ffd700', resist: { lightning: 0.8 } },
  lichking: { name: 'Lich King', emoji: 'ðŸ’€', health: 3500, speed: 0.3, reward: 220, size: 1.6, color: '#8b008b', resurrects: 2 },
  mechtitan: { name: 'Mech Titan', emoji: 'ðŸ¦¾', health: 5000, speed: 0.2, reward: 250, size: 2.0, color: '#b8860b', shield: 1500, resist: { physical: 0.5, lightning: 0.5 } },
  voidemperor: { name: 'Void Emperor', emoji: 'ðŸ‘ï¸', health: 8000, speed: 0.25, reward: 500, size: 2.2, color: '#9400d3', resist: { fire: 0.3, frost: 0.3, lightning: 0.3, poison: 0.3, physical: 0.3 } },
};

// Progression storage helper (like UTTT)
const ProgressionStorage = {
  KEY: 'towerDefense_progression_v1',

  load: () => {
    try {
      const saved = localStorage.getItem(ProgressionStorage.KEY);
      if (saved) return JSON.parse(saved);
    } catch (e) {}
    return {
      worldStars: Array(10).fill(0), // Stars earned per world (0-10 each)
      totalStars: 0,
      highestWorld: 0,
      highestWave: 0,
      gamesPlayed: 0,
      totalKills: 0,
    };
  },

  save: (data) => {
    try {
      localStorage.setItem(ProgressionStorage.KEY, JSON.stringify(data));
    } catch (e) {}
  },

  getWorldStars: (worldId) => {
    const data = ProgressionStorage.load();
    return data.worldStars[worldId] || 0;
  },

  isWorldUnlocked: (worldId) => {
    if (worldId === 0) return true;
    const data = ProgressionStorage.load();
    return data.worldStars[worldId - 1] >= worldDefs[worldId].unlockRequirement;
  },

  addStar: (worldId, waveNum) => {
    const data = ProgressionStorage.load();
    // Only add star if this is a new highest wave for this world
    if (waveNum > data.worldStars[worldId]) {
      data.worldStars[worldId] = waveNum;
      data.totalStars = data.worldStars.reduce((a, b) => a + b, 0);
      if (worldId > data.highestWorld) data.highestWorld = worldId;
      if (waveNum > data.highestWave) data.highestWave = waveNum;
      ProgressionStorage.save(data);
      return true; // New star earned
    }
    return false;
  },

  recordGame: (kills) => {
    const data = ProgressionStorage.load();
    data.gamesPlayed++;
    data.totalKills += kills;
    ProgressionStorage.save(data);
  },
};

const TowerDefenseGame = () => {
  const { useState, useEffect, useCallback, useRef, useMemo } = React;

  // Responsive scaling
  const [windowSize, setWindowSize] = useState({ width: window.innerWidth, height: window.innerHeight });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({ width: window.innerWidth, height: window.innerHeight });
      setIsLandscape(window.innerWidth > window.innerHeight);
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Detect reduced motion preference
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setPrefersReducedMotion(mediaQuery.matches);
    const handler = (e) => setPrefersReducedMotion(e.matches);
    mediaQuery.addEventListener('change', handler);
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  // Single-session mode: Parse URL parameters for Teddy's Review Roundup integration
  // Usage: tower-defense.html?session=true&world=2&callback=parent.towerDefenseComplete
  const sessionStartedRef = useRef(false);
  useEffect(() => {
    if (sessionStartedRef.current) return; // Only run once
    const params = new URLSearchParams(window.location.search);
    const isSession = params.get('session') === 'true';
    const worldParam = parseInt(params.get('world')) || 0;
    const callbackName = params.get('callback'); // e.g., "parent.towerDefenseComplete"

    if (isSession) {
      sessionStartedRef.current = true;
      // Store callback for later use
      window.towerDefenseCallback = callbackName;
      // Auto-start the session after a brief delay
      setTimeout(() => {
        startGame(Math.min(worldParam, 9), true);
      }, 100);
    }
  }, []);

  // Calculate responsive cell size with better grid calculation
  const GRID_SIZE = 15;
  // Account for portrait mode - reduce side panel width
  const panelWidth = isLandscape ? 170 : 120;
  const headerHeight = isLandscape ? 180 : 220;
  const maxGridHeight = windowSize.height - headerHeight;
  const maxGridWidth = windowSize.width - (isLandscape ? panelWidth * 2 + 50 : 30);
  const CELL_SIZE = Math.max(20, Math.min(42, Math.floor(Math.min(maxGridHeight, maxGridWidth) / GRID_SIZE) - 2));
  const GRID_OFFSET = 8;
  const GRID_GAP = 2; // Gap between grid cells in CSS

  // Game state
  const [gameState, setGameState] = useState('menu');
  const [grid, setGrid] = useState(() => Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)));
  const [towers, setTowers] = useState([]);
  const [enemies, setEnemies] = useState([]);
  const [projectiles, setProjectiles] = useState([]);
  const [particles, setParticles] = useState([]);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const [announcements, setAnnouncements] = useState([]);
  const [wave, setWave] = useState(1);
  const [lives, setLives] = useState(20);
  const [gold, setGold] = useState(100);
  const [selectedTower, setSelectedTower] = useState(null);
  const [hoveredCell, setHoveredCell] = useState(null);
  const [path, setPath] = useState([]);
  const [waveInProgress, setWaveInProgress] = useState(false);
  const [enemiesSpawned, setEnemiesSpawned] = useState(0);
  const [totalEnemiesInWave, setTotalEnemiesInWave] = useState(0);
  const [totalScore, setTotalScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [maxCombo, setMaxCombo] = useState(0);
  const [comboTimer, setComboTimer] = useState(0);
  const [screenShake, setScreenShake] = useState({ x: 0, y: 0 });
  const [selectedTowerForUpgrade, setSelectedTowerForUpgrade] = useState(null);
  const [killCount, setKillCount] = useState(0);
  const [waveEnemyList, setWaveEnemyList] = useState([]);
  const [gameSpeed, setGameSpeed] = useState(1);
  const [showHotkeys, setShowHotkeys] = useState(true);
  const [lastDamageTime, setLastDamageTime] = useState(0);
  const [totalDamageDealt, setTotalDamageDealt] = useState(0);
  const [displayGold, setDisplayGold] = useState(100); // Animated gold display
  const [waveCountdown, setWaveCountdown] = useState(0); // Countdown timer between waves
  const [lastWaveEndTime, setLastWaveEndTime] = useState(0); // When last wave ended
  const [deathMarks, setDeathMarks] = useState([]); // Visual marks where enemies died
  const [pathFlowOffset, setPathFlowOffset] = useState(0); // Animated path flow
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);
  const [isLandscape, setIsLandscape] = useState(window.innerWidth > window.innerHeight);
  const [currentFps, setCurrentFps] = useState(60);
  const fpsHistoryRef = useRef([]);

  // New game feel states
  const [slowMo, setSlowMo] = useState(1); // Slowmo multiplier (1 = normal, 0.2 = slow)
  const [screenFlash, setScreenFlash] = useState(null); // { color, opacity }
  const [dyingEnemies, setDyingEnemies] = useState([]); // Enemies in death animation
  const [confetti, setConfetti] = useState([]); // Wave complete confetti
  const [healerBeams, setHealerBeams] = useState([]); // Healer beam visualization
  const [abilities, setAbilities] = useState({
    bomb: { cooldown: 0, maxCooldown: 30000, cost: 50, ready: true },
    freeze: { cooldown: 0, maxCooldown: 20000, cost: 30, ready: true },
  });
  const [soundEnabled, setSoundEnabled] = useState(true);

  // World progression state
  const [currentWorld, setCurrentWorld] = useState(0);
  const [progression, setProgression] = useState(() => ProgressionStorage.load());
  const [singleSessionMode, setSingleSessionMode] = useState(false); // For Teddy's Review Roundup
  const [sessionStartWorld, setSessionStartWorld] = useState(0);
  const [newStarEarned, setNewStarEarned] = useState(false);
  const [activeGimmick, setActiveGimmick] = useState(null); // Current world gimmick effect
  const [sessionResults, setSessionResults] = useState({ // Track session performance
    worldsCompleted: [],
    totalStars: 0,
    totalKills: 0,
    sessionWorld: 0,
    outcome: null, // 'victory', 'defeat', or 'quit'
  });

  // Refs
  const spawnTimerRef = useRef(null);
  const enemiesRef = useRef(enemies);
  const towersRef = useRef(towers);
  const pathRef = useRef(path);
  const goldRef = useRef(gold);
  const beamDamageRef = useRef([]); // PERF: Collect beam damage to apply in batch
  const gimmickTimerRef = useRef(0); // Timer for gimmick cycles
  const gimmickActiveRef = useRef(false); // Whether gimmick effect is currently active
  const chaosGimmickRef = useRef(null); // For World 10 chaos - random gimmick per wave

  useEffect(() => { enemiesRef.current = enemies; }, [enemies]);
  useEffect(() => { towersRef.current = towers; }, [towers]);
  useEffect(() => { pathRef.current = path; }, [path]);
  useEffect(() => { goldRef.current = gold; }, [gold]);

  const theme = {
    bg: '#0a0a12',
    bgPanel: '#14141f',
    bgDark: '#0a0a10',
    bgCell: '#0e0e16',
    accent: '#7c6aed',
    accentBright: '#9d8cff',
    accentGlow: 'rgba(124, 106, 237, 0.6)',
    gold: '#ffd700',
    goldGlow: 'rgba(255, 215, 0, 0.5)',
    error: '#ff4757',
    errorGlow: 'rgba(255, 71, 87, 0.5)',
    success: '#2ed573',
    successGlow: 'rgba(46, 213, 115, 0.5)',
    frost: '#70c9ff',
    fire: '#ff6b35',
    lightning: '#fff200',
    poison: '#a55eea',
    text: '#f0f0ff',
    textSecondary: '#9090b0',
    textMuted: '#505068',
    border: '#252540',
    pathColor: 'rgba(124, 106, 237, 0.25)',
    pathGlow: 'rgba(124, 106, 237, 0.4)',
  };

  // Sprite URLs from Superpowers Asset Pack (CC0 License)
  const SPRITE_BASE = 'https://raw.githubusercontent.com/sparklinlabs/superpowers-asset-packs/master/medieval-fantasy';
  const sprites = {
    enemies: {
      slime: `${SPRITE_BASE}/monsters/slim.png`,
      scout: `${SPRITE_BASE}/monsters/bat.png`,
      tank: `${SPRITE_BASE}/monsters/cyclop.png`,
      swarm: `${SPRITE_BASE}/monsters/snake.png`,
      healer: `${SPRITE_BASE}/monsters/leonard.png`,
      shielded: `${SPRITE_BASE}/monsters/skeleton.png`,
      splitter: `${SPRITE_BASE}/monsters/slim.png`,
      boss: `${SPRITE_BASE}/monsters/dragon.png`,
      megaBoss: `${SPRITE_BASE}/monsters/king skeleton.png`,
    },
    towers: {
      arrow: `${SPRITE_BASE}/characters/1.png`,
      cannon: `${SPRITE_BASE}/characters/2.png`,
      sniper: `${SPRITE_BASE}/characters/3.png`,
      frost: `${SPRITE_BASE}/characters/4.png`,
      lightning: `${SPRITE_BASE}/characters/5.png`,
      poison: `${SPRITE_BASE}/characters/6.png`,
      laser: `${SPRITE_BASE}/characters/7.png`,
    },
    projectiles: {
      arrow: `${SPRITE_BASE}/items/projectile/1.png`,
      cannon: `${SPRITE_BASE}/items/projectile/2.png`,
      sniper: `${SPRITE_BASE}/items/projectile/3.png`,
      frost: `${SPRITE_BASE}/items/projectile/4.png`,
      lightning: `${SPRITE_BASE}/items/projectile/5.png`,
      poison: `${SPRITE_BASE}/items/projectile/6.png`,
      laser: `${SPRITE_BASE}/items/projectile/7.png`,
    },
    effects: {
      hit: `${SPRITE_BASE}/fx/1.png`,
      explosion: `${SPRITE_BASE}/fx/2.png`,
    }
  };

  // Tower damage types for resistance calculations
  const towerTypes = {
    arrow: {
      id: 'arrow', name: 'Arrow', emoji: 'ðŸ¹', cost: 30, hotkey: '1',
      damage: 12, range: 3.5, fireRate: 700, color: '#2ed573',
      projectileSpeed: 18, projectileSize: 4, critChance: 0.15,
      damageType: 'physical',
      desc: 'Fast â€¢ 15% crit',
      upgrades: [
        { cost: 40, damage: 18, fireRate: 600, name: 'Sharp' },
        { cost: 80, damage: 28, fireRate: 500, critChance: 0.25, name: 'Precise' },
        { cost: 150, damage: 40, fireRate: 400, critChance: 0.35, range: 4, name: 'Master' },
      ]
    },
    cannon: {
      id: 'cannon', name: 'Cannon', emoji: 'ðŸ’£', cost: 60, hotkey: '2',
      damage: 45, range: 2.8, fireRate: 1800, color: '#ff6b35',
      splash: 1.2, projectileSpeed: 10, projectileSize: 8,
      damageType: 'fire',
      desc: 'Splash damage',
      upgrades: [
        { cost: 50, damage: 65, splash: 1.4, name: 'Big' },
        { cost: 100, damage: 90, splash: 1.6, fireRate: 1600, name: 'Heavy' },
        { cost: 180, damage: 130, splash: 2, fireRate: 1400, name: 'Mega' },
      ]
    },
    sniper: {
      id: 'sniper', name: 'Sniper', emoji: 'ðŸŽ¯', cost: 80, hotkey: '3',
      damage: 75, range: 6, fireRate: 2200, color: '#5352ed',
      projectileSpeed: 30, projectileSize: 3,
      damageType: 'physical',
      desc: 'Long range',
      upgrades: [
        { cost: 60, damage: 110, range: 7, name: 'Scope' },
        { cost: 120, damage: 160, name: 'Pierce' },
        { cost: 200, damage: 250, range: 8, fireRate: 1800, name: 'Rail' },
      ]
    },
    frost: {
      id: 'frost', name: 'Frost', emoji: 'â„ï¸', cost: 50, hotkey: '4',
      damage: 8, range: 3, fireRate: 500, color: '#70c9ff',
      slow: 0.4, slowDuration: 2500, projectileSpeed: 14, projectileSize: 6,
      damageType: 'frost',
      desc: 'Slows 40%',
      upgrades: [
        { cost: 45, slow: 0.5, slowDuration: 3000, name: 'Deep' },
        { cost: 90, slow: 0.6, slowDuration: 3500, damage: 15, name: 'Perma' },
        { cost: 160, slow: 0.7, slowDuration: 4000, damage: 25, range: 3.5, name: 'Zero' },
      ]
    },
    lightning: {
      id: 'lightning', name: 'Tesla', emoji: 'âš¡', cost: 100, hotkey: '5',
      damage: 20, range: 3.2, fireRate: 350, color: '#fff200',
      chain: 4, chainDamageDecay: 0.7, projectileSpeed: 50, projectileSize: 2,
      damageType: 'lightning',
      desc: 'Chain Ã—4',
      upgrades: [
        { cost: 70, damage: 30, chain: 5, name: 'Arc' },
        { cost: 140, damage: 45, chain: 6, chainDamageDecay: 0.8, name: 'Over' },
        { cost: 220, damage: 65, chain: 8, fireRate: 280, name: 'Storm' },
      ]
    },
    poison: {
      id: 'poison', name: 'Plague', emoji: 'â˜ ï¸', cost: 70, hotkey: '6',
      damage: 5, range: 2.5, fireRate: 1200, color: '#a55eea',
      poisonDamage: 8, poisonDuration: 4000, splashPoison: 0.8,
      projectileSpeed: 12, projectileSize: 7,
      damageType: 'poison',
      desc: 'DoT + AoE',
      upgrades: [
        { cost: 55, poisonDamage: 14, poisonDuration: 5000, name: 'Viral' },
        { cost: 110, poisonDamage: 22, splashPoison: 1.2, name: 'Plague' },
        { cost: 190, poisonDamage: 35, poisonDuration: 6000, damage: 15, name: 'Blight' },
      ]
    },
    laser: {
      id: 'laser', name: 'Laser', emoji: 'ðŸ”´', cost: 120, hotkey: '7',
      damage: 3, range: 4, fireRate: 50, color: '#ff4757',
      beam: true, projectileSpeed: 999, projectileSize: 3,
      damageType: 'fire',
      desc: 'Continuous',
      upgrades: [
        { cost: 80, damage: 5, range: 4.5, name: 'Focus' },
        { cost: 150, damage: 8, range: 5, name: 'High' },
        { cost: 250, damage: 12, range: 5.5, name: 'Death' },
      ]
    },
  };

  // Enemy resistances: physical (arrow/sniper), fire (cannon), frost, lightning, poison
  // Values: 0 = normal, >0 = resistant (takes less), <0 = weak (takes more)
  const enemyTypes = {
    slime: { id: 'slime', name: 'Slime', emoji: 'ðŸŸ¢', health: 40, speed: 0.9, reward: 6, color: '#2ed573', size: 1,
      resist: { physical: 0, fire: 0, frost: -0.2, lightning: 0.2, poison: 0.3 } },
    scout: { id: 'scout', name: 'Scout', emoji: 'ðŸ”µ', health: 25, speed: 1.8, reward: 8, color: '#5352ed', size: 0.9,
      resist: { physical: -0.2, fire: 0, frost: 0.3, lightning: -0.2, poison: 0 } },
    tank: { id: 'tank', name: 'Golem', emoji: 'ðŸŸ¤', health: 180, speed: 0.45, reward: 18, color: '#cd6133', size: 1.3,
      resist: { physical: 0.4, fire: -0.3, frost: 0.2, lightning: -0.2, poison: 0.5 } },
    swarm: { id: 'swarm', name: 'Bug', emoji: 'ðŸ›', health: 15, speed: 1.4, reward: 4, color: '#7bed9f', size: 0.7,
      resist: { physical: 0, fire: -0.5, frost: 0, lightning: -0.3, poison: -0.2 } },
    healer: { id: 'healer', name: 'Medic', emoji: 'ðŸ’š', health: 60, speed: 0.7, reward: 14, color: '#26de81', size: 1, heals: true,
      resist: { physical: 0, fire: 0, frost: 0, lightning: 0, poison: 0.8 } },
    shielded: { id: 'shielded', name: 'Knight', emoji: 'ðŸ›¡ï¸', health: 100, speed: 0.6, reward: 21, color: '#778ca3', size: 1.1, shield: 50,
      resist: { physical: 0.3, fire: 0, frost: 0, lightning: -0.4, poison: 0 } },
    splitter: { id: 'splitter', name: 'Amoeba', emoji: 'ðŸ«§', health: 80, speed: 0.8, reward: 10, color: '#a55eea', size: 1.1, splits: 2,
      resist: { physical: 0.2, fire: -0.2, frost: 0, lightning: 0, poison: 0.6 } },
    boss: { id: 'boss', name: 'Dragon', emoji: 'ðŸ‰', health: 800, speed: 0.35, reward: 100, color: '#ff4757', size: 1.8, isBoss: true,
      resist: { physical: 0.2, fire: 0.5, frost: -0.3, lightning: 0.1, poison: 0.3 } },
    megaBoss: { id: 'megaBoss', name: 'Titan', emoji: 'ðŸ‘¹', health: 2000, speed: 0.25, reward: 200, color: '#ff0000', size: 2.2, isBoss: true,
      resist: { physical: 0.3, fire: 0.3, frost: 0.3, lightning: 0.3, poison: 0.3 } },
  };

  const START = { row: 0, col: Math.floor(GRID_SIZE / 2) };
  const END = { row: GRID_SIZE - 1, col: Math.floor(GRID_SIZE / 2) };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (gameState !== 'playing') return;

      const key = e.key;
      const towerKeys = { '1': 'arrow', '2': 'cannon', '3': 'sniper', '4': 'frost', '5': 'lightning', '6': 'poison', '7': 'laser' };

      if (towerKeys[key] && goldRef.current >= towerTypes[towerKeys[key]].cost) {
        setSelectedTower(towerKeys[key]);
        setSelectedTowerForUpgrade(null);
      }
      if (key === 'Escape') {
        setSelectedTower(null);
        setSelectedTowerForUpgrade(null);
      }
      if (key === ' ' && !waveInProgress) {
        e.preventDefault();
        startWave();
      }
      if (key === 'u' && selectedTowerForUpgrade) {
        upgradeTower(selectedTowerForUpgrade.id);
      }
      if (key === 's' && selectedTowerForUpgrade) {
        sellTower(selectedTowerForUpgrade.id);
      }
      // Ability shortcuts
      if (key === 'q' || key === 'Q') {
        useBombAbility();
      }
      if (key === 'w' || key === 'W') {
        useFreezeAbility();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [gameState, waveInProgress, selectedTowerForUpgrade, useBombAbility, useFreezeAbility]);

  // Pathfinding
  const findPath = useCallback((gridState) => {
    const queue = [[START.row, START.col]];
    const visited = new Set();
    const parent = new Map();
    visited.add(`${START.row},${START.col}`);
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

    while (queue.length > 0) {
      const [row, col] = queue.shift();
      if (row === END.row && col === END.col) {
        const pathResult = [];
        let current = `${END.row},${END.col}`;
        while (current) {
          const [r, c] = current.split(',').map(Number);
          pathResult.unshift({ row: r, col: c });
          current = parent.get(current);
        }
        return pathResult;
      }
      for (const [dr, dc] of directions) {
        const newRow = row + dr;
        const newCol = col + dc;
        const key = `${newRow},${newCol}`;
        if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE &&
            !visited.has(key) && gridState[newRow][newCol] === null) {
          visited.add(key);
          parent.set(key, `${row},${col}`);
          queue.push([newRow, newCol]);
        }
      }
    }
    return null;
  }, []);

  // Spawn particles with performance throttling
  const spawnParticles = useCallback((x, y, color, count = 8, config = {}) => {
    // Reduce particles if reduced motion is preferred or FPS is low
    const avgFps = fpsHistoryRef.current.length > 0
      ? fpsHistoryRef.current.reduce((a, b) => a + b, 0) / fpsHistoryRef.current.length
      : 60;
    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const fpsMultiplier = avgFps < 30 ? 0.3 : avgFps < 45 ? 0.6 : 1;
    const actualCount = reducedMotion ? Math.ceil(count * 0.3) : Math.ceil(count * fpsMultiplier);

    const { speed = 3, size = 4, life = 500, spread = Math.PI * 2, direction = 0, gravity = 0 } = config;
    const newParticles = Array(actualCount).fill(null).map(() => {
      const angle = direction + (Math.random() - 0.5) * spread;
      const vel = (0.5 + Math.random() * 0.5) * speed;
      return {
        id: Math.random(),
        x, y,
        vx: Math.cos(angle) * vel,
        vy: Math.sin(angle) * vel,
        size: size * (0.5 + Math.random() * 0.5),
        color,
        life,
        maxLife: life,
        gravity,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
      };
    });
    setParticles(prev => [...prev, ...newParticles]);
  }, []);

  // Spawn floating text with logarithmic size scaling for damage numbers
  const spawnFloatingText = useCallback((x, y, text, color, size = 14, isCrit = false) => {
    // Logarithmic size scaling: big numbers don't get too huge
    // Parse numeric value from text if it starts with + (gold/damage)
    let finalSize = size;
    const numMatch = text.match(/^\+?(\d+)/);
    if (numMatch) {
      const value = parseInt(numMatch[1]);
      // Scale: base size + log2(value) * 2, capped between 10-28
      finalSize = Math.min(28, Math.max(10, size + Math.log2(Math.max(1, value)) * 1.5));
    }
    setFloatingTexts(prev => [...prev, {
      id: Math.random(),
      x, y,
      text,
      color,
      size: finalSize,
      life: 800,
      maxLife: 800,
      isCrit,
      vx: (Math.random() - 0.5) * 1.5,
      vy: -2.5,
    }]);
  }, []);

  // Spawn announcement
  const announce = useCallback((text, color = theme.gold, duration = 2000) => {
    const id = Math.random();
    setAnnouncements(prev => [...prev, { id, text, color, life: duration, maxLife: duration }]);
  }, []);

  // Screen shake
  const triggerShake = useCallback((intensity = 5) => {
    let count = 0;
    const shake = () => {
      if (count++ < 4) {
        setScreenShake({
          x: (Math.random() - 0.5) * intensity * (1 - count * 0.2),
          y: (Math.random() - 0.5) * intensity * (1 - count * 0.2),
        });
        setTimeout(shake, 40);
      } else {
        setScreenShake({ x: 0, y: 0 });
      }
    };
    shake();
  }, []);

  // Play sound helper
  const playSound = useCallback((sfxFn) => {
    if (soundEnabled && sfxFn) {
      try { sfxFn(); } catch (e) {}
    }
  }, [soundEnabled]);

  // Screen flash effect
  const triggerFlash = useCallback((color, duration = 200) => {
    setScreenFlash({ color, opacity: 0.6 });
    setTimeout(() => setScreenFlash({ color, opacity: 0.3 }), duration / 3);
    setTimeout(() => setScreenFlash({ color, opacity: 0.1 }), duration * 2 / 3);
    setTimeout(() => setScreenFlash(null), duration);
  }, []);

  // Slowmo effect
  const triggerSlowMo = useCallback((factor = 0.2, duration = 500) => {
    setSlowMo(factor);
    setTimeout(() => setSlowMo(1), duration);
  }, []);

  // Spawn confetti for wave complete
  const spawnConfetti = useCallback((count = 50) => {
    const colors = [theme.gold, theme.success, theme.accent, '#ff6b6b', '#4ecdc4', '#ffe66d'];
    const newConfetti = Array(count).fill(null).map(() => ({
      id: Math.random(),
      x: gridWidth / 2 + (Math.random() - 0.5) * gridWidth * 0.8,
      y: -20,
      vx: (Math.random() - 0.5) * 8,
      vy: Math.random() * 3 + 2,
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 20,
      color: colors[Math.floor(Math.random() * colors.length)],
      size: 4 + Math.random() * 6,
      life: 2000 + Math.random() * 1000,
    }));
    setConfetti(prev => [...prev, ...newConfetti]);
  }, []);

  // Active abilities
  const useBombAbility = useCallback(() => {
    if (abilities.bomb.cooldown > 0 || gold < abilities.bomb.cost) return;

    setGold(g => g - abilities.bomb.cost);
    playSound(SFX.abilityBomb);
    triggerShake(20);
    triggerFlash('#ff4757', 300);

    // Damage all enemies
    setEnemies(enemies => enemies.map(e => {
      const damage = Math.floor(e.maxHealth * 0.25); // 25% max HP damage
      spawnParticles(e.x, e.y, theme.fire, 8, { speed: 5, size: 5, life: 400 });
      return { ...e, currentHealth: e.currentHealth - damage, hitFlash: 1 };
    }));

    setAbilities(prev => ({ ...prev, bomb: { ...prev.bomb, cooldown: prev.bomb.maxCooldown, ready: false } }));
    announce('ðŸ’£ BOMB!', theme.fire, 1500);
  }, [abilities, gold, playSound, triggerShake, triggerFlash, spawnParticles, announce]);

  const useFreezeAbility = useCallback(() => {
    if (abilities.freeze.cooldown > 0 || gold < abilities.freeze.cost) return;

    setGold(g => g - abilities.freeze.cost);
    playSound(SFX.abilityFreeze);
    triggerFlash(theme.frost, 400);

    // Freeze all enemies
    const now = Date.now();
    setEnemies(enemies => enemies.map(e => {
      spawnParticles(e.x, e.y, theme.frost, 5, { speed: 2, size: 4, life: 500 });
      return { ...e, slowedUntil: now + 5000, slowAmount: 0.1 }; // 90% slow for 5 seconds
    }));

    setAbilities(prev => ({ ...prev, freeze: { ...prev.freeze, cooldown: prev.freeze.maxCooldown, ready: false } }));
    announce('â„ï¸ FREEZE!', theme.frost, 1500);
  }, [abilities, gold, playSound, triggerFlash, spawnParticles, announce]);

  // Tower placement
  const canPlaceTower = useCallback((row, col) => {
    if (grid[row][col] !== null) return false;
    if (row === START.row && col === START.col) return false;
    if (row === END.row && col === END.col) return false;
    const testGrid = grid.map(r => [...r]);
    testGrid[row][col] = 'tower';
    return findPath(testGrid) !== null;
  }, [grid, findPath]);

  // PERF: Pre-compute placeable cells once when grid changes (avoids 225 BFS calls per render)
  const placeableCells = useMemo(() => {
    const placeable = new Set();
    for (let row = 0; row < GRID_SIZE; row++) {
      for (let col = 0; col < GRID_SIZE; col++) {
        if (grid[row][col] !== null) continue;
        if (row === START.row && col === START.col) continue;
        if (row === END.row && col === END.col) continue;
        const testGrid = grid.map(r => [...r]);
        testGrid[row][col] = 'tower';
        if (findPath(testGrid) !== null) {
          placeable.add(`${row},${col}`);
        }
      }
    }
    return placeable;
  }, [grid, findPath]);

  // Fast check using pre-computed cache
  const canPlaceTowerFast = useCallback((row, col) => {
    return placeableCells.has(`${row},${col}`);
  }, [placeableCells]);

  // PERF: Pre-compute path cells Set for O(1) lookup instead of O(n) path.some() per cell
  const pathCellsSet = useMemo(() => {
    const pathSet = new Set();
    for (const p of path) {
      pathSet.add(`${p.row},${p.col}`);
    }
    return pathSet;
  }, [path]);

  // PERF: Pre-compute tower positions Map for O(1) lookup instead of O(n) towers.find() per cell
  const towersByPosition = useMemo(() => {
    const towerMap = new Map();
    for (const tower of towers) {
      towerMap.set(`${tower.row},${tower.col}`, tower);
    }
    return towerMap;
  }, [towers]);

  const placeTower = useCallback((row, col, towerType) => {
    if (!canPlaceTower(row, col)) return false;
    const towerDef = towerTypes[towerType];
    if (gold < towerDef.cost) return false;

    const newTower = {
      id: Date.now(),
      row, col,
      type: towerType,
      ...towerDef,
      lastFired: 0,
      level: 0,
      totalDamage: 0,
      kills: 0,
      xpLevel: 0, // XP from kills, grants +2% damage per level
      targetingMode: 'first', // first, last, strongest, weakest, closest
      rotation: 0, // Tower rotation angle toward target
      beamTarget: null,
      beamDamageAccum: 0,
      pulsePhase: 0,
    };

    setTowers(prev => [...prev, newTower]);
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[row][col] = 'tower';
      return newGrid;
    });
    setGold(prev => prev - towerDef.cost);
    setSelectedTower(null);

    const cx = col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
    const cy = row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
    spawnParticles(cx, cy, towerDef.color, 12, { speed: 4, size: 5, life: 400 });
    playSound(SFX.place);

    const newGrid = grid.map(r => [...r]);
    newGrid[row][col] = 'tower';
    setPath(findPath(newGrid) || []);
    return true;
  }, [canPlaceTower, gold, grid, findPath, spawnParticles, playSound, CELL_SIZE]);

  const sellTower = useCallback((towerId) => {
    const tower = towers.find(t => t.id === towerId);
    if (!tower) return;

    const baseCost = towerTypes[tower.type].cost;
    const upgradeCost = towerTypes[tower.type].upgrades.slice(0, tower.level).reduce((sum, u) => sum + u.cost, 0);
    const sellValue = Math.floor((baseCost + upgradeCost) * 0.6);

    setTowers(prev => prev.filter(t => t.id !== towerId));
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[tower.row][tower.col] = null;
      return newGrid;
    });
    setGold(prev => prev + sellValue);
    setSelectedTowerForUpgrade(null);

    const cx = tower.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
    const cy = tower.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
    spawnParticles(cx, cy, theme.gold, 10, { speed: 3, life: 600 });
    spawnFloatingText(cx, cy, `+${sellValue}`, theme.gold, 16);
    playSound(SFX.sell);

    const newGrid = grid.map(r => [...r]);
    newGrid[tower.row][tower.col] = null;
    setPath(findPath(newGrid) || []);
  }, [towers, grid, findPath, spawnParticles, spawnFloatingText, playSound, CELL_SIZE]);

  const upgradeTower = useCallback((towerId) => {
    setTowers(prev => prev.map(tower => {
      if (tower.id !== towerId) return tower;
      const upgrades = towerTypes[tower.type].upgrades;
      if (tower.level >= upgrades.length) return tower;

      const upgrade = upgrades[tower.level];
      if (gold < upgrade.cost) return tower;

      setGold(g => g - upgrade.cost);

      const cx = tower.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
      const cy = tower.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
      spawnParticles(cx, cy, theme.gold, 15, { speed: 5, size: 6, life: 500 });
      announce(`${tower.name} â†’ ${upgrade.name}!`, tower.color, 1500);
      playSound(SFX.upgrade);

      return { ...tower, ...upgrade, level: tower.level + 1 };
    }));
  }, [gold, spawnParticles, announce, playSound, CELL_SIZE]);

  // Enemy spawning with world-based scaling
  const spawnEnemy = useCallback((type, pathOffset = 0) => {
    // Check if this is a world boss
    const isWorldBoss = bossDefs[type] !== undefined;
    const enemyDef = isWorldBoss ? bossDefs[type] : enemyTypes[type];

    if (!enemyDef) {
      console.warn('Unknown enemy type:', type);
      return;
    }

    // World-based difficulty scaling
    const worldMult = 1 + currentWorld * 0.4;
    const waveMult = 1 + (wave - 1) * 0.15;
    const baseMultiplier = worldMult * waveMult;

    // Boss scaling is more aggressive
    const healthMultiplier = isWorldBoss
      ? baseMultiplier * 2 * (1 + currentWorld * 0.3)
      : baseMultiplier;

    // Small random offset to prevent stacking
    const offsetX = (Math.random() - 0.5) * CELL_SIZE * 0.2;
    const offsetY = -pathOffset * CELL_SIZE * 0.3;

    // Apply world-specific enemy resistances
    const world = worldDefs[currentWorld];
    const worldResists = world.enemyResists || {};
    const mergedResist = { ...(enemyDef.resist || {}), ...worldResists };

    const newEnemy = {
      id: Date.now() + Math.random(),
      type,
      name: enemyDef.name,
      emoji: enemyDef.emoji,
      color: enemyDef.color,
      speed: enemyDef.speed,
      reward: Math.floor((enemyDef.reward || 5) * worldMult),
      size: enemyDef.size || 1,
      resist: mergedResist,
      heals: enemyDef.heals,
      splits: enemyDef.splits,
      isBoss: isWorldBoss,
      health: Math.floor(enemyDef.health * healthMultiplier),
      maxHealth: Math.floor(enemyDef.health * healthMultiplier),
      currentHealth: Math.floor(enemyDef.health * healthMultiplier),
      currentShield: enemyDef.shield ? Math.floor(enemyDef.shield * healthMultiplier) : 0,
      maxShield: enemyDef.shield ? Math.floor(enemyDef.shield * healthMultiplier) : 0,
      pathIndex: 0,
      x: START.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + offsetX,
      y: START.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + offsetY,
      slowedUntil: 0,
      slowAmount: 1,
      poisonedUntil: 0,
      poisonDamage: 0,
      animPhase: Math.random() * Math.PI * 2,
      hitFlash: 0,
      rotation: 0,
      lastHealTime: 0,
      // Special boss properties
      resurrects: enemyDef.resurrects || 0,
      // Invisible gimmick (World 6 or Chaos): Some enemies start invisible
      invisible: enemyDef.invisible ||
        ((world.gimmick === 'invisible' || (world.gimmick === 'chaos' && chaosGimmickRef.current === 'invisible')) && Math.random() < 0.4),
    };
    setEnemies(prev => [...prev, newEnemy]);
  }, [wave, currentWorld, CELL_SIZE]);

  // Generate wave using world-specific enemy types
  // Each world has 10 waves, wave 10 is boss wave
  const generateWaveEnemies = useCallback((waveNum, worldId = currentWorld) => {
    const world = worldDefs[worldId];
    const enemies = [];

    // Global difficulty multiplier based on world
    const worldMult = 1 + worldId * 0.3;

    // Wave 10 is BOSS WAVE
    const isBossWave = waveNum === 10;

    if (isBossWave) {
      // Boss wave: spawn the world boss + supporting enemies
      enemies.push(world.bossType);
      // Add some support enemies
      const supportCount = 5 + worldId * 2;
      for (let i = 0; i < supportCount; i++) {
        enemies.push(world.enemyTypes[Math.floor(Math.random() * world.enemyTypes.length)]);
      }
    } else {
      // Normal wave: use world-specific enemy types
      const baseCount = Math.floor((5 + waveNum * 1.5) * worldMult);
      const availableTypes = world.enemyTypes;

      // Primary enemy type (most common for this world)
      const primaryCount = Math.floor(baseCount * 0.6);
      for (let i = 0; i < primaryCount; i++) {
        enemies.push(availableTypes[0]);
      }

      // Secondary types unlock as wave progresses
      if (waveNum >= 2 && availableTypes.length > 1) {
        const secondaryCount = Math.floor(baseCount * 0.25);
        for (let i = 0; i < secondaryCount; i++) {
          enemies.push(availableTypes[1]);
        }
      }

      // Tertiary types in later waves
      if (waveNum >= 4 && availableTypes.length > 2) {
        const tertiaryCount = Math.floor(baseCount * 0.15);
        for (let i = 0; i < tertiaryCount; i++) {
          enemies.push(availableTypes[Math.floor(Math.random() * (availableTypes.length - 2)) + 2]);
        }
      }

      // Mini-boss on wave 5
      if (waveNum === 5) {
        enemies.push('tank');
      }

      // More variety in later waves
      if (waveNum >= 7) {
        for (let i = 0; i < Math.floor(waveNum / 3); i++) {
          enemies.push(availableTypes[Math.floor(Math.random() * availableTypes.length)]);
        }
      }
    }

    // Shuffle the enemies (except boss stays at end)
    const boss = isBossWave ? enemies.shift() : null;
    for (let i = enemies.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [enemies[i], enemies[j]] = [enemies[j], enemies[i]];
    }
    if (boss) enemies.push(boss); // Boss spawns last

    return enemies;
  }, [currentWorld]);

  const startWave = useCallback(() => {
    if (waveInProgress) return;
    setWaveInProgress(true);
    setEnemiesSpawned(0);

    // Early start bonus - get gold for remaining countdown time
    if (waveCountdown > 0 && wave > 1) {
      const earlyBonus = Math.floor(waveCountdown / 1000) * 2; // 2 gold per second remaining
      if (earlyBonus > 0) {
        setGold(g => g + earlyBonus);
        announce(`â±ï¸ Early Start! +${earlyBonus}ðŸ’°`, theme.gold, 1500);
      }
    }
    setWaveCountdown(0);

    const waveEnemies = generateWaveEnemies(wave, currentWorld);
    setWaveEnemyList(waveEnemies);
    setTotalEnemiesInWave(waveEnemies.length);

    const world = worldDefs[currentWorld];

    // Chaos gimmick (World 10): Pick random gimmick each wave
    if (world.gimmick === 'chaos') {
      const possibleGimmicks = ['sandstorm', 'blizzard', 'fog', 'lava', 'invisible', 'lightning', 'resurrect', 'timewarp'];
      chaosGimmickRef.current = possibleGimmicks[Math.floor(Math.random() * possibleGimmicks.length)];
      const gimmickEmojis = {
        sandstorm: 'ðŸŒªï¸', blizzard: 'â„ï¸', fog: 'ðŸŒ«ï¸', lava: 'ðŸŒ‹',
        invisible: 'ðŸ‘»', lightning: 'âš¡', resurrect: 'ðŸ’€', timewarp: 'â°'
      };
      announce(`ðŸŽ² CHAOS: ${gimmickEmojis[chaosGimmickRef.current]} ${chaosGimmickRef.current.toUpperCase()}!`, '#9400d3', 2500);
    }

    // Wave 10 is BOSS WAVE
    if (wave === 10) {
      const boss = bossDefs[world.bossType];
      announce(`âš ï¸ BOSS: ${boss.emoji} ${boss.name}!`, world.color, 3000);
      triggerShake(12);
      playSound(SFX.bossWarning);
    } else if (wave === 5) {
      // Mini-boss on wave 5
      announce(`âš ï¸ Wave ${wave} - Stronger Enemies!`, theme.gold, 2000);
      playSound(SFX.waveStart);
    } else {
      announce(`Wave ${wave}/10`, world.color, 1500);
      playSound(SFX.waveStart);
    }

    let spawnIndex = 0;
    // Spawn rate scales with world and wave
    const spawnDelay = Math.max(150, 600 - wave * 20 - currentWorld * 15);

    spawnTimerRef.current = setInterval(() => {
      if (spawnIndex < waveEnemies.length) {
        spawnEnemy(waveEnemies[spawnIndex], spawnIndex % 3);
        spawnIndex++;
        setEnemiesSpawned(spawnIndex);
      } else {
        clearInterval(spawnTimerRef.current);
      }
    }, spawnDelay);
  }, [wave, waveInProgress, currentWorld, spawnEnemy, generateWaveEnemies, announce, triggerShake]);

  // Main game loop
  useEffect(() => {
    if (gameState !== 'playing') return;

    let animationId;
    let lastTime = performance.now();

    const tick = (currentTime) => {
      const deltaTime = Math.min(currentTime - lastTime, 50) * gameSpeed * slowMo;
      const actualDelta = currentTime - lastTime;
      lastTime = currentTime;
      const now = Date.now();

      // FPS tracking for performance throttling
      if (actualDelta > 0) {
        const fps = 1000 / actualDelta;
        fpsHistoryRef.current.push(fps);
        if (fpsHistoryRef.current.length > 30) fpsHistoryRef.current.shift();
        const avgFps = fpsHistoryRef.current.reduce((a, b) => a + b, 0) / fpsHistoryRef.current.length;
        setCurrentFps(Math.round(avgFps));
      }

      // Gimmick cycle logic (sandstorm, blizzard, etc.)
      const world = worldDefs[currentWorld];
      // For chaos world, use the randomly selected gimmick for this wave
      const effectiveGimmick = world.gimmick === 'chaos' ? chaosGimmickRef.current : world.gimmick;

      const GIMMICK_CYCLE = 20000; // 20 seconds full cycle
      const GIMMICK_ACTIVE_DURATION = 5000; // Active for 5 seconds
      gimmickTimerRef.current = (gimmickTimerRef.current + deltaTime) % GIMMICK_CYCLE;
      const wasActive = gimmickActiveRef.current;
      gimmickActiveRef.current = gimmickTimerRef.current < GIMMICK_ACTIVE_DURATION;

      // Announce when gimmick activates
      if (!wasActive && gimmickActiveRef.current && effectiveGimmick) {
        if (effectiveGimmick === 'sandstorm') {
          announce('ðŸŒªï¸ SANDSTORM!', '#d4a574', 2000);
          playSound(SFX.freeze); // Use existing sound
        } else if (effectiveGimmick === 'blizzard') {
          announce('â„ï¸ BLIZZARD!', '#70c9ff', 2000);
          playSound(SFX.freeze);
        }
        setActiveGimmick(effectiveGimmick);
      } else if (wasActive && !gimmickActiveRef.current && effectiveGimmick) {
        setActiveGimmick(null);
      }

      // Lightning gimmick (World 7): Random strikes every 3-5 seconds
      if (effectiveGimmick === 'lightning' && Math.random() < deltaTime / 4000) {
        const strikeCol = Math.floor(Math.random() * GRID_COLS);
        const strikeRow = Math.floor(Math.random() * GRID_ROWS);
        const strikeX = strikeCol * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
        const strikeY = strikeRow * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;

        // Damage enemies near strike
        setEnemies(prev => prev.map(enemy => {
          const dx = enemy.x - strikeX;
          const dy = enemy.y - strikeY;
          if (dx * dx + dy * dy < CELL_SIZE * CELL_SIZE * 4) {
            enemy.currentHealth -= 30;
            enemy.hitFlash = 1;
          }
          return enemy;
        }));

        // Disable towers near strike temporarily
        setTowers(prev => prev.map(tower => {
          if (tower.col === strikeCol && tower.row === strikeRow) {
            tower.disabledUntil = Date.now() + 2000;
          }
          return tower;
        }));

        spawnParticles(strikeX, strikeY, '#fff200', 20, { speed: 8, size: 6, life: 300 });
        triggerFlash('#fff200', 100);
        playSound(SFX.crit);
      }

      // Lava Eruption gimmick (World 5): Random tile erupts periodically
      if (effectiveGimmick === 'lava' && Math.random() < deltaTime / 5000) {
        const eruptCol = Math.floor(Math.random() * GRID_COLS);
        const eruptRow = Math.floor(Math.random() * GRID_ROWS);
        const eruptX = eruptCol * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
        const eruptY = eruptRow * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;

        // Disable towers on erupted tile
        setTowers(prev => prev.map(tower => {
          if (tower.col === eruptCol && tower.row === eruptRow) {
            tower.disabledUntil = Date.now() + 3000;
            spawnFloatingText(eruptX, eruptY - 20, 'ðŸŒ‹ ERUPTION!', '#ff6b35', 12);
          }
          return tower;
        }));

        // Damage enemies on erupted tile
        setEnemies(prev => prev.map(enemy => {
          const dx = enemy.x - eruptX;
          const dy = enemy.y - eruptY;
          if (dx * dx + dy * dy < CELL_SIZE * CELL_SIZE) {
            enemy.currentHealth -= 50;
            enemy.hitFlash = 1;
          }
          return enemy;
        }));

        spawnParticles(eruptX, eruptY, '#ff6b35', 15, { speed: 6, size: 8, life: 500 });
        playSound(SFX.explosion);
      }

      // Update enemies
      setEnemies(prevEnemies => {
        const newEnemies = [];
        const enemiesToSpawn = [];

        for (const enemy of prevEnemies) {
          // Check if enemy has completed the path
          const pathLength = pathRef.current.length;
          const endX = END.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
          const endY = END.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
          const distToEnd = Math.sqrt((enemy.x - endX) ** 2 + (enemy.y - endY) ** 2);

          // Remove enemy if they reached the end (either by pathIndex or by position)
          if (enemy.pathIndex >= pathLength || (pathLength > 0 && enemy.pathIndex >= pathLength - 1 && distToEnd < CELL_SIZE * 0.5)) {
            setLives(l => {
              const damage = enemy.isBoss ? 5 : 1;
              const newLives = l - damage;
              if (newLives <= 0) {
                // Save progression when game ends
                ProgressionStorage.recordGame(killCount);
                setProgression(ProgressionStorage.load());
                // In single session mode, track partial results and end session
                if (singleSessionMode) {
                  setSessionResults(prev => ({
                    ...prev,
                    totalStars: prev.totalStars + (wave - 1), // Stars = waves completed before death
                    totalKills: killCount,
                    outcome: 'defeat',
                  }));
                }
                setGameState('lost');
              }
              return Math.max(0, newLives);
            });
            setLastDamageTime(now);
            triggerShake(12);
            triggerFlash(theme.error, 200);
            playSound(SFX.lifeLost);
            announce(`-${enemy.isBoss ? 5 : 1} â¤ï¸`, theme.error, 1000);
            continue;
          }

          // Poison tick
          if (enemy.poisonedUntil > now && enemy.poisonDamage > 0) {
            const poisonTick = enemy.poisonDamage * deltaTime / 1000;
            enemy.currentHealth -= poisonTick;
            if (Math.random() < 0.08) {
              spawnParticles(enemy.x, enemy.y, theme.poison, 2, { speed: 1, size: 3, life: 300 });
            }
          }

          // Healer - PERF: Use squared distance and early exit
          if (enemy.heals && now - enemy.lastHealTime > 2000) {
            const healRangeSq = (CELL_SIZE * 2) * (CELL_SIZE * 2); // Pre-compute squared range
            const newHealBeams = [];
            for (const other of prevEnemies) {
              if (other.id !== enemy.id) {
                const dx = other.x - enemy.x;
                // PERF: Early exit if X distance alone exceeds range
                if (dx * dx > healRangeSq) continue;
                const dy = other.y - enemy.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < healRangeSq && other.currentHealth < other.maxHealth) {
                  other.currentHealth = Math.min(other.maxHealth, other.currentHealth + 10);
                  spawnParticles(other.x, other.y, theme.success, 3, { speed: 2, size: 3, life: 400 });
                  // Add heal beam visualization
                  newHealBeams.push({
                    id: Math.random(),
                    fromX: enemy.x, fromY: enemy.y,
                    toX: other.x, toY: other.y,
                    life: 400,
                  });
                }
              }
            }
            if (newHealBeams.length > 0) {
              setHealerBeams(prev => [...prev, ...newHealBeams]);
            }
            enemy.lastHealTime = now;
          }

          // Hit flash decay
          if (enemy.hitFlash > 0) enemy.hitFlash -= deltaTime * 0.01;

          // Death (or Resurrect for World 8)
          if (enemy.currentHealth <= 0) {
            // Check for resurrect (World 8 gimmick, chaos, or boss ability)
            const canResurrect = (effectiveGimmick === 'resurrect' || enemy.resurrects > 0) && !enemy.hasResurrected;

            if (canResurrect) {
              // Resurrect at 50% HP
              enemy.currentHealth = Math.floor(enemy.maxHealth * 0.5);
              enemy.hasResurrected = true;
              enemy.hitFlash = 1;
              spawnParticles(enemy.x, enemy.y, '#8b008b', 12, { speed: 3, size: 5, life: 500 });
              spawnFloatingText(enemy.x, enemy.y - 15, 'ðŸ‘» RISEN!', '#8b008b', 14);
              playSound(SFX.bossWarning);
              newEnemies.push(enemy);
              continue;
            }

            const comboBonus = Math.floor(enemy.reward * combo * 0.1);
            const totalReward = enemy.reward + comboBonus;
            setGold(g => g + totalReward);
            setTotalScore(s => s + totalReward * 10);
            setKillCount(k => k + 1);
            setTotalDamageDealt(d => d + enemy.maxHealth);

            const newCombo = Math.min(combo + 1, 50);
            setCombo(newCombo);
            setMaxCombo(m => Math.max(m, newCombo));
            setComboTimer(3000);

            // Kill streak announcements
            if (newCombo === 5) announce('ðŸ”¥ KILLING SPREE!', '#ff9500', 1500);
            else if (newCombo === 10) announce('âš¡ RAMPAGE!', '#ff6b00', 1500);
            else if (newCombo === 20) announce('ðŸ’€ UNSTOPPABLE!', '#ff0000', 2000);
            else if (newCombo === 50) announce('ðŸ‘‘ GODLIKE!', theme.gold, 3000);

            // Death pop animation - add to dying enemies list
            setDyingEnemies(prev => [...prev, {
              ...enemy,
              deathTime: now,
              deathDuration: enemy.isBoss ? 400 : 200,
            }]);

            spawnParticles(enemy.x, enemy.y, enemy.color, 15, { speed: 4, size: 6, life: 600 });
            playSound(enemy.isBoss ? SFX.bossDeath : SFX.enemyDeath);
            playSound(SFX.goldPickup);

            // Spawn death crater mark
            setDeathMarks(prev => [...prev.slice(-30), { // Keep only last 30 marks
              id: Math.random(),
              x: enemy.x, y: enemy.y,
              color: enemy.color,
              size: enemy.isBoss ? 25 : 12,
              life: enemy.isBoss ? 15000 : 8000, // Boss marks last longer
            }]);

            if (enemy.isBoss) {
              spawnParticles(enemy.x, enemy.y, theme.gold, 25, { speed: 6, size: 8, life: 800 });
              triggerShake(15);
              triggerSlowMo(0.2, 600); // Slowmo on boss kill
              triggerFlash(theme.gold, 300); // Screen flash
              announce(enemy.type === 'megaBoss' ? 'ðŸ‘¹ TITAN SLAIN!' : 'ðŸ‰ BOSS DEFEATED!', theme.gold, 2500);
            }

            const textColor = comboBonus > 0 ? theme.gold : theme.success;
            spawnFloatingText(enemy.x, enemy.y - 10, `+${totalReward}`, textColor, comboBonus > 0 ? 18 : 14);

            if (enemy.splits) {
              for (let i = 0; i < enemy.splits; i++) {
                enemiesToSpawn.push({
                  type: 'swarm',
                  x: enemy.x + (Math.random() - 0.5) * 20,
                  y: enemy.y + (Math.random() - 0.5) * 20,
                  pathIndex: enemy.pathIndex,
                });
              }
            }
            continue;
          }

          // Movement
          const target = pathRef.current[enemy.pathIndex];
          if (target) {
            const targetX = target.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
            const targetY = target.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
            const dx = targetX - enemy.x;
            const dy = targetY - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            let speed = enemy.speed * (deltaTime / 16);
            if (enemy.slowedUntil > now) speed *= enemy.slowAmount;

            // Time Warp gimmick (World 9): Speed zones on path - every 3rd tile is a speed zone
            if (effectiveGimmick === 'timewarp' && enemy.pathIndex % 3 === 0) {
              speed *= 2; // Double speed in warp zones
              enemy.inSpeedZone = true;
            } else {
              enemy.inSpeedZone = false;
            }

            // Fog Zones gimmick (World 4): Every 4th tile heals enemies
            if (effectiveGimmick === 'fog' && enemy.pathIndex % 4 === 1) {
              const healAmount = enemy.maxHealth * 0.005 * (deltaTime / 16); // 0.5% max HP per frame
              enemy.currentHealth = Math.min(enemy.maxHealth, enemy.currentHealth + healAmount);
              enemy.inFogZone = true;
              if (Math.random() < 0.05) {
                spawnParticles(enemy.x, enemy.y, '#50c878', 2, { speed: 1, size: 4, life: 400 });
              }
            } else {
              enemy.inFogZone = false;
            }

            enemy.rotation = Math.atan2(dy, dx);

            // Use a reasonable threshold based on cell size for path advancement
            const advanceThreshold = Math.max(speed * 2, CELL_SIZE * 0.15);
            if (dist < advanceThreshold) {
              enemy.pathIndex++;
              // Snap to center when advancing to prevent drift
              enemy.x = targetX;
              enemy.y = targetY;
            } else {
              enemy.x += (dx / dist) * speed * 2;
              enemy.y += (dy / dist) * speed * 2;
            }
          }

          enemy.animPhase += deltaTime * 0.008;
          newEnemies.push(enemy);
        }

        // Spawn split enemies
        for (const spawn of enemiesToSpawn) {
          const enemyDef = enemyTypes[spawn.type];
          newEnemies.push({
            id: Date.now() + Math.random(),
            type: spawn.type,
            ...enemyDef,
            health: enemyDef.health,
            maxHealth: enemyDef.health,
            currentHealth: enemyDef.health,
            currentShield: 0,
            maxShield: 0,
            pathIndex: spawn.pathIndex,
            x: spawn.x,
            y: spawn.y,
            slowedUntil: 0,
            slowAmount: 1,
            poisonedUntil: 0,
            poisonDamage: 0,
            animPhase: Math.random() * Math.PI * 2,
            hitFlash: 0,
            rotation: 0,
            lastHealTime: 0,
          });
        }

        return newEnemies;
      });

      // Update towers
      setTowers(prevTowers => {
        // Gimmick modifiers for towers (use effectiveGimmick for chaos world support)
        const rangeMultiplier = (gimmickActiveRef.current && effectiveGimmick === 'sandstorm') ? 0.6 : 1;
        const attackSpeedMultiplier = (gimmickActiveRef.current && effectiveGimmick === 'blizzard') ? 1.6 : 1;

        return prevTowers.map(tower => {
          const towerX = tower.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
          const towerY = tower.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
          tower.pulsePhase = (tower.pulsePhase || 0) + deltaTime * 0.005;
          // Decay recoil animation
          if (tower.recoil > 0) tower.recoil = Math.max(0, tower.recoil - deltaTime * 0.015);

          // Skip disabled towers (from lightning/lava gimmicks)
          if (tower.disabledUntil && tower.disabledUntil > now) {
            tower.beamTarget = null; // Stop beam if disabled
            return tower;
          }

          // Beam tower - PERF: Use squared distance to avoid sqrt
          if (tower.beam) {
            let target = null;
            let minDistSq = Infinity;
            const effectiveRange = tower.range * rangeMultiplier;
            const rangeSq = (effectiveRange * CELL_SIZE) * (effectiveRange * CELL_SIZE);

            for (const enemy of enemiesRef.current) {
              const dx = enemy.x - towerX;
              const dy = enemy.y - towerY;
              const distSq = dx * dx + dy * dy;
              if (distSq <= rangeSq && distSq < minDistSq) {
                // Invisible enemies: beam can reveal them at close range
                const revealRangeSq = CELL_SIZE * CELL_SIZE * 1.5;
                if (enemy.invisible && distSq > revealRangeSq) continue;
                if (enemy.invisible && distSq <= revealRangeSq) {
                  enemy.invisible = false;
                  spawnFloatingText(enemy.x, enemy.y - 15, 'ðŸ‘ï¸ REVEALED!', '#ff69b4', 12);
                }
                target = enemy;
                minDistSq = distSq;
              }
            }

            if (target) {
              tower.beamTarget = { x: target.x, y: target.y, id: target.id };
              // Apply blizzard slowdown to beam towers
              tower.beamDamageAccum += (tower.damage * deltaTime / 16) / attackSpeedMultiplier;

              if (tower.beamDamageAccum >= 1) {
                const damage = Math.floor(tower.beamDamageAccum);
                tower.beamDamageAccum -= damage;

                // PERF: Collect beam damage to apply in batch instead of calling setEnemies per tower
                beamDamageRef.current.push({
                  targetId: target.id,
                  damage,
                  damageType: tower.damageType,
                  towerId: tower.id,
                });
              }

              if (Math.random() < 0.2) {
                spawnParticles(target.x, target.y, tower.color, 1, { speed: 1, size: 3, life: 200 });
              }
            } else {
              tower.beamTarget = null;
            }
            return tower;
          }

          // Regular tower
          const effectiveFireRate = tower.fireRate * attackSpeedMultiplier;
          if (now - tower.lastFired < effectiveFireRate) return tower;

          // Calculate XP level from kills: every 10 kills = 1 level (capped at level 10)
          const xpLevel = Math.min(10, Math.floor(tower.kills / 10));
          tower.xpLevel = xpLevel;

          // Targeting mode logic - PERF: Use squared distance for range check
          let target = null;
          let bestValue = tower.targetingMode === 'first' || tower.targetingMode === 'strongest' ? -Infinity : Infinity;
          const enemiesInRange = [];
          const effectiveRange = tower.range * rangeMultiplier;
          const rangeSq = (effectiveRange * CELL_SIZE) * (effectiveRange * CELL_SIZE);

          for (const enemy of enemiesRef.current) {
            const dx = enemy.x - towerX;
            const dy = enemy.y - towerY;
            const distSq = dx * dx + dy * dy;
            if (distSq <= rangeSq) {
              // Invisible enemies: reveal when very close (1 cell), skip otherwise
              const revealRangeSq = CELL_SIZE * CELL_SIZE * 1.5;
              if (enemy.invisible && distSq > revealRangeSq) continue;
              if (enemy.invisible && distSq <= revealRangeSq) {
                enemy.invisible = false; // Revealed!
                spawnFloatingText(enemy.x, enemy.y - 15, 'ðŸ‘ï¸ REVEALED!', '#ff69b4', 12);
              }
              // Only compute sqrt for 'closest' mode, otherwise store squared
              const dist = tower.targetingMode === 'closest' ? Math.sqrt(distSq) : distSq;
              enemiesInRange.push({ enemy, dist, distSq });
            }
          }

          let targetDistSq = 0;
          for (const { enemy, dist, distSq } of enemiesInRange) {
            let value;
            let selected = false;
            switch (tower.targetingMode) {
              case 'first': value = enemy.pathIndex; if (value > bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'last': value = enemy.pathIndex; if (value < bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'strongest': value = enemy.currentHealth; if (value > bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'weakest': value = enemy.currentHealth; if (value < bestValue) { bestValue = value; target = enemy; selected = true; } break;
              case 'closest': if (dist < bestValue) { bestValue = dist; target = enemy; selected = true; } break;
              default: value = enemy.pathIndex; if (value > bestValue) { bestValue = value; target = enemy; selected = true; }
            }
            if (selected) targetDistSq = distSq;
          }

          // Update tower rotation toward target
          if (target) {
            const targetAngle = Math.atan2(target.y - towerY, target.x - towerX);
            tower.rotation = targetAngle;
          }

          if (target) {
            const isCrit = tower.critChance && Math.random() < tower.critChance;
            // Apply XP bonus: +2% damage per XP level
            const xpBonus = 1 + (xpLevel * 0.02);
            const baseDamage = isCrit ? tower.damage * 2 : tower.damage;
            const damage = Math.floor(baseDamage * xpBonus);

            // Predictive targeting: lead the target based on speed
            // PERF: Use cached squared distance, compute sqrt only when needed
            const dist = Math.sqrt(targetDistSq);
            const projectileSpeed = tower.projectileSpeed || 15;
            const timeToTarget = dist / (projectileSpeed * 2); // Approximate time in frames

            // Calculate target's movement direction from current path
            const targetPath = pathRef.current[target.pathIndex];
            let predictedX = target.x;
            let predictedY = target.y;
            if (targetPath) {
              const pathTargetX = targetPath.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
              const pathTargetY = targetPath.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
              const moveDir = Math.atan2(pathTargetY - target.y, pathTargetX - target.x);
              const effectiveSpeed = target.speed * (target.slowedUntil > now ? target.slowAmount : 1);
              predictedX = target.x + Math.cos(moveDir) * effectiveSpeed * timeToTarget * 2;
              predictedY = target.y + Math.sin(moveDir) * effectiveSpeed * timeToTarget * 2;
            }

            // Check if this is an arcing projectile (cannon)
            const isArcing = tower.splash && tower.projectileSpeed <= 12;

            setProjectiles(p => [...p, {
              id: Date.now() + Math.random(),
              fromX: towerX,
              fromY: towerY,
              toX: predictedX,
              toY: predictedY,
              targetId: target.id,
              damage,
              damageType: tower.damageType || 'physical',
              color: tower.color,
              splash: tower.splash,
              slow: tower.slow,
              slowDuration: tower.slowDuration,
              chain: tower.chain,
              chainDamageDecay: tower.chainDamageDecay || 0.7,
              chainedEnemies: [],
              poisonDamage: tower.poisonDamage,
              poisonDuration: tower.poisonDuration,
              splashPoison: tower.splashPoison,
              progress: 0,
              speed: tower.projectileSpeed || 15,
              size: tower.projectileSize || 5,
              isCrit,
              trail: [],
              towerId: tower.id,
              arcing: isArcing, // Enable arcing for cannon
              arcHeight: isArcing ? Math.min(50, dist * 0.3) : 0, // Arc height based on distance
            }]);

            const angle = Math.atan2(target.y - towerY, target.x - towerX);
            spawnParticles(towerX, towerY, tower.color, 3, { speed: 3, size: 3, life: 120, spread: 0.5, direction: angle });

            // Play tower-specific sound
            const soundMap = {
              arrow: SFX.arrowShoot,
              sniper: SFX.arrowShoot,
              cannon: SFX.cannonShoot,
              frost: SFX.frostShoot,
              lightning: SFX.lightningShoot,
              poison: SFX.poisonShoot,
            };
            playSound(soundMap[tower.type] || SFX.shoot);

            // Return with recoil animation state
            return { ...tower, lastFired: now, recoil: 1 };
          }

          return tower;
        });
      });

      // PERF: Apply batched beam damage in single setEnemies call
      if (beamDamageRef.current.length > 0) {
        const pendingDamage = beamDamageRef.current;
        beamDamageRef.current = [];

        // Pre-calculate damage per enemy and track tower stats (using ref for current enemy state)
        const damageByEnemy = new Map();
        const towerStats = new Map();

        for (const entry of pendingDamage) {
          const enemy = enemiesRef.current.find(e => e.id === entry.targetId);
          if (!enemy) continue;

          const beamResist = enemy.resist?.[entry.damageType] || 0;
          const resistedDamage = Math.floor(entry.damage * (1 - beamResist));

          // Accumulate damage for this enemy
          const current = damageByEnemy.get(entry.targetId) || { damage: 0, entries: [] };
          current.damage += resistedDamage;
          current.entries.push({ towerId: entry.towerId, damage: resistedDamage });
          damageByEnemy.set(entry.targetId, current);
        }

        // Check for kills and track tower stats
        for (const [enemyId, data] of damageByEnemy) {
          const enemy = enemiesRef.current.find(e => e.id === enemyId);
          if (enemy && enemy.currentHealth - data.damage <= 0) {
            // Enemy will die - credit all contributing towers
            for (const { towerId, damage } of data.entries) {
              const stats = towerStats.get(towerId) || { kills: 0, damage: 0 };
              stats.kills++;
              stats.damage += damage;
              towerStats.set(towerId, stats);
            }
          }
        }

        // Apply damage to enemies
        setEnemies(enemies => enemies.map(e => {
          const data = damageByEnemy.get(e.id);
          if (data) {
            return { ...e, currentHealth: e.currentHealth - data.damage, hitFlash: 1 };
          }
          return e;
        }));

        // Update tower stats
        if (towerStats.size > 0) {
          setTowers(prevTowers => prevTowers.map(t => {
            const stats = towerStats.get(t.id);
            if (stats) {
              return { ...t, kills: t.kills + stats.kills, totalDamage: t.totalDamage + stats.damage };
            }
            return t;
          }));
        }
      }

      // Update projectiles
      setProjectiles(prevProjectiles => {
        const newProjectiles = [];

        for (const proj of prevProjectiles) {
          proj.trail.push({ x: proj.fromX + (proj.toX - proj.fromX) * proj.progress, y: proj.fromY + (proj.toY - proj.fromY) * proj.progress });
          if (proj.trail.length > 6) proj.trail.shift();

          proj.progress += (proj.speed / 100) * (deltaTime / 16);

          if (proj.progress >= 1) {
            setEnemies(enemies => {
              return enemies.map(enemy => {
                if (proj.chainedEnemies.includes(enemy.id)) return enemy;

                if (enemy.id === proj.targetId) {
                  // Apply resistance: positive = takes less damage, negative = takes more
                  const resistance = enemy.resist?.[proj.damageType] || 0;
                  const resistMult = 1 - resistance; // 0.3 resist = 0.7x damage, -0.3 weakness = 1.3x
                  let remainingDamage = Math.floor(proj.damage * resistMult);
                  if (enemy.currentShield > 0) {
                    const shieldDamage = Math.min(enemy.currentShield, remainingDamage);
                    enemy.currentShield -= shieldDamage;
                    remainingDamage -= shieldDamage;
                    spawnParticles(enemy.x, enemy.y, '#778ca3', 5, { speed: 3, size: 4, life: 300 });
                  }

                  const newHealth = enemy.currentHealth - remainingDamage;
                  enemy.hitFlash = 1;

                  if (proj.slow) {
                    enemy.slowedUntil = now + proj.slowDuration;
                    // Diminishing returns for slows: 1 - (1-current)*(1-new), capped at 70%
                    const currentSlow = enemy.slowAmount || 0;
                    const newSlow = 1 - (1 - currentSlow) * (1 - proj.slow);
                    enemy.slowAmount = Math.min(0.7, newSlow); // 70% max slow cap
                  }
                  if (proj.poisonDamage) {
                    enemy.poisonedUntil = now + proj.poisonDuration;
                    // Poison damage cap at 3% of max HP per second
                    const maxPoisonDPS = enemy.maxHealth * 0.03;
                    enemy.poisonDamage = Math.min(proj.poisonDamage, maxPoisonDPS);
                  }

                  spawnParticles(enemy.x, enemy.y, proj.color, 5, { speed: 3, size: 4, life: 300 });
                  playSound(SFX.hit);

                  if (proj.isCrit) {
                    spawnFloatingText(enemy.x, enemy.y - 15, 'CRIT!', '#ff0', 16, true);
                    playSound(SFX.crit);
                  }

                  setTowers(towers => towers.map(t => {
                    if (t.id === proj.towerId) {
                      return { ...t, totalDamage: t.totalDamage + proj.damage, kills: newHealth <= 0 ? t.kills + 1 : t.kills };
                    }
                    return t;
                  }));

                  return { ...enemy, currentHealth: newHealth };
                }

                if (proj.splash) {
                  const dx = enemy.x - proj.toX;
                  const dy = enemy.y - proj.toY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist <= proj.splash * CELL_SIZE) {
                    // Apply resistance to splash damage too
                    const splashResist = enemy.resist?.[proj.damageType] || 0;
                    const splashDamage = Math.floor(proj.damage * 0.5 * (1 - splashResist));
                    const newHealth = enemy.currentHealth - splashDamage;
                    enemy.hitFlash = 0.5;

                    if (proj.splashPoison) {
                      enemy.poisonedUntil = now + (proj.poisonDuration || 3000);
                      // Apply same 3% max HP/second cap as direct hits, then halve for splash
                      const maxPoisonDPS = enemy.maxHealth * 0.03;
                      enemy.poisonDamage = Math.min(proj.poisonDamage * 0.5, maxPoisonDPS);
                    }

                    spawnParticles(enemy.x, enemy.y, proj.color, 2, { speed: 2, size: 3, life: 200 });
                    return { ...enemy, currentHealth: newHealth };
                  }
                }

                return enemy;
              }).filter(Boolean);
            });

            if (proj.splash) {
              spawnParticles(proj.toX, proj.toY, proj.color, 15, { speed: 6, size: 7, life: 500 });
              spawnParticles(proj.toX, proj.toY, '#fff', 8, { speed: 4, size: 4, life: 350 });
              playSound(SFX.explosion);
              // Damage-based screenshake: scale from 2-8 based on damage
              const shakeIntensity = Math.min(8, 2 + Math.log2(proj.damage) * 0.8);
              triggerShake(shakeIntensity);
              // Spawn explosion shockwave particle
              setParticles(prev => [...prev, {
                id: Math.random(),
                x: proj.toX, y: proj.toY,
                vx: 0, vy: 0,
                size: proj.splash * CELL_SIZE * 0.5,
                color: proj.color,
                life: 300,
                maxLife: 300,
                gravity: 0,
                rotation: 0,
                rotationSpeed: 0,
                isShockwave: true, // Special rendering flag
              }]);
            }

            // Chain lightning
            if (proj.chain && proj.chain > 0) {
              let lastX = proj.toX;
              let lastY = proj.toY;
              const chainedIds = [proj.targetId];

              for (let i = 0; i < proj.chain; i++) {
                let nearestEnemy = null;
                let nearestDist = CELL_SIZE * 3;

                for (const enemy of enemiesRef.current) {
                  if (chainedIds.includes(enemy.id)) continue;
                  const dx = enemy.x - lastX;
                  const dy = enemy.y - lastY;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                  }
                }

                if (nearestEnemy) {
                  chainedIds.push(nearestEnemy.id);
                  const chainDamage = proj.damage * Math.pow(proj.chainDamageDecay, i + 1);

                  setProjectiles(p => [...p, {
                    id: Date.now() + Math.random(),
                    fromX: lastX,
                    fromY: lastY,
                    toX: nearestEnemy.x,
                    toY: nearestEnemy.y,
                    targetId: nearestEnemy.id,
                    damage: chainDamage,
                    color: proj.color,
                    progress: 0,
                    speed: 50,
                    size: 3,
                    chain: 0,
                    chainedEnemies: chainedIds,
                    trail: [],
                    isChain: true,
                    towerId: proj.towerId,
                  }]);

                  lastX = nearestEnemy.x;
                  lastY = nearestEnemy.y;
                }
              }
            }
            continue;
          }
          newProjectiles.push(proj);
        }
        return newProjectiles;
      });

      // Update particles
      setParticles(prev => prev.map(p => ({
        ...p,
        x: p.x + p.vx * (deltaTime / 16),
        y: p.y + p.vy * (deltaTime / 16) + p.gravity * (deltaTime / 16),
        vy: p.vy + p.gravity * 0.1,
        life: p.life - deltaTime,
        rotation: p.rotation + p.rotationSpeed,
      })).filter(p => p.life > 0));

      // Update floating texts
      setFloatingTexts(prev => prev.map(t => ({
        ...t,
        x: t.x + t.vx * (deltaTime / 16),
        y: t.y + t.vy * (deltaTime / 16),
        vy: t.vy - 0.03,
        life: t.life - deltaTime,
      })).filter(t => t.life > 0));

      // Update announcements
      setAnnouncements(prev => prev.map(a => ({ ...a, life: a.life - deltaTime })).filter(a => a.life > 0));

      // Combo decay
      setComboTimer(prev => {
        const newTimer = prev - deltaTime;
        if (newTimer <= 0) {
          setCombo(0);
          return 0;
        }
        return newTimer;
      });

      // Animated gold counter - smoothly interpolate toward actual gold
      setDisplayGold(prev => {
        const diff = goldRef.current - prev;
        if (Math.abs(diff) < 1) return goldRef.current;
        return prev + diff * 0.15; // Smooth interpolation
      });

      // Wave countdown timer (shows time until early start bonus expires)
      if (!waveInProgress && waveCountdown > 0) {
        setWaveCountdown(prev => Math.max(0, prev - deltaTime));
      }

      // Death marks decay
      setDeathMarks(prev => prev.map(m => ({ ...m, life: m.life - deltaTime })).filter(m => m.life > 0));

      // Animated path flow
      setPathFlowOffset(prev => (prev + deltaTime * 0.02) % 1);

      // Wave complete
      if (waveInProgress && enemiesRef.current.length === 0 && enemiesSpawned >= totalEnemiesInWave && totalEnemiesInWave > 0) {
        setWaveInProgress(false);
        setLastWaveEndTime(now);

        const world = worldDefs[currentWorld];
        const waveBonus = 30 + wave * 10 + currentWorld * 5;
        setGold(g => g + waveBonus);

        // Save star progress
        const earnedNewStar = ProgressionStorage.addStar(currentWorld, wave);
        if (earnedNewStar) {
          setNewStarEarned(true);
          setProgression(ProgressionStorage.load());
        }

        if (wave === 10) {
          // WORLD COMPLETE - Boss defeated!
          const boss = bossDefs[world.bossType];
          announce(`ðŸŽ‰ ${boss.emoji} ${boss.name} DEFEATED!`, world.color, 3000);
          playSound(SFX.bossDeath);
          spawnConfetti(100);
          triggerFlash(theme.gold, 400);
          triggerSlowMo(0.3, 1000);

          // Track session results for single session mode
          if (singleSessionMode) {
            setSessionResults(prev => ({
              ...prev,
              worldsCompleted: [...prev.worldsCompleted, {
                worldId: currentWorld,
                worldName: world.name,
                stars: 10, // Completed all waves = 10 stars
                kills: killCount - prev.totalKills,
              }],
              totalStars: prev.totalStars + 10,
              totalKills: killCount,
            }));
          }

          // Check if next world is unlocked
          const nextWorld = currentWorld + 1;
          if (nextWorld < 10 && ProgressionStorage.isWorldUnlocked(nextWorld)) {
            setTimeout(() => {
              announce(`ðŸ”“ ${worldDefs[nextWorld].emoji} ${worldDefs[nextWorld].name} Unlocked!`, worldDefs[nextWorld].color, 2500);
              playSound(SFX.worldUnlock);
            }, 1500);
          }

          // In single session mode, continue to next world or end
          if (singleSessionMode && nextWorld < 10) {
            setTimeout(() => {
              setCurrentWorld(nextWorld);
              setWave(1);
              setWaveCountdown(15000);
              announce(`âž¡ï¸ World ${nextWorld + 1}: ${worldDefs[nextWorld].emoji} ${worldDefs[nextWorld].name}`, worldDefs[nextWorld].color, 3000);
            }, 3000);
          } else if (singleSessionMode) {
            // Completed all worlds in single session - victory!
            setTimeout(() => {
              endSession('victory');
            }, 2000);
          } else {
            // Not single session - go back to world select after delay
            setTimeout(() => {
              ProgressionStorage.recordGame(killCount);
              goToWorldSelect();
            }, 3000);
          }
        } else {
          // Normal wave complete
          announce(`Wave ${wave}/10 Complete! +${waveBonus}ðŸ’°`, theme.success, 2000);
          playSound(SFX.waveComplete);
          spawnConfetti(40 + wave * 2);
          triggerFlash(theme.success, 250);
          setWaveCountdown(10000);
          setWave(w => w + 1);
        }
      }

      // Update dying enemies animation
      setDyingEnemies(prev => prev.filter(e => now - e.deathTime < e.deathDuration));

      // Update healer beams
      setHealerBeams(prev => prev.map(b => ({ ...b, life: b.life - deltaTime })).filter(b => b.life > 0));

      // Update confetti
      setConfetti(prev => prev.map(c => ({
        ...c,
        x: c.x + c.vx * (deltaTime / 16),
        y: c.y + c.vy * (deltaTime / 16),
        vy: c.vy + 0.1,
        rotation: c.rotation + c.rotationSpeed,
        life: c.life - deltaTime,
      })).filter(c => c.life > 0));

      // Update ability cooldowns
      setAbilities(prev => ({
        bomb: { ...prev.bomb, cooldown: Math.max(0, prev.bomb.cooldown - deltaTime), ready: prev.bomb.cooldown <= deltaTime },
        freeze: { ...prev.freeze, cooldown: Math.max(0, prev.freeze.cooldown - deltaTime), ready: prev.freeze.cooldown <= deltaTime },
      }));

      animationId = requestAnimationFrame(tick);
    };

    animationId = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(animationId);
  }, [gameState, gameSpeed, waveInProgress, enemiesSpawned, totalEnemiesInWave, wave, triggerShake, spawnParticles, spawnFloatingText, announce, CELL_SIZE]);

  useEffect(() => {
    setPath(findPath(grid) || []);
  }, []);

  // Start game with a specific world
  const startGame = (worldId = 0, isSingleSession = false) => {
    const emptyGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    setGrid(emptyGrid);
    setTowers([]);
    setEnemies([]);
    setProjectiles([]);
    setParticles([]);
    setFloatingTexts([]);
    setAnnouncements([]);
    setWave(1);
    setLives(20);
    setGold(100 + worldId * 20); // More starting gold for harder worlds
    setWaveInProgress(false);
    setEnemiesSpawned(0);
    setTotalEnemiesInWave(0);
    setTotalScore(0);
    setCombo(0);
    setMaxCombo(0);
    setComboTimer(0);
    setKillCount(0);
    setTotalDamageDealt(0);
    setSelectedTowerForUpgrade(null);
    setPath(findPath(emptyGrid) || []);
    // Reset new game feel states
    setSlowMo(1);
    setScreenFlash(null);
    setDyingEnemies([]);
    setConfetti([]);
    setHealerBeams([]);
    setAbilities({
      bomb: { cooldown: 0, maxCooldown: 30000, cost: 50, ready: true },
      freeze: { cooldown: 0, maxCooldown: 20000, cost: 30, ready: true },
    });
    // World state
    setCurrentWorld(worldId);
    setSingleSessionMode(isSingleSession);
    setSessionStartWorld(worldId);
    setNewStarEarned(false);
    setActiveGimmick(null);
    // Reset session results for new session
    if (isSingleSession) {
      setSessionResults({
        worldsCompleted: [],
        totalStars: 0,
        totalKills: 0,
        sessionWorld: worldId,
        outcome: null,
      });
    }
    setGameState('playing');

    // Announce world
    const world = worldDefs[worldId];
    setTimeout(() => {
      announce(`${world.emoji} ${world.name}`, world.color, 2000);
      if (world.gimmick) {
        setTimeout(() => announce(world.description, world.color, 2500), 500);
      }
    }, 500);
  };

  // Go to world select screen
  const goToWorldSelect = () => {
    setProgression(ProgressionStorage.load());
    setGameState('select');
    playSound(SFX.worldSelect);
  };

  // End single-session mode and report results
  const endSession = (outcome = 'quit') => {
    const results = {
      ...sessionResults,
      outcome,
      timestamp: Date.now(),
    };

    // Save to localStorage
    ProgressionStorage.recordGame(sessionResults.totalKills);

    // Call the external callback if provided
    if (window.towerDefenseCallback) {
      try {
        const callbackPath = window.towerDefenseCallback.split('.');
        let callback = window;
        for (const part of callbackPath) {
          callback = callback[part];
        }
        if (typeof callback === 'function') {
          callback(results);
        }
      } catch (e) {
        console.warn('Failed to call session callback:', e);
      }
    }

    // Post message for iframe integration
    if (window.parent !== window) {
      window.parent.postMessage({
        type: 'towerDefenseSessionComplete',
        results,
      }, '*');
    }

    // Reset to menu or close
    setGameState('sessionComplete');
  };

  const gridWidth = GRID_SIZE * CELL_SIZE + (GRID_SIZE - 1) * GRID_GAP + GRID_OFFSET * 2 + 4;
  const gridHeight = GRID_SIZE * CELL_SIZE + (GRID_SIZE - 1) * GRID_GAP + GRID_OFFSET * 2 + 4;

  // Wave preview
  const wavePreview = useMemo(() => {
    if (waveInProgress) return null;
    const enemies = generateWaveEnemies(wave);
    const counts = {};
    enemies.forEach(e => { counts[e] = (counts[e] || 0) + 1; });
    return counts;
  }, [wave, waveInProgress, generateWaveEnemies]);

  const styles = `
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');

    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.03); } }
    @keyframes glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.4); } }
    @keyframes slideIn { 0% { transform: translateY(20px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes slideDown { 0% { transform: translateY(-30px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
    @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    @keyframes rainbow { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }
    @keyframes shimmer { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
    @keyframes towerPulse { 0%, 100% { transform: scale(1); filter: brightness(1); } 50% { transform: scale(1.05); filter: brightness(1.1); } }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    * { box-sizing: border-box; font-family: 'Inter', -apple-system, sans-serif; }

    /* Scalable font sizes using clamp() */
    :root {
      --font-xs: clamp(8px, 1.5vw, 10px);
      --font-sm: clamp(10px, 2vw, 12px);
      --font-md: clamp(12px, 2.5vw, 14px);
      --font-lg: clamp(14px, 3vw, 18px);
      --font-xl: clamp(18px, 4vw, 24px);
    }

    .btn {
      cursor: pointer;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-user-select: none;
      min-height: 44px; /* Touch-friendly minimum */
      min-width: 44px;
    }
    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(0) scale(0.98); }

    .tower-card {
      transition: all 0.15s ease;
      cursor: pointer;
      min-height: 44px; /* Touch-friendly minimum */
    }
    .tower-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .tower-card:active { transform: translateY(0) scale(0.98); }

    .cell { transition: all 0.1s ease; }
    .cell:hover { filter: brightness(1.2); }

    /* Touch device improvements */
    @media (hover: none) and (pointer: coarse) {
      .btn:hover, .tower-card:hover, .cell:hover { transform: none; }
    }
  `;

  // PERF: Cache current time for render to avoid multiple Date.now() calls
  const renderTime = Date.now();

  return (
    <div style={{
      width: '100%',
      height: '100%',
      minHeight: '100vh',
      background: `radial-gradient(ellipse at 50% 30%, #181828 0%, #0a0a12 70%)`,
      color: theme.text,
      position: 'relative',
      overflow: 'hidden',
      display: 'flex',
      flexDirection: 'column',
    }}>
      <style>{styles}</style>

      {/* Background pattern */}
      <div style={{
        position: 'fixed',
        inset: 0,
        backgroundImage: `linear-gradient(rgba(124,106,237,0.02) 1px, transparent 1px),
                          linear-gradient(90deg, rgba(124,106,237,0.02) 1px, transparent 1px)`,
        backgroundSize: '40px 40px',
        pointerEvents: 'none',
      }} />

      <div style={{
        position: 'relative',
        zIndex: 5,
        flex: 1,
        display: 'flex',
        flexDirection: 'column',
        padding: '12px',
        transform: `translate(${screenShake.x}px, ${screenShake.y}px)`,
      }}>

        {/* MENU */}
        {gameState === 'menu' && (
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', flex: 1 }}>
            <div style={{ textAlign: 'center', animation: 'slideIn 0.5s ease-out' }}>
              <div style={{ marginBottom: '24px', animation: 'float 3s ease-in-out infinite' }}>
                <div style={{
                  width: 100, height: 100,
                  background: `linear-gradient(135deg, ${theme.accent}30 0%, ${theme.accent}10 100%)`,
                  borderRadius: '24px',
                  display: 'flex', alignItems: 'center', justifyContent: 'center',
                  fontSize: 50,
                  boxShadow: `0 0 40px ${theme.accentGlow}`,
                  border: `2px solid ${theme.accent}`,
                  margin: '0 auto',
                }}>ðŸ°</div>
              </div>
              <h1 style={{
                fontSize: 'clamp(28px, 5vw, 42px)',
                fontWeight: 900,
                marginBottom: '8px',
                background: `linear-gradient(135deg, ${theme.gold} 0%, ${theme.accentBright} 100%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
              }}>TOWER DEFENSE</h1>
              <p style={{ fontSize: '14px', color: theme.textSecondary, marginBottom: '16px' }}>
                10 Worlds â€¢ 100 Stars â€¢ Epic Bosses
              </p>

              {/* Progress summary */}
              <div style={{
                background: theme.bgPanel,
                borderRadius: '10px',
                padding: '12px 24px',
                marginBottom: '24px',
                border: `1px solid ${theme.border}`,
              }}>
                <div style={{ fontSize: '12px', color: theme.textMuted, marginBottom: '4px' }}>TOTAL PROGRESS</div>
                <div style={{ fontSize: '24px', fontWeight: 800, color: theme.gold }}>
                  â­ {progression.totalStars} / 100
                </div>
                <div style={{ fontSize: '11px', color: theme.textSecondary, marginTop: '4px' }}>
                  {progression.gamesPlayed} games â€¢ {progression.totalKills.toLocaleString()} kills
                </div>
              </div>

              <button
                onClick={goToWorldSelect}
                className="btn"
                style={{
                  padding: '14px 48px',
                  fontSize: '16px',
                  fontWeight: 700,
                  background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                  border: 'none',
                  borderRadius: '12px',
                  color: '#fff',
                  boxShadow: `0 4px 20px ${theme.accentGlow}`,
                }}
              >
                SELECT WORLD
              </button>
              <div style={{ marginTop: '24px', fontSize: '12px', color: theme.textMuted }}>
                Complete 10 waves per world to defeat the boss!
              </div>
            </div>
          </div>
        )}

        {/* SESSION COMPLETE - For Teddy's Review Roundup integration */}
        {gameState === 'sessionComplete' && (
          <div style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            flex: 1,
            padding: '24px',
            animation: 'slideIn 0.5s ease-out',
          }}>
            <div style={{ fontSize: '60px', marginBottom: '16px' }}>
              {sessionResults.outcome === 'victory' ? 'ðŸ†' : sessionResults.outcome === 'defeat' ? 'ðŸ’€' : 'ðŸšª'}
            </div>
            <h2 style={{
              fontSize: '28px',
              fontWeight: 900,
              marginBottom: '8px',
              color: sessionResults.outcome === 'victory' ? theme.gold : theme.text,
            }}>
              {sessionResults.outcome === 'victory' ? 'SESSION COMPLETE!' :
               sessionResults.outcome === 'defeat' ? 'SESSION ENDED' : 'SESSION QUIT'}
            </h2>

            {/* Session stats */}
            <div style={{
              background: theme.bgPanel,
              borderRadius: '12px',
              padding: '20px 32px',
              marginBottom: '20px',
              border: `1px solid ${theme.border}`,
              textAlign: 'center',
            }}>
              <div style={{ fontSize: '14px', color: theme.textMuted, marginBottom: '8px' }}>
                SESSION RESULTS
              </div>
              <div style={{ fontSize: '36px', fontWeight: 800, color: theme.gold, marginBottom: '8px' }}>
                â­ {sessionResults.totalStars}
              </div>
              <div style={{ fontSize: '12px', color: theme.textSecondary }}>
                {sessionResults.worldsCompleted.length} worlds completed â€¢ {sessionResults.totalKills} kills
              </div>
            </div>

            {/* Worlds completed breakdown */}
            {sessionResults.worldsCompleted.length > 0 && (
              <div style={{
                display: 'flex',
                flexWrap: 'wrap',
                gap: '8px',
                marginBottom: '24px',
                justifyContent: 'center',
              }}>
                {sessionResults.worldsCompleted.map((w, i) => (
                  <div key={i} style={{
                    background: `${worldDefs[w.worldId]?.color || theme.accent}20`,
                    border: `1px solid ${worldDefs[w.worldId]?.color || theme.accent}40`,
                    borderRadius: '8px',
                    padding: '8px 12px',
                    fontSize: '12px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                  }}>
                    <span style={{ fontSize: '16px' }}>{worldDefs[w.worldId]?.emoji}</span>
                    <span style={{ color: theme.text }}>{w.worldName}</span>
                    <span style={{ color: theme.gold }}>â­{w.stars}</span>
                  </div>
                ))}
              </div>
            )}

            {/* Actions */}
            <div style={{ display: 'flex', gap: '12px' }}>
              <button
                onClick={() => {
                  setSingleSessionMode(false);
                  setGameState('menu');
                }}
                className="btn"
                style={{
                  padding: '14px 28px',
                  fontSize: '15px',
                  fontWeight: 700,
                  background: `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`,
                  border: 'none',
                  borderRadius: '12px',
                  color: '#fff',
                  boxShadow: `0 4px 20px ${theme.accentGlow}`,
                }}
              >
                CONTINUE PLAYING
              </button>
              {window.parent !== window && (
                <button
                  onClick={() => window.parent.postMessage({ type: 'towerDefenseClose' }, '*')}
                  className="btn"
                  style={{
                    padding: '14px 28px',
                    fontSize: '15px',
                    fontWeight: 700,
                    background: theme.bgDark,
                    border: `1px solid ${theme.border}`,
                    borderRadius: '12px',
                    color: theme.textSecondary,
                  }}
                >
                  CLOSE
                </button>
              )}
            </div>

            <div style={{ marginTop: '16px', fontSize: '11px', color: theme.textMuted }}>
              Results have been sent to Teddy's Review Roundup
            </div>
          </div>
        )}

        {/* WORLD SELECT */}
        {gameState === 'select' && (
          <div style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            flex: 1,
            padding: '16px',
            animation: 'slideIn 0.3s ease-out',
          }}>
            <h2 style={{
              fontSize: 'clamp(20px, 4vw, 28px)',
              fontWeight: 800,
              marginBottom: '8px',
              color: theme.gold,
            }}>SELECT WORLD</h2>
            <p style={{ fontSize: '12px', color: theme.textSecondary, marginBottom: '16px' }}>
              â­ {progression.totalStars} / 100 Stars
            </p>

            {/* World grid - 2 rows of 5 */}
            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(5, 1fr)',
              gap: '10px',
              maxWidth: '500px',
              width: '100%',
            }}>
              {worldDefs.map((world, idx) => {
                const isUnlocked = ProgressionStorage.isWorldUnlocked(idx);
                const stars = progression.worldStars[idx] || 0;
                const isComplete = stars >= 10;

                return (
                  <button
                    key={world.id}
                    onClick={() => isUnlocked && startGame(idx, false)}
                    disabled={!isUnlocked}
                    className="btn"
                    style={{
                      padding: '12px 8px',
                      background: isUnlocked
                        ? isComplete
                          ? `linear-gradient(135deg, ${world.color}40 0%, ${world.color}20 100%)`
                          : theme.bgPanel
                        : theme.bgDark,
                      border: `2px solid ${isUnlocked ? world.color : theme.border}`,
                      borderRadius: '12px',
                      opacity: isUnlocked ? 1 : 0.4,
                      cursor: isUnlocked ? 'pointer' : 'not-allowed',
                      position: 'relative',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: '4px',
                    }}
                  >
                    {/* World emoji */}
                    <div style={{
                      fontSize: '28px',
                      filter: isUnlocked ? `drop-shadow(0 0 8px ${world.color})` : 'grayscale(1)',
                    }}>
                      {isUnlocked ? world.emoji : 'ðŸ”’'}
                    </div>

                    {/* World name */}
                    <div style={{
                      fontSize: '10px',
                      fontWeight: 700,
                      color: isUnlocked ? world.color : theme.textMuted,
                      whiteSpace: 'nowrap',
                      overflow: 'hidden',
                      textOverflow: 'ellipsis',
                      maxWidth: '100%',
                    }}>
                      {world.name.split(' ')[0]}
                    </div>

                    {/* Stars */}
                    {isUnlocked && (
                      <div style={{
                        fontSize: '9px',
                        color: stars > 0 ? theme.gold : theme.textMuted,
                      }}>
                        {'â˜…'.repeat(Math.min(stars, 10))}{'â˜†'.repeat(Math.max(0, 10 - stars))}
                      </div>
                    )}

                    {/* Complete badge */}
                    {isComplete && (
                      <div style={{
                        position: 'absolute',
                        top: '-6px',
                        right: '-6px',
                        fontSize: '14px',
                      }}>ðŸ‘‘</div>
                    )}
                  </button>
                );
              })}
            </div>

            {/* Selected world info */}
            <div style={{
              marginTop: '20px',
              padding: '16px',
              background: theme.bgPanel,
              borderRadius: '12px',
              border: `1px solid ${theme.border}`,
              textAlign: 'center',
              maxWidth: '400px',
              width: '100%',
            }}>
              <div style={{ fontSize: '11px', color: theme.textMuted, marginBottom: '8px' }}>
                Click a world to play â€¢ Complete 10 waves to defeat the boss
              </div>
              <div style={{ fontSize: '10px', color: theme.textSecondary }}>
                Need 8 stars to unlock the next world
              </div>
            </div>

            {/* Back button */}
            <button
              onClick={() => setGameState('menu')}
              className="btn"
              style={{
                marginTop: '16px',
                padding: '10px 24px',
                fontSize: '12px',
                background: theme.bgDark,
                border: `1px solid ${theme.border}`,
                borderRadius: '8px',
                color: theme.textSecondary,
              }}
            >
              â† Back to Menu
            </button>
          </div>
        )}

        {/* PLAYING */}
        {(gameState === 'playing' || gameState === 'lost') && (
          <div style={{
            display: 'flex',
            flexDirection: isLandscape ? 'row' : 'column',
            gap: '12px',
            justifyContent: 'center',
            alignItems: isLandscape ? 'flex-start' : 'center',
            flex: 1,
            overflow: isLandscape ? 'visible' : 'auto',
          }}>

            {/* Left Panel - Hidden in portrait, shown as bottom bar */}
            {isLandscape && <div style={{
              background: theme.bgPanel,
              borderRadius: '12px',
              padding: '12px',
              border: `1px solid ${theme.border}`,
              width: `${panelWidth}px`,
              flexShrink: 0,
            }}>
              <div style={{ fontSize: '10px', fontWeight: 700, color: theme.gold, letterSpacing: '1px', marginBottom: '10px' }}>
                TOWERS
              </div>

              {Object.values(towerTypes).map((tower, idx) => {
                const canAfford = gold >= tower.cost;
                const isSelected = selectedTower === tower.id;

                return (
                  <div
                    key={tower.id}
                    onClick={() => canAfford && (setSelectedTower(tower.id), setSelectedTowerForUpgrade(null))}
                    className="tower-card"
                    style={{
                      background: isSelected ? `${tower.color}20` : theme.bgDark,
                      borderRadius: '8px',
                      padding: '8px 10px',
                      marginBottom: '6px',
                      opacity: canAfford ? 1 : 0.4,
                      border: isSelected ? `2px solid ${tower.color}` : `1px solid ${theme.border}`,
                      cursor: canAfford ? 'pointer' : 'not-allowed',
                    }}
                  >
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      {sprites.towers[tower.id] ? (
                        <img src={sprites.towers[tower.id]} alt={tower.name} style={{ width: 22, height: 22, imageRendering: 'pixelated' }} />
                      ) : (
                        <span style={{ fontSize: '18px' }}>{tower.emoji}</span>
                      )}
                      <div style={{ flex: 1, minWidth: 0 }}>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <span style={{ fontSize: '11px', fontWeight: 700, color: tower.color }}>{tower.name}</span>
                          {showHotkeys && <span style={{ fontSize: '9px', color: theme.textMuted, background: theme.bgDark, padding: '1px 4px', borderRadius: '3px' }}>{tower.hotkey}</span>}
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: '2px' }}>
                          <span style={{ fontSize: '9px', color: theme.textMuted }}>{tower.desc}</span>
                          <span style={{ fontSize: '10px', color: theme.gold, fontWeight: 600 }}>{tower.cost}ðŸ’°</span>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}

              <div style={{ marginTop: '10px', padding: '8px', background: theme.bgDark, borderRadius: '8px', fontSize: '9px', color: theme.textMuted }}>
                <div style={{ fontWeight: 600, color: theme.textSecondary, marginBottom: '4px' }}>Controls</div>
                <div>1-7: Select tower</div>
                <div>U: Upgrade â€¢ S: Sell</div>
                <div>Q: Bomb â€¢ W: Freeze</div>
                <div>Space: Start wave</div>
                <div>Esc: Deselect</div>
              </div>

              {/* Sound toggle */}
              <button
                onClick={() => setSoundEnabled(s => !s)}
                className="btn"
                style={{
                  marginTop: '8px',
                  padding: '6px 12px',
                  fontSize: '12px',
                  background: theme.bgDark,
                  border: `1px solid ${theme.border}`,
                  borderRadius: '6px',
                  color: soundEnabled ? theme.success : theme.textMuted,
                  width: '100%',
                }}
              >
                {soundEnabled ? 'ðŸ”Š Sound ON' : 'ðŸ”‡ Sound OFF'}
              </button>
            </div>}

            {/* Center - Game */}
            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              {/* Top bar */}
              <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '8px',
                padding: '8px 12px',
                background: theme.bgPanel,
                borderRadius: '10px',
                border: `1px solid ${theme.border}`,
                width: gridWidth,
              }}>
                <div style={{ display: 'flex', gap: '16px', alignItems: 'center' }}>
                  {/* World indicator */}
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    padding: '4px 8px',
                    background: `${worldDefs[currentWorld].color}20`,
                    borderRadius: '6px',
                    border: `1px solid ${worldDefs[currentWorld].color}40`,
                  }}>
                    <span style={{ fontSize: '16px' }}>{worldDefs[currentWorld].emoji}</span>
                    <div style={{ textAlign: 'left' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted }}>WORLD {currentWorld + 1}</div>
                      <div style={{ fontSize: '11px', fontWeight: 700, color: worldDefs[currentWorld].color }}>
                        {wave}/10
                      </div>
                    </div>
                  </div>

                  {[
                    { label: 'LIVES', value: `â¤ï¸${lives}`, color: lives <= 5 ? theme.error : theme.success, blink: lives <= 5 },
                    {
                      label: 'GOLD',
                      value: `ðŸ’°${Math.floor(displayGold)}`,
                      color: displayGold > gold ? theme.error : displayGold < gold ? theme.success : theme.gold,
                      glow: Math.abs(gold - displayGold) > 5
                    },
                  ].map((stat, i) => (
                    <div key={i} style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted, letterSpacing: '0.5px' }}>{stat.label}</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: stat.color,
                        animation: stat.blink ? 'pulse 0.5s ease-in-out infinite' : 'none',
                        textShadow: stat.glow ? `0 0 10px ${stat.color}` : 'none',
                        transition: 'color 0.2s ease',
                      }}>{stat.value}</div>
                    </div>
                  ))}
                  {/* Wave countdown timer */}
                  {!waveInProgress && waveCountdown > 0 && (
                    <div style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted }}>BONUS</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: theme.gold,
                        animation: 'pulse 1s ease-in-out infinite',
                      }}>â±ï¸{Math.ceil(waveCountdown / 1000)}s</div>
                    </div>
                  )}
                  {combo > 0 && (
                    <div style={{ textAlign: 'center' }}>
                      <div style={{ fontSize: '8px', color: theme.textMuted }}>COMBO</div>
                      <div style={{
                        fontSize: '16px',
                        fontWeight: 800,
                        color: combo >= 20 ? theme.gold : combo >= 10 ? '#ff6b00' : theme.accent,
                        animation: combo >= 20 ? 'rainbow 2s linear infinite' : 'none',
                      }}>ðŸ”¥{combo}</div>
                    </div>
                  )}
                </div>

                {/* Ability buttons */}
                <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
                  <button
                    onClick={useBombAbility}
                    disabled={abilities.bomb.cooldown > 0 || gold < abilities.bomb.cost}
                    className="btn"
                    title={`Bomb (${abilities.bomb.cost}ðŸ’°) - Deal 25% max HP to all enemies`}
                    style={{
                      padding: '6px 10px',
                      fontSize: '14px',
                      background: abilities.bomb.cooldown > 0 ? theme.bgDark : `linear-gradient(135deg, ${theme.fire}40 0%, ${theme.fire}20 100%)`,
                      border: `2px solid ${abilities.bomb.cooldown > 0 ? theme.border : theme.fire}`,
                      borderRadius: '8px',
                      color: abilities.bomb.cooldown > 0 ? theme.textMuted : theme.fire,
                      opacity: gold < abilities.bomb.cost && abilities.bomb.cooldown <= 0 ? 0.5 : 1,
                      position: 'relative',
                      overflow: 'hidden',
                    }}
                  >
                    ðŸ’£
                    {abilities.bomb.cooldown > 0 && (
                      <div style={{
                        position: 'absolute',
                        bottom: 0,
                        left: 0,
                        height: '3px',
                        width: `${(1 - abilities.bomb.cooldown / abilities.bomb.maxCooldown) * 100}%`,
                        background: theme.fire,
                      }} />
                    )}
                  </button>
                  <button
                    onClick={useFreezeAbility}
                    disabled={abilities.freeze.cooldown > 0 || gold < abilities.freeze.cost}
                    className="btn"
                    title={`Freeze (${abilities.freeze.cost}ðŸ’°) - Slow all enemies 90% for 5s`}
                    style={{
                      padding: '6px 10px',
                      fontSize: '14px',
                      background: abilities.freeze.cooldown > 0 ? theme.bgDark : `linear-gradient(135deg, ${theme.frost}40 0%, ${theme.frost}20 100%)`,
                      border: `2px solid ${abilities.freeze.cooldown > 0 ? theme.border : theme.frost}`,
                      borderRadius: '8px',
                      color: abilities.freeze.cooldown > 0 ? theme.textMuted : theme.frost,
                      opacity: gold < abilities.freeze.cost && abilities.freeze.cooldown <= 0 ? 0.5 : 1,
                      position: 'relative',
                      overflow: 'hidden',
                    }}
                  >
                    â„ï¸
                    {abilities.freeze.cooldown > 0 && (
                      <div style={{
                        position: 'absolute',
                        bottom: 0,
                        left: 0,
                        height: '3px',
                        width: `${(1 - abilities.freeze.cooldown / abilities.freeze.maxCooldown) * 100}%`,
                        background: theme.frost,
                      }} />
                    )}
                  </button>
                </div>

                <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
                  <button
                    onClick={() => setGameSpeed(s => s === 1 ? 2 : s === 2 ? 3 : 1)}
                    className="btn"
                    style={{
                      padding: '6px 12px',
                      fontSize: '11px',
                      fontWeight: 700,
                      background: theme.bgDark,
                      border: `1px solid ${theme.border}`,
                      borderRadius: '6px',
                      color: theme.textSecondary,
                    }}
                  >{gameSpeed}Ã—</button>
                  <button
                    onClick={startWave}
                    disabled={waveInProgress}
                    className="btn"
                    style={{
                      padding: '8px 16px',
                      fontSize: '12px',
                      fontWeight: 700,
                      background: waveInProgress ? theme.bgDark : `linear-gradient(135deg, ${theme.success} 0%, #1fab54 100%)`,
                      border: 'none',
                      borderRadius: '8px',
                      color: waveInProgress ? theme.textMuted : '#fff',
                      cursor: waveInProgress ? 'not-allowed' : 'pointer',
                      boxShadow: waveInProgress ? 'none' : `0 4px 12px ${theme.successGlow}`,
                    }}
                  >
                    {waveInProgress ? `${enemiesSpawned}/${totalEnemiesInWave}` : `â–¶ WAVE ${wave}`}
                  </button>
                </div>
              </div>

              {/* Wave progress */}
              {waveInProgress && (
                <div style={{
                  width: gridWidth,
                  height: '3px',
                  background: theme.bgDark,
                  borderRadius: '2px',
                  marginBottom: '8px',
                  overflow: 'hidden',
                }}>
                  <div style={{
                    width: `${(enemiesSpawned / totalEnemiesInWave) * 100}%`,
                    height: '100%',
                    background: `linear-gradient(90deg, ${theme.accent} 0%, ${theme.success} 100%)`,
                    transition: 'width 0.2s ease',
                  }} />
                </div>
              )}

              {/* Grid */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`,
                gap: `${GRID_GAP}px`,
                background: `linear-gradient(145deg, ${theme.bgDark} 0%, #080810 100%)`,
                padding: `${GRID_OFFSET}px`,
                borderRadius: '16px',
                border: `2px solid ${theme.border}`,
                position: 'relative',
                boxShadow: `0 8px 32px rgba(0,0,0,0.5), 0 0 60px ${theme.accent}08, inset 0 0 60px rgba(0,0,0,0.3)`,
              }}>
                {grid.map((row, rowIdx) => row.map((cell, colIdx) => {
                  const isStart = rowIdx === START.row && colIdx === START.col;
                  const isEnd = rowIdx === END.row && colIdx === END.col;
                  const cellKey = `${rowIdx},${colIdx}`;
                  const isPath = pathCellsSet.has(cellKey);
                  const isHovered = hoveredCell?.row === rowIdx && hoveredCell?.col === colIdx;
                  const tower = towersByPosition.get(cellKey);
                  const canPlace = selectedTower && canPlaceTowerFast(rowIdx, colIdx) && gold >= towerTypes[selectedTower].cost;
                  const isSelected = tower && selectedTowerForUpgrade?.id === tower.id;

                  return (
                    <div
                      key={`${rowIdx}-${colIdx}`}
                      className="cell"
                      onClick={() => {
                        if (selectedTower && canPlace) placeTower(rowIdx, colIdx, selectedTower);
                        else if (tower && !selectedTower) setSelectedTowerForUpgrade(isSelected ? null : tower);
                      }}
                      onContextMenu={(e) => { e.preventDefault(); if (tower) sellTower(tower.id); }}
                      onMouseEnter={() => setHoveredCell({ row: rowIdx, col: colIdx })}
                      onMouseLeave={() => setHoveredCell(null)}
                      onTouchStart={() => setHoveredCell({ row: rowIdx, col: colIdx })}
                      style={{
                        width: CELL_SIZE,
                        height: CELL_SIZE,
                        background: isStart ? `radial-gradient(circle, ${theme.success}50 0%, ${theme.success}20 70%)`
                          : isEnd ? `radial-gradient(circle, ${theme.error}50 0%, ${theme.error}20 70%)`
                          : tower ? `radial-gradient(circle, ${tower.color}35 0%, ${tower.color}15 70%)`
                          : isHovered && canPlace ? `${towerTypes[selectedTower].color}30`
                          : isHovered && selectedTower && !canPlace ? `${theme.error}30`
                          : isPath ? `linear-gradient(135deg, ${theme.pathColor} 0%, ${theme.pathGlow} 100%)`
                          : theme.bgCell,
                        borderRadius: '6px',
                        boxShadow: isPath ? `inset 0 0 ${CELL_SIZE * 0.4}px ${theme.accent}15` : 'none',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        cursor: canPlace ? 'crosshair'
                          : tower ? 'pointer'
                          : selectedTower && !canPlace ? 'not-allowed'
                          : 'default',
                        position: 'relative',
                        border: isSelected ? `2px solid ${tower.color}` : isPath ? `1px solid ${theme.accent}20` : 'none',
                        boxShadow: tower ? `inset 0 0 ${CELL_SIZE/3}px ${tower.color}30, 0 0 8px ${tower.color}20` : 'none',
                      }}
                    >
                      {isStart && <span style={{ fontSize: CELL_SIZE * 0.55, filter: `drop-shadow(0 0 6px ${theme.success})`, animation: 'pulse 2s ease-in-out infinite' }}>ðŸšª</span>}
                      {isEnd && <span style={{ fontSize: CELL_SIZE * 0.55, filter: `drop-shadow(0 0 6px ${theme.error})`, animation: 'pulse 2s ease-in-out infinite' }}>ðŸ </span>}
                      {tower && (
                        <>
                          {/* Upgrade aura ring */}
                          {tower.level > 0 && (
                            <div style={{
                              position: 'absolute',
                              width: CELL_SIZE * (0.7 + tower.level * 0.1),
                              height: CELL_SIZE * (0.7 + tower.level * 0.1),
                              borderRadius: '50%',
                              border: `${tower.level}px solid ${tower.color}40`,
                              boxShadow: `0 0 ${4 + tower.level * 3}px ${tower.color}60, inset 0 0 ${tower.level * 2}px ${tower.color}30`,
                              animation: 'pulse 2s ease-in-out infinite',
                            }} />
                          )}
                          {/* Tower sprite/emoji with recoil */}
                          <div style={{
                            transform: `scale(${1 + tower.level * 0.08 - (tower.recoil || 0) * 0.15}) translateY(${(tower.recoil || 0) * 2}px)`,
                            transition: 'transform 0.05s ease-out',
                          }}>
                            {sprites.towers[tower.type] ? (
                              <img
                                src={sprites.towers[tower.type]}
                                alt={tower.name}
                                style={{
                                  width: CELL_SIZE * 0.6,
                                  height: CELL_SIZE * 0.6,
                                  imageRendering: 'pixelated',
                                  filter: `drop-shadow(0 0 ${4 + tower.level * 2}px ${tower.color}) ${tower.level >= 2 ? 'brightness(1.2)' : ''} ${tower.level >= 3 ? 'saturate(1.3)' : ''}`,
                                  animation: tower.beamTarget ? 'glow 0.3s ease-in-out infinite' : 'none',
                                }}
                              />
                            ) : (
                              <span style={{
                                fontSize: CELL_SIZE * 0.55,
                                filter: `drop-shadow(0 0 ${4 + tower.level * 2}px ${tower.color})`,
                                animation: tower.beamTarget ? 'glow 0.3s ease-in-out infinite' : 'none',
                              }}>{tower.emoji}</span>
                            )}
                          </div>
                          {/* Type badge in corner */}
                          <div style={{
                            position: 'absolute',
                            top: '0px',
                            left: '1px',
                            fontSize: '10px',
                            filter: `drop-shadow(0 0 2px ${tower.color})`,
                            lineHeight: 1,
                          }}>{tower.emoji}</div>
                          {/* Level indicator with upgrade tier color */}
                          {tower.level > 0 && (
                            <div style={{
                              position: 'absolute',
                              bottom: '1px',
                              right: '2px',
                              fontSize: '8px',
                              fontWeight: 900,
                              color: tower.level >= 3 ? '#ff4757' : tower.level >= 2 ? '#ffa502' : theme.gold,
                              textShadow: `0 0 4px ${tower.level >= 3 ? '#ff4757' : tower.level >= 2 ? '#ffa502' : theme.gold}`,
                            }}>{'â˜…'.repeat(tower.level)}</div>
                          )}
                        </>
                      )}
                      {isHovered && canPlace && !tower && (
                        <>
                          {sprites.towers[selectedTower] ? (
                            <img
                              src={sprites.towers[selectedTower]}
                              alt={towerTypes[selectedTower].name}
                              style={{
                                width: CELL_SIZE * 0.55,
                                height: CELL_SIZE * 0.55,
                                imageRendering: 'pixelated',
                                opacity: 0.5,
                              }}
                            />
                          ) : (
                            <span style={{ fontSize: CELL_SIZE * 0.5, opacity: 0.5 }}>{towerTypes[selectedTower].emoji}</span>
                          )}
                          {/* Type badge preview */}
                          <div style={{
                            position: 'absolute',
                            top: '0px',
                            left: '1px',
                            fontSize: '10px',
                            opacity: 0.5,
                            lineHeight: 1,
                          }}>{towerTypes[selectedTower].emoji}</div>
                        </>
                      )}
                    </div>
                  );
                }))}

                {/* Death marks / craters */}
                {deathMarks.map(mark => (
                  <div key={mark.id} style={{
                    position: 'absolute',
                    left: mark.x - mark.size / 2 + GRID_OFFSET,
                    top: mark.y - mark.size / 2 + GRID_OFFSET,
                    width: mark.size,
                    height: mark.size,
                    background: `radial-gradient(circle, ${mark.color}40 0%, ${mark.color}20 40%, transparent 70%)`,
                    borderRadius: '50%',
                    opacity: Math.min(1, mark.life / 2000) * 0.6,
                    pointerEvents: 'none',
                    zIndex: 3,
                    boxShadow: `inset 0 0 ${mark.size/3}px ${mark.color}30`,
                  }} />
                ))}

                {/* Base health visualization - glow around the end based on remaining lives */}
                <div style={{
                  position: 'absolute',
                  left: END.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET,
                  top: END.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET,
                  width: CELL_SIZE * 2.5,
                  height: CELL_SIZE * 2.5,
                  transform: 'translate(-50%, -50%)',
                  borderRadius: '50%',
                  background: `radial-gradient(circle,
                    ${lives > 10 ? theme.success : lives > 5 ? theme.gold : theme.error}${Math.floor(lives / 20 * 40).toString(16).padStart(2, '0')} 0%,
                    transparent 70%)`,
                  pointerEvents: 'none',
                  zIndex: 2,
                  animation: lives <= 5 ? 'pulse 1s ease-in-out infinite' : 'none',
                }} />

                {/* Path flow particles */}
                {path.length > 1 && Array(5).fill(0).map((_, i) => {
                  const flowPos = (pathFlowOffset + i * 0.2) % 1;
                  const pathIdx = Math.floor(flowPos * (path.length - 1));
                  const t = (flowPos * (path.length - 1)) - pathIdx;
                  const p1 = path[pathIdx];
                  const p2 = path[Math.min(pathIdx + 1, path.length - 1)];
                  if (!p1 || !p2) return null;
                  const x = (p1.col + (p2.col - p1.col) * t) * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
                  const y = (p1.row + (p2.row - p1.row) * t) * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2;
                  return (
                    <div key={`flow-${i}`} style={{
                      position: 'absolute',
                      left: x - 3 + GRID_OFFSET,
                      top: y - 3 + GRID_OFFSET,
                      width: 6,
                      height: 6,
                      background: theme.accent,
                      borderRadius: '50%',
                      opacity: 0.3,
                      pointerEvents: 'none',
                      zIndex: 4,
                      boxShadow: `0 0 6px ${theme.accent}`,
                    }} />
                  );
                })}

                {/* Range indicator */}
                {(hoveredCell && selectedTower && canPlaceTowerFast(hoveredCell.row, hoveredCell.col)) && (
                  <div style={{
                    position: 'absolute',
                    left: hoveredCell.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET,
                    top: hoveredCell.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET,
                    width: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    height: towerTypes[selectedTower].range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px dashed ${towerTypes[selectedTower].color}40`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${towerTypes[selectedTower].color}08 0%, transparent 70%)`,
                  }} />
                )}

                {/* Selected tower range */}
                {selectedTowerForUpgrade && (
                  <div style={{
                    position: 'absolute',
                    left: selectedTowerForUpgrade.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET,
                    top: selectedTowerForUpgrade.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET,
                    width: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    height: selectedTowerForUpgrade.range * CELL_SIZE * 2,
                    transform: 'translate(-50%, -50%)',
                    border: `2px solid ${selectedTowerForUpgrade.color}60`,
                    borderRadius: '50%',
                    pointerEvents: 'none',
                    background: `radial-gradient(circle, ${selectedTowerForUpgrade.color}10 0%, transparent 70%)`,
                  }} />
                )}

                {/* Beams */}
                {towers.filter(t => t.beam && t.beamTarget).map(tower => {
                  const fromX = tower.col * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET;
                  const fromY = tower.row * (CELL_SIZE + GRID_GAP) + CELL_SIZE / 2 + GRID_OFFSET;
                  const toX = tower.beamTarget.x + GRID_OFFSET;
                  const toY = tower.beamTarget.y + GRID_OFFSET;
                  const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                  const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);

                  return (
                    <React.Fragment key={`beam-${tower.id}`}>
                      {/* Outer glow */}
                      <div style={{
                        position: 'absolute',
                        left: fromX,
                        top: fromY - 3,
                        width: length,
                        height: '10px',
                        background: `linear-gradient(90deg, ${tower.color}60 0%, ${tower.color}20 100%)`,
                        transform: `rotate(${angle}deg)`,
                        transformOrigin: '0 50%',
                        pointerEvents: 'none',
                        filter: 'blur(4px)',
                        zIndex: 14,
                      }} />
                      {/* Core beam */}
                      <div style={{
                        position: 'absolute',
                        left: fromX,
                        top: fromY - 1,
                        width: length,
                        height: '4px',
                        background: `linear-gradient(90deg, #fff 0%, ${tower.color} 20%, ${tower.color} 80%, #fff 100%)`,
                        transform: `rotate(${angle}deg)`,
                        transformOrigin: '0 50%',
                        pointerEvents: 'none',
                        boxShadow: `0 0 12px ${tower.color}, 0 0 24px ${tower.color}80, 0 0 4px #fff`,
                        zIndex: 15,
                        borderRadius: '2px',
                      }} />
                    </React.Fragment>
                  );
                })}

                {/* Enemies */}
                {enemies.map(enemy => {
                  const size = (CELL_SIZE * 0.55) * (enemy.size || 1);
                  const bobOffset = Math.sin(enemy.animPhase * 4) * 2;
                  const scaleEffect = 1 + Math.sin(enemy.animPhase * 2) * 0.03;

                  return (
                    <div
                      key={enemy.id}
                      style={{
                        position: 'absolute',
                        left: enemy.x - size / 2 + GRID_OFFSET,
                        top: enemy.y - size / 2 + GRID_OFFSET + bobOffset,
                        width: size,
                        height: size,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        pointerEvents: 'none',
                        zIndex: 10,
                        filter: enemy.hitFlash > 0 ? `brightness(${1 + enemy.hitFlash * 1.5}) drop-shadow(0 0 8px #fff)`
                          : enemy.poisonedUntil > renderTime ? `drop-shadow(0 0 6px ${theme.poison}) drop-shadow(0 0 2px ${theme.poison})`
                          : enemy.slowedUntil > renderTime ? `drop-shadow(0 0 6px ${theme.frost}) drop-shadow(0 0 2px ${theme.frost})`
                          : `drop-shadow(0 0 4px ${enemy.color})`,
                        transition: 'filter 0.1s ease',
                        transform: `scale(${scaleEffect})`,
                      }}
                    >
                      {sprites.enemies[enemy.type] ? (
                        <img
                          src={sprites.enemies[enemy.type]}
                          alt={enemy.name}
                          style={{
                            width: enemy.isBoss ? CELL_SIZE * 0.9 : size * 0.9,
                            height: enemy.isBoss ? CELL_SIZE * 0.9 : size * 0.9,
                            imageRendering: 'pixelated',
                            transform: `scaleX(${enemy.rotation > -Math.PI / 2 && enemy.rotation < Math.PI / 2 ? 1 : -1})`,
                          }}
                        />
                      ) : (
                        <span style={{
                          fontSize: enemy.isBoss ? CELL_SIZE * 0.8 : size * 0.8,
                          transform: `scaleX(${enemy.rotation > -Math.PI / 2 && enemy.rotation < Math.PI / 2 ? 1 : -1})`,
                        }}>{enemy.emoji}</span>
                      )}

                      {/* Health bar */}
                      <div style={{
                        position: 'absolute',
                        bottom: -8,
                        width: size + 6,
                        height: enemy.isBoss ? 6 : 4,
                        background: 'rgba(0,0,0,0.7)',
                        borderRadius: '3px',
                        overflow: 'hidden',
                        border: '1px solid rgba(255,255,255,0.1)',
                        boxShadow: '0 1px 3px rgba(0,0,0,0.4)',
                      }}>
                        {enemy.maxShield > 0 && (
                          <div style={{
                            position: 'absolute',
                            width: `${(enemy.currentShield / enemy.maxShield) * 100}%`,
                            height: '100%',
                            background: 'linear-gradient(180deg, #9db3c9 0%, #778ca3 100%)',
                            transition: 'width 0.1s ease',
                          }} />
                        )}
                        <div style={{
                          width: `${(enemy.currentHealth / enemy.maxHealth) * 100}%`,
                          height: '100%',
                          background: enemy.currentHealth > enemy.maxHealth * 0.5
                            ? `linear-gradient(180deg, ${theme.success} 0%, #1fab54 100%)`
                            : enemy.currentHealth > enemy.maxHealth * 0.25
                            ? `linear-gradient(180deg, ${theme.gold} 0%, #e6c200 100%)`
                            : `linear-gradient(180deg, ${theme.error} 0%, #cc3847 100%)`,
                          transition: 'width 0.15s ease',
                          boxShadow: enemy.currentHealth <= enemy.maxHealth * 0.25 ? `0 0 4px ${theme.error}` : 'none',
                        }} />
                      </div>

                      {enemy.slowedUntil > renderTime && <div style={{ position: 'absolute', top: -8, fontSize: '8px' }}>â„ï¸</div>}
                      {enemy.poisonedUntil > renderTime && <div style={{ position: 'absolute', top: -8, left: enemy.slowedUntil > renderTime ? 10 : 0, fontSize: '8px' }}>â˜ ï¸</div>}
                    </div>
                  );
                })}

                {/* Dying enemies - pop animation */}
                {dyingEnemies.map(enemy => {
                  const elapsed = renderTime - enemy.deathTime;
                  const progress = elapsed / enemy.deathDuration;
                  const scale = 1 + progress * 0.8; // Scale up
                  const opacity = 1 - progress; // Fade out
                  const size = (CELL_SIZE * 0.55) * (enemy.size || 1);

                  return (
                    <div
                      key={`dying-${enemy.id}`}
                      style={{
                        position: 'absolute',
                        left: enemy.x - size / 2 + GRID_OFFSET,
                        top: enemy.y - size / 2 + GRID_OFFSET,
                        width: size,
                        height: size,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        pointerEvents: 'none',
                        zIndex: 11,
                        transform: `scale(${scale})`,
                        opacity: opacity,
                        filter: `brightness(2) drop-shadow(0 0 15px ${enemy.color})`,
                      }}
                    >
                      {sprites.enemies[enemy.type] ? (
                        <img
                          src={sprites.enemies[enemy.type]}
                          alt={enemy.name}
                          style={{
                            width: size * 0.9,
                            height: size * 0.9,
                            imageRendering: 'pixelated',
                          }}
                        />
                      ) : (
                        <span style={{ fontSize: size * 0.8 }}>{enemy.emoji}</span>
                      )}
                    </div>
                  );
                })}

                {/* Healer beams */}
                {healerBeams.map(beam => {
                  const angle = Math.atan2(beam.toY - beam.fromY, beam.toX - beam.fromX) * 180 / Math.PI;
                  const length = Math.sqrt((beam.toX - beam.fromX) ** 2 + (beam.toY - beam.fromY) ** 2);
                  const opacity = beam.life / 400;

                  return (
                    <div
                      key={beam.id}
                      style={{
                        position: 'absolute',
                        left: beam.fromX + GRID_OFFSET,
                        top: beam.fromY + GRID_OFFSET - 1,
                        width: length,
                        height: 3,
                        background: `linear-gradient(90deg, transparent 0%, ${theme.success}${Math.floor(opacity * 255).toString(16).padStart(2, '0')} 20%, ${theme.success}${Math.floor(opacity * 255).toString(16).padStart(2, '0')} 80%, transparent 100%)`,
                        transform: `rotate(${angle}deg)`,
                        transformOrigin: '0 50%',
                        pointerEvents: 'none',
                        zIndex: 9,
                        boxShadow: `0 0 8px ${theme.success}`,
                      }}
                    />
                  );
                })}

                {/* Confetti */}
                {confetti.map(c => (
                  <div
                    key={c.id}
                    style={{
                      position: 'absolute',
                      left: c.x + GRID_OFFSET,
                      top: c.y + GRID_OFFSET,
                      width: c.size,
                      height: c.size * 0.6,
                      background: c.color,
                      transform: `rotate(${c.rotation}deg)`,
                      opacity: c.life / 2000,
                      pointerEvents: 'none',
                      zIndex: 20,
                      borderRadius: '1px',
                      boxShadow: `0 0 4px ${c.color}`,
                    }}
                  />
                ))}

                {/* Projectiles */}
                {projectiles.map(proj => {
                  // Calculate position with optional arcing
                  let x = proj.fromX + (proj.toX - proj.fromX) * proj.progress;
                  let y = proj.fromY + (proj.toY - proj.fromY) * proj.progress;

                  // Arcing projectiles (cannon) - parabolic motion
                  if (proj.arcing && proj.arcHeight) {
                    const arcOffset = Math.sin(proj.progress * Math.PI) * proj.arcHeight;
                    y -= arcOffset;
                  }

                  // Elemental trail colors
                  const trailColors = {
                    fire: ['#ff6b35', '#ff9500', '#ffcc00'],
                    frost: ['#70c9ff', '#a8e6ff', '#ffffff'],
                    lightning: ['#fff200', '#ffff80', '#ffffff'],
                    poison: ['#a55eea', '#c990ff', '#e8c0ff'],
                    physical: [proj.color],
                  };
                  const elementTrail = trailColors[proj.damageType] || [proj.color];

                  return (
                    <React.Fragment key={proj.id}>
                      {/* Elemental trail */}
                      {proj.trail.map((point, i) => {
                        const trailY = proj.arcing && proj.arcHeight
                          ? point.y - Math.sin((i / proj.trail.length) * Math.PI) * proj.arcHeight * 0.3
                          : point.y;
                        const trailColor = elementTrail[i % elementTrail.length];
                        return (
                          <div key={`trail-${proj.id}-${i}`} style={{
                            position: 'absolute',
                            left: point.x - proj.size * 0.4 + GRID_OFFSET,
                            top: trailY - proj.size * 0.4 + GRID_OFFSET,
                            width: proj.size * 0.7,
                            height: proj.size * 0.7,
                            background: `radial-gradient(circle, ${trailColor} 0%, transparent 70%)`,
                            borderRadius: '50%',
                            opacity: (i / proj.trail.length) * 0.6,
                            pointerEvents: 'none',
                            zIndex: 18,
                          }} />
                        );
                      })}
                      {/* Main projectile */}
                      <div style={{
                        position: 'absolute',
                        left: x - proj.size / 2 + GRID_OFFSET,
                        top: y - proj.size / 2 + GRID_OFFSET,
                        width: proj.size,
                        height: proj.size,
                        background: `radial-gradient(circle, #fff 0%, ${proj.color} 50%, transparent 100%)`,
                        borderRadius: proj.arcing ? '30%' : '50%',
                        boxShadow: `0 0 ${proj.size * 1.5}px ${proj.color}, 0 0 ${proj.size * 0.5}px #fff`,
                        pointerEvents: 'none',
                        zIndex: 20,
                        transform: proj.arcing ? `rotate(${Math.atan2(proj.toY - proj.fromY, proj.toX - proj.fromX) + Math.PI/4}rad)` : 'none',
                      }} />
                      {/* Chain lightning special effect */}
                      {proj.isChain && (
                        <div style={{
                          position: 'absolute',
                          left: proj.fromX + GRID_OFFSET,
                          top: proj.fromY + GRID_OFFSET,
                          width: 2,
                          height: Math.sqrt((proj.toX - proj.fromX) ** 2 + (proj.toY - proj.fromY) ** 2),
                          background: `linear-gradient(180deg, ${proj.color} 0%, transparent 100%)`,
                          transform: `rotate(${Math.atan2(proj.toY - proj.fromY, proj.toX - proj.fromX) - Math.PI/2}rad)`,
                          transformOrigin: 'top center',
                          opacity: 1 - proj.progress,
                          pointerEvents: 'none',
                          zIndex: 19,
                          filter: 'blur(1px)',
                        }} />
                      )}
                    </React.Fragment>
                  );
                })}

                {/* Particles */}
                {particles.map(p => p.isShockwave ? (
                  // Explosion shockwave - expanding ring
                  <div key={p.id} style={{
                    position: 'absolute',
                    left: p.x - p.size * (2 - p.life / p.maxLife) + GRID_OFFSET,
                    top: p.y - p.size * (2 - p.life / p.maxLife) + GRID_OFFSET,
                    width: p.size * 2 * (2 - p.life / p.maxLife),
                    height: p.size * 2 * (2 - p.life / p.maxLife),
                    border: `3px solid ${p.color}`,
                    borderRadius: '50%',
                    opacity: p.life / p.maxLife * 0.7,
                    pointerEvents: 'none',
                    zIndex: 24,
                    boxShadow: `0 0 10px ${p.color}, inset 0 0 10px ${p.color}40`,
                  }} />
                ) : (
                  // Regular particle
                  <div key={p.id} style={{
                    position: 'absolute',
                    left: p.x - p.size / 2 + GRID_OFFSET,
                    top: p.y - p.size / 2 + GRID_OFFSET,
                    width: p.size,
                    height: p.size,
                    background: `radial-gradient(circle, ${p.color} 0%, ${p.color}80 50%, transparent 100%)`,
                    borderRadius: '50%',
                    opacity: Math.pow(p.life / p.maxLife, 0.7),
                    pointerEvents: 'none',
                    zIndex: 25,
                    transform: `scale(${0.5 + (p.life / p.maxLife) * 0.5}) rotate(${p.rotation}deg)`,
                    boxShadow: `0 0 ${p.size * 1.2}px ${p.color}`,
                  }} />
                ))}

                {/* Floating texts */}
                {floatingTexts.map(t => (
                  <div key={t.id} style={{
                    position: 'absolute',
                    left: t.x + GRID_OFFSET,
                    top: t.y + GRID_OFFSET,
                    fontSize: `${t.size}px`,
                    fontWeight: 800,
                    color: t.color,
                    pointerEvents: 'none',
                    zIndex: 30,
                    opacity: t.life / t.maxLife,
                    transform: `translate(-50%, -50%) scale(${t.isCrit ? 1.2 : 1})`,
                    textShadow: `0 0 8px ${t.color}, 0 2px 3px rgba(0,0,0,0.5)`,
                    animation: t.isCrit ? 'shake 0.2s ease-out' : 'none',
                  }}>{t.text}</div>
                ))}

                {/* Announcements */}
                {announcements.map((a, i) => (
                  <div key={a.id} style={{
                    position: 'absolute',
                    left: '50%',
                    top: 60 + i * 40,
                    transform: 'translateX(-50%)',
                    fontSize: '18px',
                    fontWeight: 900,
                    color: a.color,
                    textShadow: `0 0 20px ${a.color}, 0 2px 4px rgba(0,0,0,0.5)`,
                    pointerEvents: 'none',
                    zIndex: 50,
                    opacity: Math.min(1, a.life / 500),
                    animation: 'popIn 0.2s ease-out',
                  }}>{a.text}</div>
                ))}

                {/* Screen Flash Overlay */}
                {screenFlash && (
                  <div style={{
                    position: 'absolute',
                    inset: 0,
                    background: screenFlash.color,
                    opacity: screenFlash.opacity,
                    pointerEvents: 'none',
                    zIndex: 55,
                    borderRadius: '10px',
                  }} />
                )}

                {/* Game Over */}
                {gameState === 'lost' && (() => {
                  const world = worldDefs[currentWorld];
                  const starsEarned = wave - 1; // Stars = waves completed
                  return (
                    <div style={{
                      position: 'absolute',
                      inset: 0,
                      background: 'rgba(10, 10, 18, 0.95)',
                      borderRadius: '10px',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      zIndex: 100,
                      animation: 'slideIn 0.4s ease-out',
                    }}>
                      <div style={{ fontSize: '60px', marginBottom: '16px' }}>ðŸ’€</div>
                      <div style={{ fontSize: '28px', fontWeight: 900, color: theme.error, marginBottom: '8px' }}>GAME OVER</div>

                      {/* World info */}
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '8px',
                        marginBottom: '12px',
                        padding: '8px 16px',
                        background: `${world.color}20`,
                        borderRadius: '8px',
                        border: `1px solid ${world.color}40`,
                      }}>
                        <span style={{ fontSize: '24px' }}>{world.emoji}</span>
                        <div>
                          <div style={{ fontSize: '14px', fontWeight: 700, color: world.color }}>{world.name}</div>
                          <div style={{ fontSize: '11px', color: theme.textSecondary }}>Wave {wave}/10</div>
                        </div>
                      </div>

                      {/* Stars earned */}
                      {starsEarned > 0 && (
                        <div style={{ fontSize: '16px', color: theme.gold, marginBottom: '12px' }}>
                          â­ +{starsEarned} Stars Earned!
                        </div>
                      )}

                      <div style={{ display: 'flex', gap: '16px', fontSize: '11px', color: theme.textMuted, marginBottom: '20px' }}>
                        <span>ðŸŽ¯ {killCount} kills</span>
                        <span>ðŸ”¥ {maxCombo} max combo</span>
                        <span>ðŸ’° {totalScore.toLocaleString()} score</span>
                      </div>

                      <div style={{ display: 'flex', gap: '10px' }}>
                        {singleSessionMode ? (
                          <>
                            <button onClick={() => startGame(currentWorld, true)} className="btn" style={{
                              padding: '12px 24px',
                              fontSize: '14px',
                              fontWeight: 700,
                              background: `linear-gradient(135deg, ${world.color} 0%, ${world.color}cc 100%)`,
                              border: 'none',
                              borderRadius: '10px',
                              color: '#fff',
                              boxShadow: `0 4px 16px ${world.color}40`,
                            }}>RETRY</button>
                            <button onClick={() => endSession('defeat')} className="btn" style={{
                              padding: '12px 24px',
                              fontSize: '14px',
                              fontWeight: 700,
                              background: theme.bgDark,
                              border: `1px solid ${theme.border}`,
                              borderRadius: '10px',
                              color: theme.textSecondary,
                            }}>END SESSION</button>
                          </>
                        ) : (
                          <>
                            <button onClick={() => startGame(currentWorld, false)} className="btn" style={{
                              padding: '12px 24px',
                              fontSize: '14px',
                              fontWeight: 700,
                              background: `linear-gradient(135deg, ${world.color} 0%, ${world.color}cc 100%)`,
                              border: 'none',
                              borderRadius: '10px',
                              color: '#fff',
                              boxShadow: `0 4px 16px ${world.color}40`,
                            }}>RETRY</button>
                            <button onClick={goToWorldSelect} className="btn" style={{
                              padding: '12px 24px',
                              fontSize: '14px',
                              fontWeight: 700,
                              background: theme.bgDark,
                              border: `1px solid ${theme.border}`,
                              borderRadius: '10px',
                              color: theme.textSecondary,
                            }}>WORLDS</button>
                          </>
                        )}
                      </div>
                    </div>
                  );
                })()}
              </div>

              {/* Wave preview */}
              {!waveInProgress && wavePreview && (
                <div style={{
                  marginTop: '8px',
                  padding: '8px 12px',
                  background: theme.bgPanel,
                  borderRadius: '8px',
                  border: `1px solid ${theme.border}`,
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  fontSize: '11px',
                }}>
                  <span style={{ color: theme.textMuted }}>Next:</span>
                  {Object.entries(wavePreview).map(([type, count]) => (
                    <span key={`preview-${type}`} style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                      {sprites.enemies[type] ? (
                        <img src={sprites.enemies[type]} alt={enemyTypes[type].name} style={{ width: 14, height: 14, imageRendering: 'pixelated' }} />
                      ) : (
                        <span>{enemyTypes[type].emoji}</span>
                      )}
                      <span style={{ color: enemyTypes[type].color, fontWeight: 600 }}>Ã—{count}</span>
                    </span>
                  ))}
                </div>
              )}
            </div>

            {/* Right Panel - Hidden in portrait */}
            {isLandscape && <div style={{
              background: theme.bgPanel,
              borderRadius: '12px',
              padding: '12px',
              border: `1px solid ${theme.border}`,
              width: `${panelWidth}px`,
              flexShrink: 0,
            }}>
              {selectedTowerForUpgrade ? (
                <>
                  <div style={{ fontSize: '10px', fontWeight: 700, color: selectedTowerForUpgrade.color, letterSpacing: '1px', marginBottom: '8px' }}>
                    {selectedTowerForUpgrade.name.toUpperCase()}
                  </div>
                  <div style={{ textAlign: 'center', marginBottom: '10px' }}>
                    <span style={{ fontSize: '36px' }}>{selectedTowerForUpgrade.emoji}</span>
                    <div style={{ fontSize: '10px', color: theme.gold, fontWeight: 600 }}>Level {selectedTowerForUpgrade.level + 1}</div>
                  </div>
                  <div style={{ fontSize: '9px', color: theme.textSecondary, marginBottom: '10px', background: theme.bgDark, padding: '8px', borderRadius: '6px' }}>
                    <div>DMG: <span style={{ color: theme.text, fontWeight: 600 }}>{selectedTowerForUpgrade.damage}</span>
                      {selectedTowerForUpgrade.xpLevel > 0 && <span style={{ color: theme.success, fontSize: '8px' }}> +{selectedTowerForUpgrade.xpLevel * 2}%</span>}
                    </div>
                    <div>RNG: <span style={{ color: theme.text, fontWeight: 600 }}>{selectedTowerForUpgrade.range}</span></div>
                    <div>DPS: <span style={{ color: theme.gold, fontWeight: 600 }}>{(selectedTowerForUpgrade.damage * 1000 / selectedTowerForUpgrade.fireRate).toFixed(1)}</span></div>
                    <div style={{ marginTop: '4px', borderTop: `1px solid ${theme.border}`, paddingTop: '4px' }}>
                      Kills: <span style={{ color: theme.error, fontWeight: 600 }}>{selectedTowerForUpgrade.kills}</span>
                      {selectedTowerForUpgrade.xpLevel > 0 && <span style={{ color: theme.accent, marginLeft: '6px' }}>â˜…{selectedTowerForUpgrade.xpLevel}</span>}
                    </div>
                  </div>

                  {/* Targeting Mode Selector */}
                  <div style={{ fontSize: '9px', color: theme.textMuted, marginBottom: '4px' }}>TARGET:</div>
                  <div style={{ display: 'flex', flexWrap: 'wrap', gap: '3px', marginBottom: '10px' }}>
                    {['first', 'last', 'strongest', 'weakest', 'closest'].map(mode => (
                      <button
                        key={mode}
                        onClick={() => setTowers(prev => prev.map(t =>
                          t.id === selectedTowerForUpgrade.id ? { ...t, targetingMode: mode } : t
                        ))}
                        style={{
                          padding: '3px 6px',
                          fontSize: '8px',
                          fontWeight: 600,
                          background: selectedTowerForUpgrade.targetingMode === mode ? theme.accent : theme.bgDark,
                          border: `1px solid ${selectedTowerForUpgrade.targetingMode === mode ? theme.accent : theme.border}`,
                          borderRadius: '4px',
                          color: selectedTowerForUpgrade.targetingMode === mode ? '#fff' : theme.textSecondary,
                          cursor: 'pointer',
                          textTransform: 'capitalize',
                        }}
                      >{mode}</button>
                    ))}
                  </div>

                  {selectedTowerForUpgrade.level < towerTypes[selectedTowerForUpgrade.type].upgrades.length ? (() => {
                    const nextUpgrade = towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level];
                    return (
                    <>
                      <div style={{ fontSize: '9px', color: theme.textMuted, marginBottom: '4px' }}>UPGRADE PREVIEW:</div>
                      <div style={{ background: theme.bgDark, padding: '8px', borderRadius: '6px', marginBottom: '8px', fontSize: '9px' }}>
                        <div style={{ fontWeight: 600, color: theme.gold, marginBottom: '4px' }}>
                          â†’ {nextUpgrade.name}
                        </div>
                        {nextUpgrade.damage && nextUpgrade.damage !== selectedTowerForUpgrade.damage && (
                          <div style={{ color: theme.success }}>DMG: {selectedTowerForUpgrade.damage} â†’ {nextUpgrade.damage}</div>
                        )}
                        {nextUpgrade.range && nextUpgrade.range !== selectedTowerForUpgrade.range && (
                          <div style={{ color: theme.success }}>RNG: {selectedTowerForUpgrade.range} â†’ {nextUpgrade.range}</div>
                        )}
                        {nextUpgrade.fireRate && nextUpgrade.fireRate !== selectedTowerForUpgrade.fireRate && (
                          <div style={{ color: theme.success }}>SPD: {(1000/selectedTowerForUpgrade.fireRate).toFixed(1)} â†’ {(1000/nextUpgrade.fireRate).toFixed(1)}/s</div>
                        )}
                        {nextUpgrade.slow && nextUpgrade.slow !== selectedTowerForUpgrade.slow && (
                          <div style={{ color: theme.frost }}>SLOW: {Math.round(selectedTowerForUpgrade.slow*100)}% â†’ {Math.round(nextUpgrade.slow*100)}%</div>
                        )}
                        {nextUpgrade.splash && nextUpgrade.splash !== selectedTowerForUpgrade.splash && (
                          <div style={{ color: theme.fire }}>AOE: {selectedTowerForUpgrade.splash} â†’ {nextUpgrade.splash}</div>
                        )}
                        {nextUpgrade.chain && nextUpgrade.chain !== selectedTowerForUpgrade.chain && (
                          <div style={{ color: theme.lightning }}>CHAIN: {selectedTowerForUpgrade.chain} â†’ {nextUpgrade.chain}</div>
                        )}
                        {nextUpgrade.poisonDamage && nextUpgrade.poisonDamage !== selectedTowerForUpgrade.poisonDamage && (
                          <div style={{ color: theme.poison }}>DOT: {selectedTowerForUpgrade.poisonDamage} â†’ {nextUpgrade.poisonDamage}</div>
                        )}
                        <div style={{ marginTop: '4px', color: theme.gold, fontWeight: 600 }}>ðŸ’° {nextUpgrade.cost}</div>
                      </div>
                      <button
                        onClick={() => upgradeTower(selectedTowerForUpgrade.id)}
                        disabled={gold < towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost}
                        className="btn"
                        style={{
                          width: '100%',
                          padding: '8px',
                          fontSize: '11px',
                          fontWeight: 700,
                          background: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost
                            ? `linear-gradient(135deg, ${theme.accent} 0%, ${theme.accentBright} 100%)`
                            : theme.bgDark,
                          border: 'none',
                          borderRadius: '6px',
                          color: gold >= towerTypes[selectedTowerForUpgrade.type].upgrades[selectedTowerForUpgrade.level].cost ? '#fff' : theme.textMuted,
                          marginBottom: '6px',
                        }}
                      >UPGRADE [U]</button>
                    </>
                  )})() : (
                    <div style={{ fontSize: '10px', color: theme.gold, textAlign: 'center', padding: '8px', background: `${theme.gold}10`, borderRadius: '6px', marginBottom: '8px' }}>
                      âœ¨ MAX LEVEL
                    </div>
                  )}
                  <button
                    onClick={() => sellTower(selectedTowerForUpgrade.id)}
                    className="btn"
                    style={{
                      width: '100%',
                      padding: '8px',
                      fontSize: '11px',
                      fontWeight: 700,
                      background: 'transparent',
                      border: `1px solid ${theme.error}`,
                      borderRadius: '6px',
                      color: theme.error,
                    }}
                  >SELL [S]</button>
                </>
              ) : (
                <>
                  <div style={{ fontSize: '10px', fontWeight: 700, color: theme.accent, letterSpacing: '1px', marginBottom: '10px' }}>ENEMIES</div>
                  {Object.values(enemyTypes).slice(0, 6).map(enemy => (
                    <div key={`info-${enemy.id}`} style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: '6px',
                      padding: '4px 6px',
                      marginBottom: '4px',
                      background: theme.bgDark,
                      borderRadius: '6px',
                    }}>
                      {sprites.enemies[enemy.id] ? (
                        <img src={sprites.enemies[enemy.id]} alt={enemy.name} style={{ width: 18, height: 18, imageRendering: 'pixelated' }} />
                      ) : (
                        <span style={{ fontSize: '14px' }}>{enemy.emoji}</span>
                      )}
                      <div>
                        <div style={{ fontSize: '9px', fontWeight: 600, color: enemy.color }}>{enemy.name}</div>
                        <div style={{ fontSize: '8px', color: theme.textMuted }}>HP:{enemy.health} ðŸ’°{enemy.reward}</div>
                      </div>
                    </div>
                  ))}
                  <div style={{ marginTop: '12px', fontSize: '10px', fontWeight: 700, color: theme.accent, letterSpacing: '1px', marginBottom: '6px' }}>STATS</div>
                  <div style={{ fontSize: '9px', color: theme.textSecondary, background: theme.bgDark, padding: '8px', borderRadius: '6px' }}>
                    <div>Score: <span style={{ color: theme.gold, fontWeight: 600 }}>{totalScore.toLocaleString()}</span></div>
                    <div>Kills: <span style={{ color: theme.error, fontWeight: 600 }}>{killCount}</span></div>
                    <div>Best Combo: <span style={{ color: theme.accent, fontWeight: 600 }}>{maxCombo}</span></div>
                  </div>
                </>
              )}
            </div>}

            {/* Portrait mode: tower selection bar at bottom */}
            {!isLandscape && (
              <div style={{
                display: 'flex',
                gap: '6px',
                padding: '8px',
                background: theme.bgPanel,
                borderRadius: '10px',
                border: `1px solid ${theme.border}`,
                overflowX: 'auto',
                width: '100%',
                maxWidth: gridWidth,
              }}>
                {Object.values(towerTypes).map(tower => {
                  const canAfford = gold >= tower.cost;
                  const isSelected = selectedTower === tower.id;
                  return (
                    <div
                      key={tower.id}
                      onClick={() => canAfford && (setSelectedTower(tower.id), setSelectedTowerForUpgrade(null))}
                      style={{
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        padding: '6px 8px',
                        minWidth: '50px',
                        background: isSelected ? `${tower.color}30` : theme.bgDark,
                        borderRadius: '8px',
                        opacity: canAfford ? 1 : 0.4,
                        border: isSelected ? `2px solid ${tower.color}` : '1px solid transparent',
                        cursor: canAfford ? 'pointer' : 'not-allowed',
                      }}
                    >
                      {sprites.towers[tower.id] ? (
                        <img src={sprites.towers[tower.id]} alt={tower.name} style={{ width: 24, height: 24, imageRendering: 'pixelated' }} />
                      ) : (
                        <span style={{ fontSize: '20px' }}>{tower.emoji}</span>
                      )}
                      <span style={{ fontSize: '9px', color: theme.gold }}>{tower.cost}</span>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TowerDefenseGame />);
  </script>
</body>
</html>
